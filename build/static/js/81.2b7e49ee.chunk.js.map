{"version":3,"file":"static/js/81.2b7e49ee.chunk.js","mappings":"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","sources":["../node_modules/src/objects/GroundProjectedEnv.ts","../node_modules/src/loaders/RGBELoader.js","../node_modules/fflate/esm/browser.js","../node_modules/src/loaders/EXRLoader.js","../node_modules/@monogrid/gainmap-js/dist/QuadRenderer-6HrRQdJM.js","../node_modules/@monogrid/gainmap-js/dist/decode.js","../node_modules/@react-three/drei/helpers/environment-assets.js","../node_modules/@react-three/drei/helpers/deprecated.js","../node_modules/@react-three/drei/core/useEnvironment.js","../node_modules/@react-three/drei/core/Environment.js","../node_modules/src/controls/OrbitControls.ts","../node_modules/@react-three/drei/core/OrbitControls.js","../node_modules/src/geometries/TextGeometry.ts","../node_modules/src/loaders/FontLoader.ts","../node_modules/@react-three/drei/core/useFont.js","../node_modules/@react-three/drei/core/Text3D.js","../node_modules/src/utils/BufferGeometryUtils.ts"],"sourcesContent":["import {\n  Mesh,\n  IcosahedronGeometry,\n  ShaderMaterial,\n  DoubleSide,\n  Texture,\n  CubeTexture,\n  BufferGeometry,\n  REVISION,\n} from 'three'\n\nexport interface GroundProjectedEnvParameters {\n  height?: number\n  radius?: number\n}\n\nconst isCubeTexture = (def: CubeTexture | Texture): def is CubeTexture => def && (def as CubeTexture).isCubeTexture\n\nexport class GroundProjectedEnv extends Mesh<BufferGeometry, ShaderMaterial> {\n  constructor(texture: CubeTexture | Texture, options?: GroundProjectedEnvParameters) {\n    const isCubeMap = isCubeTexture(texture)\n    const w = (isCubeMap ? texture.image[0]?.width : texture.image.width) ?? 1024\n    const cubeSize = w / 4\n    const _lodMax = Math.floor(Math.log2(cubeSize))\n    const _cubeSize = Math.pow(2, _lodMax)\n    const width = 3 * Math.max(_cubeSize, 16 * 7)\n    const height = 4 * _cubeSize\n\n    const defines = [\n      isCubeMap ? '#define ENVMAP_TYPE_CUBE' : '',\n      `#define CUBEUV_TEXEL_WIDTH ${1.0 / width}`,\n      `#define CUBEUV_TEXEL_HEIGHT ${1.0 / height}`,\n      `#define CUBEUV_MAX_MIP ${_lodMax}.0`,\n    ]\n\n    const vertexShader = /* glsl */ `\n        varying vec3 vWorldPosition;\n        void main() \n        {\n            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );\n            vWorldPosition = worldPosition.xyz;\n            \n            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n        `\n    const fragmentShader =\n      defines.join('\\n') +\n      /* glsl */ `\n        #define ENVMAP_TYPE_CUBE_UV\n        varying vec3 vWorldPosition;\n        uniform float radius;\n        uniform float height;\n        uniform float angle;\n        #ifdef ENVMAP_TYPE_CUBE\n            uniform samplerCube map;\n        #else\n            uniform sampler2D map;\n        #endif\n        // From: https://www.shadertoy.com/view/4tsBD7\n        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) \n        {\n            float d = dot ( rd, n );\n            \n            if( d > 0.0 ) { return 1e6; }\n            \n            vec3  o = ro - c;\n            float t = - dot( n, o ) / d;\n            vec3  q = o + rd * t;\n            \n            return ( dot( q, q ) < r * r ) ? t : 1e6;\n        }\n        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) \n        {\n            vec3 oc = ro - ce;\n            float b = dot( oc, rd );\n            float c = dot( oc, oc ) - ra * ra;\n            float h = b * b - c;\n            \n            if( h < 0.0 ) { return -1.0; }\n            \n            h = sqrt( h );\n            \n            return - b + h;\n        }\n        vec3 project() \n        {\n            vec3 p = normalize( vWorldPosition );\n            vec3 camPos = cameraPosition;\n            camPos.y -= height;\n            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );\n            if( intersection > 0.0 ) {\n                \n                vec3 h = vec3( 0.0, - height, 0.0 );\n                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );\n                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;\n            } else {\n                p = vec3( 0.0, 1.0, 0.0 );\n            }\n            return p;\n        }\n        #include <common>\n        #include <cube_uv_reflection_fragment>\n        void main() \n        {\n            vec3 projectedWorldPosition = project();\n            \n            #ifdef ENVMAP_TYPE_CUBE\n                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;\n            #else\n                vec3 direction = normalize( projectedWorldPosition );\n                vec2 uv = equirectUv( direction );\n                vec3 outcolor = texture2D( map, uv ).rgb;\n            #endif\n            gl_FragColor = vec4( outcolor, 1.0 );\n            #include <tonemapping_fragment>\n            #include <${parseInt(REVISION.replace(/\\D+/g, '')) >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n        }\n        `\n\n    const uniforms = {\n      map: { value: texture },\n      height: { value: options?.height || 15 },\n      radius: { value: options?.radius || 100 },\n    }\n\n    const geometry = new IcosahedronGeometry(1, 16)\n    const material = new ShaderMaterial({\n      uniforms,\n      fragmentShader,\n      vertexShader,\n      side: DoubleSide,\n    })\n\n    super(geometry, material)\n  }\n\n  set radius(radius: number) {\n    this.material.uniforms.radius.value = radius\n  }\n\n  get radius(): number {\n    return this.material.uniforms.radius.value\n  }\n\n  set height(height: number) {\n    this.material.uniforms.height.value = height\n  }\n\n  get height(): number {\n    return this.material.uniforms.height.value\n  }\n}\n","import { DataTextureLoader, DataUtils, FloatType, HalfFloatType, LinearFilter } from 'three'\n\n// https://github.com/mrdoob/three.js/issues/5552\n// http://en.wikipedia.org/wiki/RGBE_image_format\n\nclass RGBELoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager)\n\n    this.type = HalfFloatType\n  }\n\n  // adapted from http://www.graphics.cornell.edu/~bjw/rgbe.html\n\n  parse(buffer) {\n    const /* default error routine.  change this to change error handling */\n      rgbe_read_error = 1,\n      rgbe_write_error = 2,\n      rgbe_format_error = 3,\n      rgbe_memory_error = 4,\n      rgbe_error = function (rgbe_error_code, msg) {\n        switch (rgbe_error_code) {\n          case rgbe_read_error:\n            throw new Error('THREE.RGBELoader: Read Error: ' + (msg || ''))\n          case rgbe_write_error:\n            throw new Error('THREE.RGBELoader: Write Error: ' + (msg || ''))\n          case rgbe_format_error:\n            throw new Error('THREE.RGBELoader: Bad File Format: ' + (msg || ''))\n          default:\n          case rgbe_memory_error:\n            throw new Error('THREE.RGBELoader: Memory Error: ' + (msg || ''))\n        }\n      },\n      /* offsets to red, green, and blue components in a data (float) pixel */\n      //RGBE_DATA_RED = 0,\n      //RGBE_DATA_GREEN = 1,\n      //RGBE_DATA_BLUE = 2,\n\n      /* number of floats per pixel, use 4 since stored in rgba image format */\n      //RGBE_DATA_SIZE = 4,\n\n      /* flags indicating which fields in an rgbe_header_info are valid */\n      RGBE_VALID_PROGRAMTYPE = 1,\n      RGBE_VALID_FORMAT = 2,\n      RGBE_VALID_DIMENSIONS = 4,\n      NEWLINE = '\\n',\n      fgets = function (buffer, lineLimit, consume) {\n        const chunkSize = 128\n\n        lineLimit = !lineLimit ? 1024 : lineLimit\n        let p = buffer.pos,\n          i = -1,\n          len = 0,\n          s = '',\n          chunk = String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)))\n\n        while (0 > (i = chunk.indexOf(NEWLINE)) && len < lineLimit && p < buffer.byteLength) {\n          s += chunk\n          len += chunk.length\n          p += chunkSize\n          chunk += String.fromCharCode.apply(null, new Uint16Array(buffer.subarray(p, p + chunkSize)))\n        }\n\n        if (-1 < i) {\n          /*for (i=l-1; i>=0; i--) {\n\t\t\t\t\t\tbyteCode = m.charCodeAt(i);\n\t\t\t\t\t\tif (byteCode > 0x7f && byteCode <= 0x7ff) byteLen++;\n\t\t\t\t\t\telse if (byteCode > 0x7ff && byteCode <= 0xffff) byteLen += 2;\n\t\t\t\t\t\tif (byteCode >= 0xDC00 && byteCode <= 0xDFFF) i--; //trail surrogate\n\t\t\t\t\t}*/\n          if (false !== consume) buffer.pos += len + i + 1\n          return s + chunk.slice(0, i)\n        }\n\n        return false\n      },\n      /* minimal header reading.  modify if you want to parse more information */\n      RGBE_ReadHeader = function (buffer) {\n        // regexes to parse header info fields\n        const magic_token_re = /^#\\?(\\S+)/,\n          gamma_re = /^\\s*GAMMA\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          exposure_re = /^\\s*EXPOSURE\\s*=\\s*(\\d+(\\.\\d+)?)\\s*$/,\n          format_re = /^\\s*FORMAT=(\\S+)\\s*$/,\n          dimensions_re = /^\\s*\\-Y\\s+(\\d+)\\s+\\+X\\s+(\\d+)\\s*$/,\n          // RGBE format header struct\n          header = {\n            valid: 0 /* indicate which fields are valid */,\n\n            string: '' /* the actual header string */,\n\n            comments: '' /* comments found in header */,\n\n            programtype: 'RGBE' /* listed at beginning of file to identify it after \"#?\". defaults to \"RGBE\" */,\n\n            format: '' /* RGBE format, default 32-bit_rle_rgbe */,\n\n            gamma: 1.0 /* image has already been gamma corrected with given gamma. defaults to 1.0 (no correction) */,\n\n            exposure: 1.0 /* a value of 1.0 in an image corresponds to <exposure> watts/steradian/m^2. defaults to 1.0 */,\n\n            width: 0,\n            height: 0 /* image dimensions, width/height */,\n          }\n\n        let line, match\n\n        if (buffer.pos >= buffer.byteLength || !(line = fgets(buffer))) {\n          rgbe_error(rgbe_read_error, 'no header found')\n        }\n\n        /* if you want to require the magic token then uncomment the next line */\n        if (!(match = line.match(magic_token_re))) {\n          rgbe_error(rgbe_format_error, 'bad initial token')\n        }\n\n        header.valid |= RGBE_VALID_PROGRAMTYPE\n        header.programtype = match[1]\n        header.string += line + '\\n'\n\n        while (true) {\n          line = fgets(buffer)\n          if (false === line) break\n          header.string += line + '\\n'\n\n          if ('#' === line.charAt(0)) {\n            header.comments += line + '\\n'\n            continue // comment line\n          }\n\n          if ((match = line.match(gamma_re))) {\n            header.gamma = parseFloat(match[1])\n          }\n\n          if ((match = line.match(exposure_re))) {\n            header.exposure = parseFloat(match[1])\n          }\n\n          if ((match = line.match(format_re))) {\n            header.valid |= RGBE_VALID_FORMAT\n            header.format = match[1] //'32-bit_rle_rgbe';\n          }\n\n          if ((match = line.match(dimensions_re))) {\n            header.valid |= RGBE_VALID_DIMENSIONS\n            header.height = parseInt(match[1], 10)\n            header.width = parseInt(match[2], 10)\n          }\n\n          if (header.valid & RGBE_VALID_FORMAT && header.valid & RGBE_VALID_DIMENSIONS) break\n        }\n\n        if (!(header.valid & RGBE_VALID_FORMAT)) {\n          rgbe_error(rgbe_format_error, 'missing format specifier')\n        }\n\n        if (!(header.valid & RGBE_VALID_DIMENSIONS)) {\n          rgbe_error(rgbe_format_error, 'missing image size specifier')\n        }\n\n        return header\n      },\n      RGBE_ReadPixels_RLE = function (buffer, w, h) {\n        const scanline_width = w\n\n        if (\n          // run length encoding is not allowed so read flat\n          scanline_width < 8 ||\n          scanline_width > 0x7fff ||\n          // this file is not run length encoded\n          2 !== buffer[0] ||\n          2 !== buffer[1] ||\n          buffer[2] & 0x80\n        ) {\n          // return the flat buffer\n          return new Uint8Array(buffer)\n        }\n\n        if (scanline_width !== ((buffer[2] << 8) | buffer[3])) {\n          rgbe_error(rgbe_format_error, 'wrong scanline width')\n        }\n\n        const data_rgba = new Uint8Array(4 * w * h)\n\n        if (!data_rgba.length) {\n          rgbe_error(rgbe_memory_error, 'unable to allocate buffer space')\n        }\n\n        let offset = 0,\n          pos = 0\n\n        const ptr_end = 4 * scanline_width\n        const rgbeStart = new Uint8Array(4)\n        const scanline_buffer = new Uint8Array(ptr_end)\n        let num_scanlines = h\n\n        // read in each successive scanline\n        while (num_scanlines > 0 && pos < buffer.byteLength) {\n          if (pos + 4 > buffer.byteLength) {\n            rgbe_error(rgbe_read_error)\n          }\n\n          rgbeStart[0] = buffer[pos++]\n          rgbeStart[1] = buffer[pos++]\n          rgbeStart[2] = buffer[pos++]\n          rgbeStart[3] = buffer[pos++]\n\n          if (2 != rgbeStart[0] || 2 != rgbeStart[1] || ((rgbeStart[2] << 8) | rgbeStart[3]) != scanline_width) {\n            rgbe_error(rgbe_format_error, 'bad rgbe scanline format')\n          }\n\n          // read each of the four channels for the scanline into the buffer\n          // first red, then green, then blue, then exponent\n          let ptr = 0,\n            count\n\n          while (ptr < ptr_end && pos < buffer.byteLength) {\n            count = buffer[pos++]\n            const isEncodedRun = count > 128\n            if (isEncodedRun) count -= 128\n\n            if (0 === count || ptr + count > ptr_end) {\n              rgbe_error(rgbe_format_error, 'bad scanline data')\n            }\n\n            if (isEncodedRun) {\n              // a (encoded) run of the same value\n              const byteValue = buffer[pos++]\n              for (let i = 0; i < count; i++) {\n                scanline_buffer[ptr++] = byteValue\n              }\n              //ptr += count;\n            } else {\n              // a literal-run\n              scanline_buffer.set(buffer.subarray(pos, pos + count), ptr)\n              ptr += count\n              pos += count\n            }\n          }\n\n          // now convert data from buffer into rgba\n          // first red, then green, then blue, then exponent (alpha)\n          const l = scanline_width //scanline_buffer.byteLength;\n          for (let i = 0; i < l; i++) {\n            let off = 0\n            data_rgba[offset] = scanline_buffer[i + off]\n            off += scanline_width //1;\n            data_rgba[offset + 1] = scanline_buffer[i + off]\n            off += scanline_width //1;\n            data_rgba[offset + 2] = scanline_buffer[i + off]\n            off += scanline_width //1;\n            data_rgba[offset + 3] = scanline_buffer[i + off]\n            offset += 4\n          }\n\n          num_scanlines--\n        }\n\n        return data_rgba\n      }\n\n    const RGBEByteToRGBFloat = function (sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3]\n      const scale = Math.pow(2.0, e - 128.0) / 255.0\n\n      destArray[destOffset + 0] = sourceArray[sourceOffset + 0] * scale\n      destArray[destOffset + 1] = sourceArray[sourceOffset + 1] * scale\n      destArray[destOffset + 2] = sourceArray[sourceOffset + 2] * scale\n      destArray[destOffset + 3] = 1\n    }\n\n    const RGBEByteToRGBHalf = function (sourceArray, sourceOffset, destArray, destOffset) {\n      const e = sourceArray[sourceOffset + 3]\n      const scale = Math.pow(2.0, e - 128.0) / 255.0\n\n      // clamping to 65504, the maximum representable value in float16\n      destArray[destOffset + 0] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 0] * scale, 65504))\n      destArray[destOffset + 1] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 1] * scale, 65504))\n      destArray[destOffset + 2] = DataUtils.toHalfFloat(Math.min(sourceArray[sourceOffset + 2] * scale, 65504))\n      destArray[destOffset + 3] = DataUtils.toHalfFloat(1)\n    }\n\n    const byteArray = new Uint8Array(buffer)\n    byteArray.pos = 0\n    const rgbe_header_info = RGBE_ReadHeader(byteArray)\n\n    const w = rgbe_header_info.width,\n      h = rgbe_header_info.height,\n      image_rgba_data = RGBE_ReadPixels_RLE(byteArray.subarray(byteArray.pos), w, h)\n\n    let data, type\n    let numElements\n\n    switch (this.type) {\n      case FloatType:\n        numElements = image_rgba_data.length / 4\n        const floatArray = new Float32Array(numElements * 4)\n\n        for (let j = 0; j < numElements; j++) {\n          RGBEByteToRGBFloat(image_rgba_data, j * 4, floatArray, j * 4)\n        }\n\n        data = floatArray\n        type = FloatType\n        break\n\n      case HalfFloatType:\n        numElements = image_rgba_data.length / 4\n        const halfArray = new Uint16Array(numElements * 4)\n\n        for (let j = 0; j < numElements; j++) {\n          RGBEByteToRGBHalf(image_rgba_data, j * 4, halfArray, j * 4)\n        }\n\n        data = halfArray\n        type = HalfFloatType\n        break\n\n      default:\n        throw new Error('THREE.RGBELoader: Unsupported type: ' + this.type)\n        break\n    }\n\n    return {\n      width: w,\n      height: h,\n      data: data,\n      header: rgbe_header_info.string,\n      gamma: rgbe_header_info.gamma,\n      exposure: rgbe_header_info.exposure,\n      type: type,\n    }\n  }\n\n  setDataType(value) {\n    this.type = value\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      switch (texture.type) {\n        case FloatType:\n        case HalfFloatType:\n          if ('colorSpace' in texture) texture.colorSpace = 'srgb-linear'\n          else texture.encoding = 3000 // LinearEncoding\n          texture.minFilter = LinearFilter\n          texture.magFilter = LinearFilter\n          texture.generateMipmaps = false\n          texture.flipY = true\n\n          break\n      }\n\n      if (onLoad) onLoad(texture, texData)\n    }\n\n    return super.load(url, onLoadCallback, onProgress, onError)\n  }\n}\n\nexport { RGBELoader }\n","// DEFLATE is a complex format; to read this code, you should probably check the RFC first:\n// https://tools.ietf.org/html/rfc1951\n// You may also wish to take a look at the guide I made about this program:\n// https://gist.github.com/101arrowz/253f31eb5abc3d9275ab943003ffecad\n// Some of the following code is similar to that of UZIP.js:\n// https://github.com/photopea/UZIP.js\n// However, the vast majority of the codebase has diverged from UZIP.js to increase performance and reduce bundle size.\n// Sometimes 0 will appear where -1 would be more appropriate. This is because using a uint\n// is better for memory in most engines (I *think*).\nvar ch2 = {};\nvar wk = (function (c, id, msg, transfer, cb) {\n    var w = new Worker(ch2[id] || (ch2[id] = URL.createObjectURL(new Blob([c], { type: 'text/javascript' }))));\n    w.onerror = function (e) { return cb(e.error, null); };\n    w.onmessage = function (e) { return cb(null, e.data); };\n    w.postMessage(msg, transfer);\n    return w;\n});\n\n// aliases for shorter compressed code (most minifers don't do this)\nvar u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;\n// fixed length extra bits\nvar fleb = new u8([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, /* unused */ 0, 0, /* impossible */ 0]);\n// fixed distance extra bits\n// see fleb note\nvar fdeb = new u8([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, /* unused */ 0, 0]);\n// code length index map\nvar clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);\n// get base, reverse index map from extra bits\nvar freb = function (eb, start) {\n    var b = new u16(31);\n    for (var i = 0; i < 31; ++i) {\n        b[i] = start += 1 << eb[i - 1];\n    }\n    // numbers here are at max 18 bits\n    var r = new u32(b[30]);\n    for (var i = 1; i < 30; ++i) {\n        for (var j = b[i]; j < b[i + 1]; ++j) {\n            r[j] = ((j - b[i]) << 5) | i;\n        }\n    }\n    return [b, r];\n};\nvar _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];\n// we can ignore the fact that the other numbers are wrong; they never happen anyway\nfl[28] = 258, revfl[258] = 28;\nvar _b = freb(fdeb, 0), fd = _b[0], revfd = _b[1];\n// map of value to reverse (assuming 16 bits)\nvar rev = new u16(32768);\nfor (var i = 0; i < 32768; ++i) {\n    // reverse table algorithm from SO\n    var x = ((i & 0xAAAA) >>> 1) | ((i & 0x5555) << 1);\n    x = ((x & 0xCCCC) >>> 2) | ((x & 0x3333) << 2);\n    x = ((x & 0xF0F0) >>> 4) | ((x & 0x0F0F) << 4);\n    rev[i] = (((x & 0xFF00) >>> 8) | ((x & 0x00FF) << 8)) >>> 1;\n}\n// create huffman tree from u8 \"map\": index -> code length for code index\n// mb (max bits) must be at most 15\n// TODO: optimize/split up?\nvar hMap = (function (cd, mb, r) {\n    var s = cd.length;\n    // index\n    var i = 0;\n    // u16 \"map\": index -> # of codes with bit length = index\n    var l = new u16(mb);\n    // length of cd must be 288 (total # of codes)\n    for (; i < s; ++i)\n        ++l[cd[i] - 1];\n    // u16 \"map\": index -> minimum code for bit length = index\n    var le = new u16(mb);\n    for (i = 0; i < mb; ++i) {\n        le[i] = (le[i - 1] + l[i - 1]) << 1;\n    }\n    var co;\n    if (r) {\n        // u16 \"map\": index -> number of actual bits, symbol for code\n        co = new u16(1 << mb);\n        // bits to remove for reverser\n        var rvb = 15 - mb;\n        for (i = 0; i < s; ++i) {\n            // ignore 0 lengths\n            if (cd[i]) {\n                // num encoding both symbol and bits read\n                var sv = (i << 4) | cd[i];\n                // free bits\n                var r_1 = mb - cd[i];\n                // start value\n                var v = le[cd[i] - 1]++ << r_1;\n                // m is end value\n                for (var m = v | ((1 << r_1) - 1); v <= m; ++v) {\n                    // every 16 bit value starting with the code yields the same result\n                    co[rev[v] >>> rvb] = sv;\n                }\n            }\n        }\n    }\n    else {\n        co = new u16(s);\n        for (i = 0; i < s; ++i) {\n            if (cd[i]) {\n                co[i] = rev[le[cd[i] - 1]++] >>> (15 - cd[i]);\n            }\n        }\n    }\n    return co;\n});\n// fixed length tree\nvar flt = new u8(288);\nfor (var i = 0; i < 144; ++i)\n    flt[i] = 8;\nfor (var i = 144; i < 256; ++i)\n    flt[i] = 9;\nfor (var i = 256; i < 280; ++i)\n    flt[i] = 7;\nfor (var i = 280; i < 288; ++i)\n    flt[i] = 8;\n// fixed distance tree\nvar fdt = new u8(32);\nfor (var i = 0; i < 32; ++i)\n    fdt[i] = 5;\n// fixed length map\nvar flm = /*#__PURE__*/ hMap(flt, 9, 0), flrm = /*#__PURE__*/ hMap(flt, 9, 1);\n// fixed distance map\nvar fdm = /*#__PURE__*/ hMap(fdt, 5, 0), fdrm = /*#__PURE__*/ hMap(fdt, 5, 1);\n// find max of array\nvar max = function (a) {\n    var m = a[0];\n    for (var i = 1; i < a.length; ++i) {\n        if (a[i] > m)\n            m = a[i];\n    }\n    return m;\n};\n// read d, starting at bit p and mask with m\nvar bits = function (d, p, m) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8)) >> (p & 7)) & m;\n};\n// read d, starting at bit p continuing for at least 16 bits\nvar bits16 = function (d, p) {\n    var o = (p / 8) | 0;\n    return ((d[o] | (d[o + 1] << 8) | (d[o + 2] << 16)) >> (p & 7));\n};\n// get end of byte\nvar shft = function (p) { return ((p / 8) | 0) + (p & 7 && 1); };\n// typed array slice - allows garbage collector to free original reference,\n// while being more compatible than .slice\nvar slc = function (v, s, e) {\n    if (s == null || s < 0)\n        s = 0;\n    if (e == null || e > v.length)\n        e = v.length;\n    // can't use .constructor in case user-supplied\n    var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s);\n    n.set(v.subarray(s, e));\n    return n;\n};\n// expands raw DEFLATE data\nvar inflt = function (dat, buf, st) {\n    // source length\n    var sl = dat.length;\n    if (!sl || (st && !st.l && sl < 5))\n        return buf || new u8(0);\n    // have to estimate size\n    var noBuf = !buf || st;\n    // no state\n    var noSt = !st || st.i;\n    if (!st)\n        st = {};\n    // Assumes roughly 33% compression ratio average\n    if (!buf)\n        buf = new u8(sl * 3);\n    // ensure buffer can fit at least l elements\n    var cbuf = function (l) {\n        var bl = buf.length;\n        // need to increase size to fit\n        if (l > bl) {\n            // Double or set to necessary, whichever is greater\n            var nbuf = new u8(Math.max(bl * 2, l));\n            nbuf.set(buf);\n            buf = nbuf;\n        }\n    };\n    //  last chunk         bitpos           bytes\n    var final = st.f || 0, pos = st.p || 0, bt = st.b || 0, lm = st.l, dm = st.d, lbt = st.m, dbt = st.n;\n    // total bits\n    var tbts = sl * 8;\n    do {\n        if (!lm) {\n            // BFINAL - this is only 1 when last chunk is next\n            st.f = final = bits(dat, pos, 1);\n            // type: 0 = no compression, 1 = fixed huffman, 2 = dynamic huffman\n            var type = bits(dat, pos + 1, 3);\n            pos += 3;\n            if (!type) {\n                // go to end of byte boundary\n                var s = shft(pos) + 4, l = dat[s - 4] | (dat[s - 3] << 8), t = s + l;\n                if (t > sl) {\n                    if (noSt)\n                        throw 'unexpected EOF';\n                    break;\n                }\n                // ensure size\n                if (noBuf)\n                    cbuf(bt + l);\n                // Copy over uncompressed data\n                buf.set(dat.subarray(s, t), bt);\n                // Get new bitpos, update byte count\n                st.b = bt += l, st.p = pos = t * 8;\n                continue;\n            }\n            else if (type == 1)\n                lm = flrm, dm = fdrm, lbt = 9, dbt = 5;\n            else if (type == 2) {\n                //  literal                            lengths\n                var hLit = bits(dat, pos, 31) + 257, hcLen = bits(dat, pos + 10, 15) + 4;\n                var tl = hLit + bits(dat, pos + 5, 31) + 1;\n                pos += 14;\n                // length+distance tree\n                var ldt = new u8(tl);\n                // code length tree\n                var clt = new u8(19);\n                for (var i = 0; i < hcLen; ++i) {\n                    // use index map to get real code\n                    clt[clim[i]] = bits(dat, pos + i * 3, 7);\n                }\n                pos += hcLen * 3;\n                // code lengths bits\n                var clb = max(clt), clbmsk = (1 << clb) - 1;\n                // code lengths map\n                var clm = hMap(clt, clb, 1);\n                for (var i = 0; i < tl;) {\n                    var r = clm[bits(dat, pos, clbmsk)];\n                    // bits read\n                    pos += r & 15;\n                    // symbol\n                    var s = r >>> 4;\n                    // code length to copy\n                    if (s < 16) {\n                        ldt[i++] = s;\n                    }\n                    else {\n                        //  copy   count\n                        var c = 0, n = 0;\n                        if (s == 16)\n                            n = 3 + bits(dat, pos, 3), pos += 2, c = ldt[i - 1];\n                        else if (s == 17)\n                            n = 3 + bits(dat, pos, 7), pos += 3;\n                        else if (s == 18)\n                            n = 11 + bits(dat, pos, 127), pos += 7;\n                        while (n--)\n                            ldt[i++] = c;\n                    }\n                }\n                //    length tree                 distance tree\n                var lt = ldt.subarray(0, hLit), dt = ldt.subarray(hLit);\n                // max length bits\n                lbt = max(lt);\n                // max dist bits\n                dbt = max(dt);\n                lm = hMap(lt, lbt, 1);\n                dm = hMap(dt, dbt, 1);\n            }\n            else\n                throw 'invalid block type';\n            if (pos > tbts) {\n                if (noSt)\n                    throw 'unexpected EOF';\n                break;\n            }\n        }\n        // Make sure the buffer can hold this + the largest possible addition\n        // Maximum chunk size (practically, theoretically infinite) is 2^17;\n        if (noBuf)\n            cbuf(bt + 131072);\n        var lms = (1 << lbt) - 1, dms = (1 << dbt) - 1;\n        var lpos = pos;\n        for (;; lpos = pos) {\n            // bits read, code\n            var c = lm[bits16(dat, pos) & lms], sym = c >>> 4;\n            pos += c & 15;\n            if (pos > tbts) {\n                if (noSt)\n                    throw 'unexpected EOF';\n                break;\n            }\n            if (!c)\n                throw 'invalid length/literal';\n            if (sym < 256)\n                buf[bt++] = sym;\n            else if (sym == 256) {\n                lpos = pos, lm = null;\n                break;\n            }\n            else {\n                var add = sym - 254;\n                // no extra bits needed if less\n                if (sym > 264) {\n                    // index\n                    var i = sym - 257, b = fleb[i];\n                    add = bits(dat, pos, (1 << b) - 1) + fl[i];\n                    pos += b;\n                }\n                // dist\n                var d = dm[bits16(dat, pos) & dms], dsym = d >>> 4;\n                if (!d)\n                    throw 'invalid distance';\n                pos += d & 15;\n                var dt = fd[dsym];\n                if (dsym > 3) {\n                    var b = fdeb[dsym];\n                    dt += bits16(dat, pos) & ((1 << b) - 1), pos += b;\n                }\n                if (pos > tbts) {\n                    if (noSt)\n                        throw 'unexpected EOF';\n                    break;\n                }\n                if (noBuf)\n                    cbuf(bt + 131072);\n                var end = bt + add;\n                for (; bt < end; bt += 4) {\n                    buf[bt] = buf[bt - dt];\n                    buf[bt + 1] = buf[bt + 1 - dt];\n                    buf[bt + 2] = buf[bt + 2 - dt];\n                    buf[bt + 3] = buf[bt + 3 - dt];\n                }\n                bt = end;\n            }\n        }\n        st.l = lm, st.p = lpos, st.b = bt;\n        if (lm)\n            final = 1, st.m = lbt, st.d = dm, st.n = dbt;\n    } while (!final);\n    return bt == buf.length ? buf : slc(buf, 0, bt);\n};\n// starting at p, write the minimum number of bits that can hold v to d\nvar wbits = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n};\n// starting at p, write the minimum number of bits (>8) that can hold v to d\nvar wbits16 = function (d, p, v) {\n    v <<= p & 7;\n    var o = (p / 8) | 0;\n    d[o] |= v;\n    d[o + 1] |= v >>> 8;\n    d[o + 2] |= v >>> 16;\n};\n// creates code lengths from a frequency table\nvar hTree = function (d, mb) {\n    // Need extra info to make a tree\n    var t = [];\n    for (var i = 0; i < d.length; ++i) {\n        if (d[i])\n            t.push({ s: i, f: d[i] });\n    }\n    var s = t.length;\n    var t2 = t.slice();\n    if (!s)\n        return [et, 0];\n    if (s == 1) {\n        var v = new u8(t[0].s + 1);\n        v[t[0].s] = 1;\n        return [v, 1];\n    }\n    t.sort(function (a, b) { return a.f - b.f; });\n    // after i2 reaches last ind, will be stopped\n    // freq must be greater than largest possible number of symbols\n    t.push({ s: -1, f: 25001 });\n    var l = t[0], r = t[1], i0 = 0, i1 = 1, i2 = 2;\n    t[0] = { s: -1, f: l.f + r.f, l: l, r: r };\n    // efficient algorithm from UZIP.js\n    // i0 is lookbehind, i2 is lookahead - after processing two low-freq\n    // symbols that combined have high freq, will start processing i2 (high-freq,\n    // non-composite) symbols instead\n    // see https://reddit.com/r/photopea/comments/ikekht/uzipjs_questions/\n    while (i1 != s - 1) {\n        l = t[t[i0].f < t[i2].f ? i0++ : i2++];\n        r = t[i0 != i1 && t[i0].f < t[i2].f ? i0++ : i2++];\n        t[i1++] = { s: -1, f: l.f + r.f, l: l, r: r };\n    }\n    var maxSym = t2[0].s;\n    for (var i = 1; i < s; ++i) {\n        if (t2[i].s > maxSym)\n            maxSym = t2[i].s;\n    }\n    // code lengths\n    var tr = new u16(maxSym + 1);\n    // max bits in tree\n    var mbt = ln(t[i1 - 1], tr, 0);\n    if (mbt > mb) {\n        // more algorithms from UZIP.js\n        // TODO: find out how this code works (debt)\n        //  ind    debt\n        var i = 0, dt = 0;\n        //    left            cost\n        var lft = mbt - mb, cst = 1 << lft;\n        t2.sort(function (a, b) { return tr[b.s] - tr[a.s] || a.f - b.f; });\n        for (; i < s; ++i) {\n            var i2_1 = t2[i].s;\n            if (tr[i2_1] > mb) {\n                dt += cst - (1 << (mbt - tr[i2_1]));\n                tr[i2_1] = mb;\n            }\n            else\n                break;\n        }\n        dt >>>= lft;\n        while (dt > 0) {\n            var i2_2 = t2[i].s;\n            if (tr[i2_2] < mb)\n                dt -= 1 << (mb - tr[i2_2]++ - 1);\n            else\n                ++i;\n        }\n        for (; i >= 0 && dt; --i) {\n            var i2_3 = t2[i].s;\n            if (tr[i2_3] == mb) {\n                --tr[i2_3];\n                ++dt;\n            }\n        }\n        mbt = mb;\n    }\n    return [new u8(tr), mbt];\n};\n// get the max length and assign length codes\nvar ln = function (n, l, d) {\n    return n.s == -1\n        ? Math.max(ln(n.l, l, d + 1), ln(n.r, l, d + 1))\n        : (l[n.s] = d);\n};\n// length codes generation\nvar lc = function (c) {\n    var s = c.length;\n    // Note that the semicolon was intentional\n    while (s && !c[--s])\n        ;\n    var cl = new u16(++s);\n    //  ind      num         streak\n    var cli = 0, cln = c[0], cls = 1;\n    var w = function (v) { cl[cli++] = v; };\n    for (var i = 1; i <= s; ++i) {\n        if (c[i] == cln && i != s)\n            ++cls;\n        else {\n            if (!cln && cls > 2) {\n                for (; cls > 138; cls -= 138)\n                    w(32754);\n                if (cls > 2) {\n                    w(cls > 10 ? ((cls - 11) << 5) | 28690 : ((cls - 3) << 5) | 12305);\n                    cls = 0;\n                }\n            }\n            else if (cls > 3) {\n                w(cln), --cls;\n                for (; cls > 6; cls -= 6)\n                    w(8304);\n                if (cls > 2)\n                    w(((cls - 3) << 5) | 8208), cls = 0;\n            }\n            while (cls--)\n                w(cln);\n            cls = 1;\n            cln = c[i];\n        }\n    }\n    return [cl.subarray(0, cli), s];\n};\n// calculate the length of output from tree, code lengths\nvar clen = function (cf, cl) {\n    var l = 0;\n    for (var i = 0; i < cl.length; ++i)\n        l += cf[i] * cl[i];\n    return l;\n};\n// writes a fixed block\n// returns the new bit pos\nvar wfblk = function (out, pos, dat) {\n    // no need to write 00 as type: TypedArray defaults to 0\n    var s = dat.length;\n    var o = shft(pos + 2);\n    out[o] = s & 255;\n    out[o + 1] = s >>> 8;\n    out[o + 2] = out[o] ^ 255;\n    out[o + 3] = out[o + 1] ^ 255;\n    for (var i = 0; i < s; ++i)\n        out[o + i + 4] = dat[i];\n    return (o + 4 + s) * 8;\n};\n// writes a block\nvar wblk = function (dat, out, final, syms, lf, df, eb, li, bs, bl, p) {\n    wbits(out, p++, final);\n    ++lf[256];\n    var _a = hTree(lf, 15), dlt = _a[0], mlb = _a[1];\n    var _b = hTree(df, 15), ddt = _b[0], mdb = _b[1];\n    var _c = lc(dlt), lclt = _c[0], nlc = _c[1];\n    var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];\n    var lcfreq = new u16(19);\n    for (var i = 0; i < lclt.length; ++i)\n        lcfreq[lclt[i] & 31]++;\n    for (var i = 0; i < lcdt.length; ++i)\n        lcfreq[lcdt[i] & 31]++;\n    var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];\n    var nlcc = 19;\n    for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc)\n        ;\n    var flen = (bl + 5) << 3;\n    var ftlen = clen(lf, flt) + clen(df, fdt) + eb;\n    var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);\n    if (flen <= ftlen && flen <= dtlen)\n        return wfblk(out, p, dat.subarray(bs, bs + bl));\n    var lm, ll, dm, dl;\n    wbits(out, p, 1 + (dtlen < ftlen)), p += 2;\n    if (dtlen < ftlen) {\n        lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;\n        var llm = hMap(lct, mlcb, 0);\n        wbits(out, p, nlc - 257);\n        wbits(out, p + 5, ndc - 1);\n        wbits(out, p + 10, nlcc - 4);\n        p += 14;\n        for (var i = 0; i < nlcc; ++i)\n            wbits(out, p + 3 * i, lct[clim[i]]);\n        p += 3 * nlcc;\n        var lcts = [lclt, lcdt];\n        for (var it = 0; it < 2; ++it) {\n            var clct = lcts[it];\n            for (var i = 0; i < clct.length; ++i) {\n                var len = clct[i] & 31;\n                wbits(out, p, llm[len]), p += lct[len];\n                if (len > 15)\n                    wbits(out, p, (clct[i] >>> 5) & 127), p += clct[i] >>> 12;\n            }\n        }\n    }\n    else {\n        lm = flm, ll = flt, dm = fdm, dl = fdt;\n    }\n    for (var i = 0; i < li; ++i) {\n        if (syms[i] > 255) {\n            var len = (syms[i] >>> 18) & 31;\n            wbits16(out, p, lm[len + 257]), p += ll[len + 257];\n            if (len > 7)\n                wbits(out, p, (syms[i] >>> 23) & 31), p += fleb[len];\n            var dst = syms[i] & 31;\n            wbits16(out, p, dm[dst]), p += dl[dst];\n            if (dst > 3)\n                wbits16(out, p, (syms[i] >>> 5) & 8191), p += fdeb[dst];\n        }\n        else {\n            wbits16(out, p, lm[syms[i]]), p += ll[syms[i]];\n        }\n    }\n    wbits16(out, p, lm[256]);\n    return p + ll[256];\n};\n// deflate options (nice << 13) | chain\nvar deo = /*#__PURE__*/ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);\n// empty\nvar et = /*#__PURE__*/ new u8(0);\n// compresses data into a raw DEFLATE buffer\nvar dflt = function (dat, lvl, plvl, pre, post, lst) {\n    var s = dat.length;\n    var o = new u8(pre + s + 5 * (1 + Math.ceil(s / 7000)) + post);\n    // writing to this writes to the output buffer\n    var w = o.subarray(pre, o.length - post);\n    var pos = 0;\n    if (!lvl || s < 8) {\n        for (var i = 0; i <= s; i += 65535) {\n            // end\n            var e = i + 65535;\n            if (e < s) {\n                // write full block\n                pos = wfblk(w, pos, dat.subarray(i, e));\n            }\n            else {\n                // write final block\n                w[i] = lst;\n                pos = wfblk(w, pos, dat.subarray(i, s));\n            }\n        }\n    }\n    else {\n        var opt = deo[lvl - 1];\n        var n = opt >>> 13, c = opt & 8191;\n        var msk_1 = (1 << plvl) - 1;\n        //    prev 2-byte val map    curr 2-byte val map\n        var prev = new u16(32768), head = new u16(msk_1 + 1);\n        var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;\n        var hsh = function (i) { return (dat[i] ^ (dat[i + 1] << bs1_1) ^ (dat[i + 2] << bs2_1)) & msk_1; };\n        // 24576 is an arbitrary number of maximum symbols per block\n        // 424 buffer for last block\n        var syms = new u32(25000);\n        // length/literal freq   distance freq\n        var lf = new u16(288), df = new u16(32);\n        //  l/lcnt  exbits  index  l/lind  waitdx  bitpos\n        var lc_1 = 0, eb = 0, i = 0, li = 0, wi = 0, bs = 0;\n        for (; i < s; ++i) {\n            // hash value\n            // deopt when i > s - 3 - at end, deopt acceptable\n            var hv = hsh(i);\n            // index mod 32768    previous index mod\n            var imod = i & 32767, pimod = head[hv];\n            prev[imod] = pimod;\n            head[hv] = imod;\n            // We always should modify head and prev, but only add symbols if\n            // this data is not yet processed (\"wait\" for wait index)\n            if (wi <= i) {\n                // bytes remaining\n                var rem = s - i;\n                if ((lc_1 > 7000 || li > 24576) && rem > 423) {\n                    pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i - bs, pos);\n                    li = lc_1 = eb = 0, bs = i;\n                    for (var j = 0; j < 286; ++j)\n                        lf[j] = 0;\n                    for (var j = 0; j < 30; ++j)\n                        df[j] = 0;\n                }\n                //  len    dist   chain\n                var l = 2, d = 0, ch_1 = c, dif = (imod - pimod) & 32767;\n                if (rem > 2 && hv == hsh(i - dif)) {\n                    var maxn = Math.min(n, rem) - 1;\n                    var maxd = Math.min(32767, i);\n                    // max possible length\n                    // not capped at dif because decompressors implement \"rolling\" index population\n                    var ml = Math.min(258, rem);\n                    while (dif <= maxd && --ch_1 && imod != pimod) {\n                        if (dat[i + l] == dat[i + l - dif]) {\n                            var nl = 0;\n                            for (; nl < ml && dat[i + nl] == dat[i + nl - dif]; ++nl)\n                                ;\n                            if (nl > l) {\n                                l = nl, d = dif;\n                                // break out early when we reach \"nice\" (we are satisfied enough)\n                                if (nl > maxn)\n                                    break;\n                                // now, find the rarest 2-byte sequence within this\n                                // length of literals and search for that instead.\n                                // Much faster than just using the start\n                                var mmd = Math.min(dif, nl - 2);\n                                var md = 0;\n                                for (var j = 0; j < mmd; ++j) {\n                                    var ti = (i - dif + j + 32768) & 32767;\n                                    var pti = prev[ti];\n                                    var cd = (ti - pti + 32768) & 32767;\n                                    if (cd > md)\n                                        md = cd, pimod = ti;\n                                }\n                            }\n                        }\n                        // check the previous match\n                        imod = pimod, pimod = prev[imod];\n                        dif += (imod - pimod + 32768) & 32767;\n                    }\n                }\n                // d will be nonzero only when a match was found\n                if (d) {\n                    // store both dist and len data in one Uint32\n                    // Make sure this is recognized as a len/dist with 28th bit (2^28)\n                    syms[li++] = 268435456 | (revfl[l] << 18) | revfd[d];\n                    var lin = revfl[l] & 31, din = revfd[d] & 31;\n                    eb += fleb[lin] + fdeb[din];\n                    ++lf[257 + lin];\n                    ++df[din];\n                    wi = i + l;\n                    ++lc_1;\n                }\n                else {\n                    syms[li++] = dat[i];\n                    ++lf[dat[i]];\n                }\n            }\n        }\n        pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i - bs, pos);\n        // this is the easiest way to avoid needing to maintain state\n        if (!lst && pos & 7)\n            pos = wfblk(w, pos + 1, et);\n    }\n    return slc(o, 0, pre + shft(pos) + post);\n};\n// CRC32 table\nvar crct = /*#__PURE__*/ (function () {\n    var t = new Int32Array(256);\n    for (var i = 0; i < 256; ++i) {\n        var c = i, k = 9;\n        while (--k)\n            c = ((c & 1) && -306674912) ^ (c >>> 1);\n        t[i] = c;\n    }\n    return t;\n})();\n// CRC32\nvar crc = function () {\n    var c = -1;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var cr = c;\n            for (var i = 0; i < d.length; ++i)\n                cr = crct[(cr & 255) ^ d[i]] ^ (cr >>> 8);\n            c = cr;\n        },\n        d: function () { return ~c; }\n    };\n};\n// Alder32\nvar adler = function () {\n    var a = 1, b = 0;\n    return {\n        p: function (d) {\n            // closures have awful performance\n            var n = a, m = b;\n            var l = d.length;\n            for (var i = 0; i != l;) {\n                var e = Math.min(i + 2655, l);\n                for (; i < e; ++i)\n                    m += n += d[i];\n                n = (n & 65535) + 15 * (n >> 16), m = (m & 65535) + 15 * (m >> 16);\n            }\n            a = n, b = m;\n        },\n        d: function () {\n            a %= 65521, b %= 65521;\n            return (a & 255) << 24 | (a >>> 8) << 16 | (b & 255) << 8 | (b >>> 8);\n        }\n    };\n};\n;\n// deflate with opts\nvar dopt = function (dat, opt, pre, post, st) {\n    return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : (12 + opt.mem), pre, post, !st);\n};\n// Walmart object spread\nvar mrg = function (a, b) {\n    var o = {};\n    for (var k in a)\n        o[k] = a[k];\n    for (var k in b)\n        o[k] = b[k];\n    return o;\n};\n// worker clone\n// This is possibly the craziest part of the entire codebase, despite how simple it may seem.\n// The only parameter to this function is a closure that returns an array of variables outside of the function scope.\n// We're going to try to figure out the variable names used in the closure as strings because that is crucial for workerization.\n// We will return an object mapping of true variable name to value (basically, the current scope as a JS object).\n// The reason we can't just use the original variable names is minifiers mangling the toplevel scope.\n// This took me three weeks to figure out how to do.\nvar wcln = function (fn, fnStr, td) {\n    var dt = fn();\n    var st = fn.toString();\n    var ks = st.slice(st.indexOf('[') + 1, st.lastIndexOf(']')).replace(/ /g, '').split(',');\n    for (var i = 0; i < dt.length; ++i) {\n        var v = dt[i], k = ks[i];\n        if (typeof v == 'function') {\n            fnStr += ';' + k + '=';\n            var st_1 = v.toString();\n            if (v.prototype) {\n                // for global objects\n                if (st_1.indexOf('[native code]') != -1) {\n                    var spInd = st_1.indexOf(' ', 8) + 1;\n                    fnStr += st_1.slice(spInd, st_1.indexOf('(', spInd));\n                }\n                else {\n                    fnStr += st_1;\n                    for (var t in v.prototype)\n                        fnStr += ';' + k + '.prototype.' + t + '=' + v.prototype[t].toString();\n                }\n            }\n            else\n                fnStr += st_1;\n        }\n        else\n            td[k] = v;\n    }\n    return [fnStr, td];\n};\nvar ch = [];\n// clone bufs\nvar cbfs = function (v) {\n    var tl = [];\n    for (var k in v) {\n        if (v[k] instanceof u8 || v[k] instanceof u16 || v[k] instanceof u32)\n            tl.push((v[k] = new v[k].constructor(v[k])).buffer);\n    }\n    return tl;\n};\n// use a worker to execute code\nvar wrkr = function (fns, init, id, cb) {\n    var _a;\n    if (!ch[id]) {\n        var fnStr = '', td_1 = {}, m = fns.length - 1;\n        for (var i = 0; i < m; ++i)\n            _a = wcln(fns[i], fnStr, td_1), fnStr = _a[0], td_1 = _a[1];\n        ch[id] = wcln(fns[m], fnStr, td_1);\n    }\n    var td = mrg({}, ch[id][1]);\n    return wk(ch[id][0] + ';onmessage=function(e){for(var k in e.data)self[k]=e.data[k];onmessage=' + init.toString() + '}', id, td, cbfs(td), cb);\n};\n// base async inflate fn\nvar bInflt = function () { return [u8, u16, u32, fleb, fdeb, clim, fl, fd, flrm, fdrm, rev, hMap, max, bits, bits16, shft, slc, inflt, inflateSync, pbf, gu8]; };\nvar bDflt = function () { return [u8, u16, u32, fleb, fdeb, clim, revfl, revfd, flm, flt, fdm, fdt, rev, deo, et, hMap, wbits, wbits16, hTree, ln, lc, clen, wfblk, wblk, shft, slc, dflt, dopt, deflateSync, pbf]; };\n// gzip extra\nvar gze = function () { return [gzh, gzhl, wbytes, crc, crct]; };\n// gunzip extra\nvar guze = function () { return [gzs, gzl]; };\n// zlib extra\nvar zle = function () { return [zlh, wbytes, adler]; };\n// unzlib extra\nvar zule = function () { return [zlv]; };\n// post buf\nvar pbf = function (msg) { return postMessage(msg, [msg.buffer]); };\n// get u8\nvar gu8 = function (o) { return o && o.size && new u8(o.size); };\n// async helper\nvar cbify = function (dat, opts, fns, init, id, cb) {\n    var w = wrkr(fns, init, id, function (err, dat) {\n        w.terminate();\n        cb(err, dat);\n    });\n    w.postMessage([dat, opts], opts.consume ? [dat.buffer] : []);\n    return function () { w.terminate(); };\n};\n// auto stream\nvar astrm = function (strm) {\n    strm.ondata = function (dat, final) { return postMessage([dat, final], [dat.buffer]); };\n    return function (ev) { return strm.push(ev.data[0], ev.data[1]); };\n};\n// async stream attach\nvar astrmify = function (fns, strm, opts, init, id) {\n    var t;\n    var w = wrkr(fns, init, id, function (err, dat) {\n        if (err)\n            w.terminate(), strm.ondata.call(strm, err);\n        else {\n            if (dat[1])\n                w.terminate();\n            strm.ondata.call(strm, err, dat[0], dat[1]);\n        }\n    });\n    w.postMessage(opts);\n    strm.push = function (d, f) {\n        if (t)\n            throw 'stream finished';\n        if (!strm.ondata)\n            throw 'no stream handler';\n        w.postMessage([d, t = f], [d.buffer]);\n    };\n    strm.terminate = function () { w.terminate(); };\n};\n// read 2 bytes\nvar b2 = function (d, b) { return d[b] | (d[b + 1] << 8); };\n// read 4 bytes\nvar b4 = function (d, b) { return (d[b] | (d[b + 1] << 8) | (d[b + 2] << 16) | (d[b + 3] << 24)) >>> 0; };\nvar b8 = function (d, b) { return b4(d, b) + (b4(d, b + 4) * 4294967296); };\n// write bytes\nvar wbytes = function (d, b, v) {\n    for (; v; ++b)\n        d[b] = v, v >>>= 8;\n};\n// gzip header\nvar gzh = function (c, o) {\n    var fn = o.filename;\n    c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3; // assume Unix\n    if (o.mtime != 0)\n        wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1000));\n    if (fn) {\n        c[3] = 8;\n        for (var i = 0; i <= fn.length; ++i)\n            c[i + 10] = fn.charCodeAt(i);\n    }\n};\n// gzip footer: -8 to -4 = CRC, -4 to -0 is length\n// gzip start\nvar gzs = function (d) {\n    if (d[0] != 31 || d[1] != 139 || d[2] != 8)\n        throw 'invalid gzip data';\n    var flg = d[3];\n    var st = 10;\n    if (flg & 4)\n        st += d[10] | (d[11] << 8) + 2;\n    for (var zs = (flg >> 3 & 1) + (flg >> 4 & 1); zs > 0; zs -= !d[st++])\n        ;\n    return st + (flg & 2);\n};\n// gzip length\nvar gzl = function (d) {\n    var l = d.length;\n    return ((d[l - 4] | d[l - 3] << 8 | d[l - 2] << 16) | (d[l - 1] << 24)) >>> 0;\n};\n// gzip header length\nvar gzhl = function (o) { return 10 + ((o.filename && (o.filename.length + 1)) || 0); };\n// zlib header\nvar zlh = function (c, o) {\n    var lv = o.level, fl = lv == 0 ? 0 : lv < 6 ? 1 : lv == 9 ? 3 : 2;\n    c[0] = 120, c[1] = (fl << 6) | (fl ? (32 - 2 * fl) : 1);\n};\n// zlib valid\nvar zlv = function (d) {\n    if ((d[0] & 15) != 8 || (d[0] >>> 4) > 7 || ((d[0] << 8 | d[1]) % 31))\n        throw 'invalid zlib data';\n    if (d[1] & 32)\n        throw 'invalid zlib data: preset dictionaries not supported';\n};\nfunction AsyncCmpStrm(opts, cb) {\n    if (!cb && typeof opts == 'function')\n        cb = opts, opts = {};\n    this.ondata = cb;\n    return opts;\n}\n// zlib footer: -4 to -0 is Adler32\n/**\n * Streaming DEFLATE compression\n */\nvar Deflate = /*#__PURE__*/ (function () {\n    function Deflate(opts, cb) {\n        if (!cb && typeof opts == 'function')\n            cb = opts, opts = {};\n        this.ondata = cb;\n        this.o = opts || {};\n    }\n    Deflate.prototype.p = function (c, f) {\n        this.ondata(dopt(c, this.o, 0, 0, !f), f);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Deflate.prototype.push = function (chunk, final) {\n        if (this.d)\n            throw 'stream finished';\n        if (!this.ondata)\n            throw 'no stream handler';\n        this.d = final;\n        this.p(chunk, final || false);\n    };\n    return Deflate;\n}());\nexport { Deflate };\n/**\n * Asynchronous streaming DEFLATE compression\n */\nvar AsyncDeflate = /*#__PURE__*/ (function () {\n    function AsyncDeflate(opts, cb) {\n        astrmify([\n            bDflt,\n            function () { return [astrm, Deflate]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Deflate(ev.data);\n            onmessage = astrm(strm);\n        }, 6);\n    }\n    return AsyncDeflate;\n}());\nexport { AsyncDeflate };\nexport function deflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n    ], function (ev) { return pbf(deflateSync(ev.data[0], ev.data[1])); }, 0, cb);\n}\n/**\n * Compresses data with DEFLATE without any wrapper\n * @param data The data to compress\n * @param opts The compression options\n * @returns The deflated version of the data\n */\nexport function deflateSync(data, opts) {\n    return dopt(data, opts || {}, 0, 0);\n}\n/**\n * Streaming DEFLATE decompression\n */\nvar Inflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an inflation stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Inflate(cb) {\n        this.s = {};\n        this.p = new u8(0);\n        this.ondata = cb;\n    }\n    Inflate.prototype.e = function (c) {\n        if (this.d)\n            throw 'stream finished';\n        if (!this.ondata)\n            throw 'no stream handler';\n        var l = this.p.length;\n        var n = new u8(l + c.length);\n        n.set(this.p), n.set(c, l), this.p = n;\n    };\n    Inflate.prototype.c = function (final) {\n        this.d = this.s.i = final || false;\n        var bts = this.s.b;\n        var dt = inflt(this.p, this.o, this.s);\n        this.ondata(slc(dt, bts, this.s.b), this.d);\n        this.o = slc(dt, this.s.b - 32768), this.s.b = this.o.length;\n        this.p = slc(this.p, (this.s.p / 8) | 0), this.s.p &= 7;\n    };\n    /**\n     * Pushes a chunk to be inflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the final chunk\n     */\n    Inflate.prototype.push = function (chunk, final) {\n        this.e(chunk), this.c(final);\n    };\n    return Inflate;\n}());\nexport { Inflate };\n/**\n * Asynchronous streaming DEFLATE decompression\n */\nvar AsyncInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous inflation stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncInflate(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            function () { return [astrm, Inflate]; }\n        ], this, 0, function () {\n            var strm = new Inflate();\n            onmessage = astrm(strm);\n        }, 7);\n    }\n    return AsyncInflate;\n}());\nexport { AsyncInflate };\nexport function inflate(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt\n    ], function (ev) { return pbf(inflateSync(ev.data[0], gu8(ev.data[1]))); }, 1, cb);\n}\n/**\n * Expands DEFLATE data with no wrapper\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function inflateSync(data, out) {\n    return inflt(data, out);\n}\n// before you yell at me for not just using extends, my reason is that TS inheritance is hard to workerize.\n/**\n * Streaming GZIP compression\n */\nvar Gzip = /*#__PURE__*/ (function () {\n    function Gzip(opts, cb) {\n        this.c = crc();\n        this.l = 0;\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be GZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gzip.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Gzip.prototype.p = function (c, f) {\n        this.c.p(c);\n        this.l += c.length;\n        var raw = dopt(c, this.o, this.v && gzhl(this.o), f && 8, !f);\n        if (this.v)\n            gzh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 8, this.c.d()), wbytes(raw, raw.length - 4, this.l);\n        this.ondata(raw, f);\n    };\n    return Gzip;\n}());\nexport { Gzip };\n/**\n * Asynchronous streaming GZIP compression\n */\nvar AsyncGzip = /*#__PURE__*/ (function () {\n    function AsyncGzip(opts, cb) {\n        astrmify([\n            bDflt,\n            gze,\n            function () { return [astrm, Deflate, Gzip]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Gzip(ev.data);\n            onmessage = astrm(strm);\n        }, 8);\n    }\n    return AsyncGzip;\n}());\nexport { AsyncGzip };\nexport function gzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n        gze,\n        function () { return [gzipSync]; }\n    ], function (ev) { return pbf(gzipSync(ev.data[0], ev.data[1])); }, 2, cb);\n}\n/**\n * Compresses data with GZIP\n * @param data The data to compress\n * @param opts The compression options\n * @returns The gzipped version of the data\n */\nexport function gzipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var c = crc(), l = data.length;\n    c.p(data);\n    var d = dopt(data, opts, gzhl(opts), 8), s = d.length;\n    return gzh(d, opts), wbytes(d, s - 8, c.d()), wbytes(d, s - 4, l), d;\n}\n/**\n * Streaming GZIP decompression\n */\nvar Gunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a GUNZIP stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Gunzip(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be GUNZIPped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Gunzip.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            var s = this.p.length > 3 ? gzs(this.p) : 4;\n            if (s >= this.p.length && !final)\n                return;\n            this.p = this.p.subarray(s), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 8)\n                throw 'invalid gzip stream';\n            this.p = this.p.subarray(0, -8);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Gunzip;\n}());\nexport { Gunzip };\n/**\n * Asynchronous streaming GZIP decompression\n */\nvar AsyncGunzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous GUNZIP stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncGunzip(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            guze,\n            function () { return [astrm, Inflate, Gunzip]; }\n        ], this, 0, function () {\n            var strm = new Gunzip();\n            onmessage = astrm(strm);\n        }, 9);\n    }\n    return AsyncGunzip;\n}());\nexport { AsyncGunzip };\nexport function gunzip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt,\n        guze,\n        function () { return [gunzipSync]; }\n    ], function (ev) { return pbf(gunzipSync(ev.data[0])); }, 3, cb);\n}\n/**\n * Expands GZIP data\n * @param data The data to decompress\n * @param out Where to write the data. GZIP already encodes the output size, so providing this doesn't save memory.\n * @returns The decompressed version of the data\n */\nexport function gunzipSync(data, out) {\n    return inflt(data.subarray(gzs(data), -8), out || new u8(gzl(data)));\n}\n/**\n * Streaming Zlib compression\n */\nvar Zlib = /*#__PURE__*/ (function () {\n    function Zlib(opts, cb) {\n        this.c = adler();\n        this.v = 1;\n        Deflate.call(this, opts, cb);\n    }\n    /**\n     * Pushes a chunk to be zlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Zlib.prototype.push = function (chunk, final) {\n        Deflate.prototype.push.call(this, chunk, final);\n    };\n    Zlib.prototype.p = function (c, f) {\n        this.c.p(c);\n        var raw = dopt(c, this.o, this.v && 2, f && 4, !f);\n        if (this.v)\n            zlh(raw, this.o), this.v = 0;\n        if (f)\n            wbytes(raw, raw.length - 4, this.c.d());\n        this.ondata(raw, f);\n    };\n    return Zlib;\n}());\nexport { Zlib };\n/**\n * Asynchronous streaming Zlib compression\n */\nvar AsyncZlib = /*#__PURE__*/ (function () {\n    function AsyncZlib(opts, cb) {\n        astrmify([\n            bDflt,\n            zle,\n            function () { return [astrm, Deflate, Zlib]; }\n        ], this, AsyncCmpStrm.call(this, opts, cb), function (ev) {\n            var strm = new Zlib(ev.data);\n            onmessage = astrm(strm);\n        }, 10);\n    }\n    return AsyncZlib;\n}());\nexport { AsyncZlib };\nexport function zlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bDflt,\n        zle,\n        function () { return [zlibSync]; }\n    ], function (ev) { return pbf(zlibSync(ev.data[0], ev.data[1])); }, 4, cb);\n}\n/**\n * Compress data with Zlib\n * @param data The data to compress\n * @param opts The compression options\n * @returns The zlib-compressed version of the data\n */\nexport function zlibSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var a = adler();\n    a.p(data);\n    var d = dopt(data, opts, 2, 4);\n    return zlh(d, opts), wbytes(d, d.length - 4, a.d()), d;\n}\n/**\n * Streaming Zlib decompression\n */\nvar Unzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates a Zlib decompression stream\n     * @param cb The callback to call whenever data is inflated\n     */\n    function Unzlib(cb) {\n        this.v = 1;\n        Inflate.call(this, cb);\n    }\n    /**\n     * Pushes a chunk to be unzlibbed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzlib.prototype.push = function (chunk, final) {\n        Inflate.prototype.e.call(this, chunk);\n        if (this.v) {\n            if (this.p.length < 2 && !final)\n                return;\n            this.p = this.p.subarray(2), this.v = 0;\n        }\n        if (final) {\n            if (this.p.length < 4)\n                throw 'invalid zlib stream';\n            this.p = this.p.subarray(0, -4);\n        }\n        // necessary to prevent TS from using the closure value\n        // This allows for workerization to function correctly\n        Inflate.prototype.c.call(this, final);\n    };\n    return Unzlib;\n}());\nexport { Unzlib };\n/**\n * Asynchronous streaming Zlib decompression\n */\nvar AsyncUnzlib = /*#__PURE__*/ (function () {\n    /**\n     * Creates an asynchronous Zlib decompression stream\n     * @param cb The callback to call whenever data is deflated\n     */\n    function AsyncUnzlib(cb) {\n        this.ondata = cb;\n        astrmify([\n            bInflt,\n            zule,\n            function () { return [astrm, Inflate, Unzlib]; }\n        ], this, 0, function () {\n            var strm = new Unzlib();\n            onmessage = astrm(strm);\n        }, 11);\n    }\n    return AsyncUnzlib;\n}());\nexport { AsyncUnzlib };\nexport function unzlib(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return cbify(data, opts, [\n        bInflt,\n        zule,\n        function () { return [unzlibSync]; }\n    ], function (ev) { return pbf(unzlibSync(ev.data[0], gu8(ev.data[1]))); }, 5, cb);\n}\n/**\n * Expands Zlib data\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function unzlibSync(data, out) {\n    return inflt((zlv(data), data.subarray(2, -4)), out);\n}\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzip as compress, AsyncGzip as AsyncCompress };\n// Default algorithm for compression (used because having a known output size allows faster decompression)\nexport { gzipSync as compressSync, Gzip as Compress };\n/**\n * Streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar Decompress = /*#__PURE__*/ (function () {\n    /**\n     * Creates a decompression stream\n     * @param cb The callback to call whenever data is decompressed\n     */\n    function Decompress(cb) {\n        this.G = Gunzip;\n        this.I = Inflate;\n        this.Z = Unzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Decompress.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no stream handler';\n        if (!this.s) {\n            if (this.p && this.p.length) {\n                var n = new u8(this.p.length + chunk.length);\n                n.set(this.p), n.set(chunk, this.p.length);\n            }\n            else\n                this.p = chunk;\n            if (this.p.length > 2) {\n                var _this_1 = this;\n                var cb = function () { _this_1.ondata.apply(_this_1, arguments); };\n                this.s = (this.p[0] == 31 && this.p[1] == 139 && this.p[2] == 8)\n                    ? new this.G(cb)\n                    : ((this.p[0] & 15) != 8 || (this.p[0] >> 4) > 7 || ((this.p[0] << 8 | this.p[1]) % 31))\n                        ? new this.I(cb)\n                        : new this.Z(cb);\n                this.s.push(this.p, final);\n                this.p = null;\n            }\n        }\n        else\n            this.s.push(chunk, final);\n    };\n    return Decompress;\n}());\nexport { Decompress };\n/**\n * Asynchronous streaming GZIP, Zlib, or raw DEFLATE decompression\n */\nvar AsyncDecompress = /*#__PURE__*/ (function () {\n    /**\n   * Creates an asynchronous decompression stream\n   * @param cb The callback to call whenever data is decompressed\n   */\n    function AsyncDecompress(cb) {\n        this.G = AsyncGunzip;\n        this.I = AsyncInflate;\n        this.Z = AsyncUnzlib;\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be decompressed\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncDecompress.prototype.push = function (chunk, final) {\n        Decompress.prototype.push.call(this, chunk, final);\n    };\n    return AsyncDecompress;\n}());\nexport { AsyncDecompress };\nexport function decompress(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzip(data, opts, cb)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflate(data, opts, cb)\n            : unzlib(data, opts, cb);\n}\n/**\n * Expands compressed GZIP, Zlib, or raw DEFLATE data, automatically detecting the format\n * @param data The data to decompress\n * @param out Where to write the data. Saves memory if you know the decompressed size and provide an output buffer of that length.\n * @returns The decompressed version of the data\n */\nexport function decompressSync(data, out) {\n    return (data[0] == 31 && data[1] == 139 && data[2] == 8)\n        ? gunzipSync(data, out)\n        : ((data[0] & 15) != 8 || (data[0] >> 4) > 7 || ((data[0] << 8 | data[1]) % 31))\n            ? inflateSync(data, out)\n            : unzlibSync(data, out);\n}\n// flatten a directory structure\nvar fltn = function (d, p, t, o) {\n    for (var k in d) {\n        var val = d[k], n = p + k;\n        if (val instanceof u8)\n            t[n] = [val, o];\n        else if (Array.isArray(val))\n            t[n] = [val[0], mrg(o, val[1])];\n        else\n            fltn(val, n + '/', t, o);\n    }\n};\n// text encoder\nvar te = typeof TextEncoder != 'undefined' && /*#__PURE__*/ new TextEncoder();\n// text decoder\nvar td = typeof TextDecoder != 'undefined' && /*#__PURE__*/ new TextDecoder();\n// text decoder stream\nvar tds = 0;\ntry {\n    td.decode(et, { stream: true });\n    tds = 1;\n}\ncatch (e) { }\n// decode UTF8\nvar dutf8 = function (d) {\n    for (var r = '', i = 0;;) {\n        var c = d[i++];\n        var eb = (c > 127) + (c > 223) + (c > 239);\n        if (i + eb > d.length)\n            return [r, slc(d, i - 1)];\n        if (!eb)\n            r += String.fromCharCode(c);\n        else if (eb == 3) {\n            c = ((c & 15) << 18 | (d[i++] & 63) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63)) - 65536,\n                r += String.fromCharCode(55296 | (c >> 10), 56320 | (c & 1023));\n        }\n        else if (eb & 1)\n            r += String.fromCharCode((c & 31) << 6 | (d[i++] & 63));\n        else\n            r += String.fromCharCode((c & 15) << 12 | (d[i++] & 63) << 6 | (d[i++] & 63));\n    }\n};\n/**\n * Streaming UTF-8 decoding\n */\nvar DecodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is decoded\n     */\n    function DecodeUTF8(cb) {\n        this.ondata = cb;\n        if (tds)\n            this.t = new TextDecoder();\n        else\n            this.p = et;\n    }\n    /**\n     * Pushes a chunk to be decoded from UTF-8 binary\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    DecodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback';\n        final = !!final;\n        if (this.t) {\n            this.ondata(this.t.decode(chunk, { stream: true }), final);\n            if (final) {\n                if (this.t.decode().length)\n                    throw 'invalid utf-8 data';\n                this.t = null;\n            }\n            return;\n        }\n        if (!this.p)\n            throw 'stream finished';\n        var dat = new u8(this.p.length + chunk.length);\n        dat.set(this.p);\n        dat.set(chunk, this.p.length);\n        var _a = dutf8(dat), ch = _a[0], np = _a[1];\n        if (final) {\n            if (np.length)\n                throw 'invalid utf-8 data';\n            this.p = null;\n        }\n        else\n            this.p = np;\n        this.ondata(ch, final);\n    };\n    return DecodeUTF8;\n}());\nexport { DecodeUTF8 };\n/**\n * Streaming UTF-8 encoding\n */\nvar EncodeUTF8 = /*#__PURE__*/ (function () {\n    /**\n     * Creates a UTF-8 decoding stream\n     * @param cb The callback to call whenever data is encoded\n     */\n    function EncodeUTF8(cb) {\n        this.ondata = cb;\n    }\n    /**\n     * Pushes a chunk to be encoded to UTF-8\n     * @param chunk The string data to push\n     * @param final Whether this is the last chunk\n     */\n    EncodeUTF8.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback';\n        if (this.d)\n            throw 'stream finished';\n        this.ondata(strToU8(chunk), this.d = final || false);\n    };\n    return EncodeUTF8;\n}());\nexport { EncodeUTF8 };\n/**\n * Converts a string into a Uint8Array for use with compression/decompression methods\n * @param str The string to encode\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless decoding a binary string.\n * @returns The string encoded in UTF-8/Latin-1 binary\n */\nexport function strToU8(str, latin1) {\n    if (latin1) {\n        var ar_1 = new u8(str.length);\n        for (var i = 0; i < str.length; ++i)\n            ar_1[i] = str.charCodeAt(i);\n        return ar_1;\n    }\n    if (te)\n        return te.encode(str);\n    var l = str.length;\n    var ar = new u8(str.length + (str.length >> 1));\n    var ai = 0;\n    var w = function (v) { ar[ai++] = v; };\n    for (var i = 0; i < l; ++i) {\n        if (ai + 5 > ar.length) {\n            var n = new u8(ai + 8 + ((l - i) << 1));\n            n.set(ar);\n            ar = n;\n        }\n        var c = str.charCodeAt(i);\n        if (c < 128 || latin1)\n            w(c);\n        else if (c < 2048)\n            w(192 | (c >> 6)), w(128 | (c & 63));\n        else if (c > 55295 && c < 57344)\n            c = 65536 + (c & 1023 << 10) | (str.charCodeAt(++i) & 1023),\n                w(240 | (c >> 18)), w(128 | ((c >> 12) & 63)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n        else\n            w(224 | (c >> 12)), w(128 | ((c >> 6) & 63)), w(128 | (c & 63));\n    }\n    return slc(ar, 0, ai);\n}\n/**\n * Converts a Uint8Array to a string\n * @param dat The data to decode to string\n * @param latin1 Whether or not to interpret the data as Latin-1. This should\n *               not need to be true unless encoding to binary string.\n * @returns The original UTF-8/Latin-1 string\n */\nexport function strFromU8(dat, latin1) {\n    if (latin1) {\n        var r = '';\n        for (var i = 0; i < dat.length; i += 16384)\n            r += String.fromCharCode.apply(null, dat.subarray(i, i + 16384));\n        return r;\n    }\n    else if (td)\n        return td.decode(dat);\n    else {\n        var _a = dutf8(dat), out = _a[0], ext = _a[1];\n        if (ext.length)\n            throw 'invalid utf-8 data';\n        return out;\n    }\n}\n;\n// deflate bit flag\nvar dbf = function (l) { return l == 1 ? 3 : l < 6 ? 2 : l == 9 ? 1 : 0; };\n// skip local zip header\nvar slzh = function (d, b) { return b + 30 + b2(d, b + 26) + b2(d, b + 28); };\n// read zip header\nvar zh = function (d, b, z) {\n    var fnl = b2(d, b + 28), fn = strFromU8(d.subarray(b + 46, b + 46 + fnl), !(b2(d, b + 8) & 2048)), es = b + 46 + fnl, bs = b4(d, b + 20);\n    var _a = z && bs == 4294967295 ? z64e(d, es) : [bs, b4(d, b + 24), b4(d, b + 42)], sc = _a[0], su = _a[1], off = _a[2];\n    return [b2(d, b + 10), sc, su, fn, es + b2(d, b + 30) + b2(d, b + 32), off];\n};\n// read zip64 extra field\nvar z64e = function (d, b) {\n    for (; b2(d, b) != 1; b += 4 + b2(d, b + 2))\n        ;\n    return [b8(d, b + 12), b8(d, b + 4), b8(d, b + 20)];\n};\n// extra field length\nvar exfl = function (ex) {\n    var le = 0;\n    if (ex) {\n        for (var k in ex) {\n            var l = ex[k].length;\n            if (l > 65535)\n                throw 'extra field too long';\n            le += l + 4;\n        }\n    }\n    return le;\n};\n// write zip header\nvar wzh = function (d, b, f, fn, u, c, ce, co) {\n    var fl = fn.length, ex = f.extra, col = co && co.length;\n    var exl = exfl(ex);\n    wbytes(d, b, ce != null ? 0x2014B50 : 0x4034B50), b += 4;\n    if (ce != null)\n        d[b++] = 20, d[b++] = f.os;\n    d[b] = 20, b += 2; // spec compliance? what's that?\n    d[b++] = (f.flag << 1) | (c == null && 8), d[b++] = u && 8;\n    d[b++] = f.compression & 255, d[b++] = f.compression >> 8;\n    var dt = new Date(f.mtime == null ? Date.now() : f.mtime), y = dt.getFullYear() - 1980;\n    if (y < 0 || y > 119)\n        throw 'date not in range 1980-2099';\n    wbytes(d, b, (y << 25) | ((dt.getMonth() + 1) << 21) | (dt.getDate() << 16) | (dt.getHours() << 11) | (dt.getMinutes() << 5) | (dt.getSeconds() >>> 1)), b += 4;\n    if (c != null) {\n        wbytes(d, b, f.crc);\n        wbytes(d, b + 4, c);\n        wbytes(d, b + 8, f.size);\n    }\n    wbytes(d, b + 12, fl);\n    wbytes(d, b + 14, exl), b += 16;\n    if (ce != null) {\n        wbytes(d, b, col);\n        wbytes(d, b + 6, f.attrs);\n        wbytes(d, b + 10, ce), b += 14;\n    }\n    d.set(fn, b);\n    b += fl;\n    if (exl) {\n        for (var k in ex) {\n            var exf = ex[k], l = exf.length;\n            wbytes(d, b, +k);\n            wbytes(d, b + 2, l);\n            d.set(exf, b + 4), b += 4 + l;\n        }\n    }\n    if (col)\n        d.set(co, b), b += col;\n    return b;\n};\n// write zip footer (end of central directory)\nvar wzf = function (o, b, c, d, e) {\n    wbytes(o, b, 0x6054B50); // skip disk\n    wbytes(o, b + 8, c);\n    wbytes(o, b + 10, c);\n    wbytes(o, b + 12, d);\n    wbytes(o, b + 16, e);\n};\n/**\n * A pass-through stream to keep data uncompressed in a ZIP archive.\n */\nvar ZipPassThrough = /*#__PURE__*/ (function () {\n    /**\n     * Creates a pass-through stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     */\n    function ZipPassThrough(filename) {\n        this.filename = filename;\n        this.c = crc();\n        this.size = 0;\n        this.compression = 0;\n    }\n    /**\n     * Processes a chunk and pushes to the output stream. You can override this\n     * method in a subclass for custom behavior, but by default this passes\n     * the data through. You must call this.ondata(err, chunk, final) at some\n     * point in this method.\n     * @param chunk The chunk to process\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.process = function (chunk, final) {\n        this.ondata(null, chunk, final);\n    };\n    /**\n     * Pushes a chunk to be added. If you are subclassing this with a custom\n     * compression algorithm, note that you must push data from the source\n     * file only, pre-compression.\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipPassThrough.prototype.push = function (chunk, final) {\n        if (!this.ondata)\n            throw 'no callback - add to ZIP archive before pushing';\n        this.c.p(chunk);\n        this.size += chunk.length;\n        if (final)\n            this.crc = this.c.d();\n        this.process(chunk, final || false);\n    };\n    return ZipPassThrough;\n}());\nexport { ZipPassThrough };\n// I don't extend because TypeScript extension adds 1kB of runtime bloat\n/**\n * Streaming DEFLATE compression for ZIP archives. Prefer using AsyncZipDeflate\n * for better performance\n */\nvar ZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function ZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new Deflate(opts, function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n    }\n    ZipDeflate.prototype.process = function (chunk, final) {\n        try {\n            this.d.push(chunk, final);\n        }\n        catch (e) {\n            this.ondata(e, null, final);\n        }\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    ZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return ZipDeflate;\n}());\nexport { ZipDeflate };\n/**\n * Asynchronous streaming DEFLATE compression for ZIP archives\n */\nvar AsyncZipDeflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE stream that can be added to ZIP archives\n     * @param filename The filename to associate with this data stream\n     * @param opts The compression options\n     */\n    function AsyncZipDeflate(filename, opts) {\n        var _this_1 = this;\n        if (!opts)\n            opts = {};\n        ZipPassThrough.call(this, filename);\n        this.d = new AsyncDeflate(opts, function (err, dat, final) {\n            _this_1.ondata(err, dat, final);\n        });\n        this.compression = 8;\n        this.flag = dbf(opts.level);\n        this.terminate = this.d.terminate;\n    }\n    AsyncZipDeflate.prototype.process = function (chunk, final) {\n        this.d.push(chunk, final);\n    };\n    /**\n     * Pushes a chunk to be deflated\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    AsyncZipDeflate.prototype.push = function (chunk, final) {\n        ZipPassThrough.prototype.push.call(this, chunk, final);\n    };\n    return AsyncZipDeflate;\n}());\nexport { AsyncZipDeflate };\n// TODO: Better tree shaking\n/**\n * A zippable archive to which files can incrementally be added\n */\nvar Zip = /*#__PURE__*/ (function () {\n    /**\n     * Creates an empty ZIP archive to which files can be added\n     * @param cb The callback to call whenever data for the generated ZIP archive\n     *           is available\n     */\n    function Zip(cb) {\n        this.ondata = cb;\n        this.u = [];\n        this.d = 1;\n    }\n    /**\n     * Adds a file to the ZIP archive\n     * @param file The file stream to add\n     */\n    Zip.prototype.add = function (file) {\n        var _this_1 = this;\n        if (this.d & 2)\n            throw 'stream finished';\n        var f = strToU8(file.filename), fl = f.length;\n        var com = file.comment, o = com && strToU8(com);\n        var u = fl != file.filename.length || (o && (com.length != o.length));\n        var hl = fl + exfl(file.extra) + 30;\n        if (fl > 65535)\n            throw 'filename too long';\n        var header = new u8(hl);\n        wzh(header, 0, file, f, u);\n        var chks = [header];\n        var pAll = function () {\n            for (var _i = 0, chks_1 = chks; _i < chks_1.length; _i++) {\n                var chk = chks_1[_i];\n                _this_1.ondata(null, chk, false);\n            }\n            chks = [];\n        };\n        var tr = this.d;\n        this.d = 0;\n        var ind = this.u.length;\n        var uf = mrg(file, {\n            f: f,\n            u: u,\n            o: o,\n            t: function () {\n                if (file.terminate)\n                    file.terminate();\n            },\n            r: function () {\n                pAll();\n                if (tr) {\n                    var nxt = _this_1.u[ind + 1];\n                    if (nxt)\n                        nxt.r();\n                    else\n                        _this_1.d = 1;\n                }\n                tr = 1;\n            }\n        });\n        var cl = 0;\n        file.ondata = function (err, dat, final) {\n            if (err) {\n                _this_1.ondata(err, dat, final);\n                _this_1.terminate();\n            }\n            else {\n                cl += dat.length;\n                chks.push(dat);\n                if (final) {\n                    var dd = new u8(16);\n                    wbytes(dd, 0, 0x8074B50);\n                    wbytes(dd, 4, file.crc);\n                    wbytes(dd, 8, cl);\n                    wbytes(dd, 12, file.size);\n                    chks.push(dd);\n                    uf.c = cl, uf.b = hl + cl + 16, uf.crc = file.crc, uf.size = file.size;\n                    if (tr)\n                        uf.r();\n                    tr = 1;\n                }\n                else if (tr)\n                    pAll();\n            }\n        };\n        this.u.push(uf);\n    };\n    /**\n     * Ends the process of adding files and prepares to emit the final chunks.\n     * This *must* be called after adding all desired files for the resulting\n     * ZIP file to work properly.\n     */\n    Zip.prototype.end = function () {\n        var _this_1 = this;\n        if (this.d & 2) {\n            if (this.d & 1)\n                throw 'stream finishing';\n            throw 'stream finished';\n        }\n        if (this.d)\n            this.e();\n        else\n            this.u.push({\n                r: function () {\n                    if (!(_this_1.d & 1))\n                        return;\n                    _this_1.u.splice(-1, 1);\n                    _this_1.e();\n                },\n                t: function () { }\n            });\n        this.d = 3;\n    };\n    Zip.prototype.e = function () {\n        var bt = 0, l = 0, tl = 0;\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            tl += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0);\n        }\n        var out = new u8(tl + 22);\n        for (var _b = 0, _c = this.u; _b < _c.length; _b++) {\n            var f = _c[_b];\n            wzh(out, bt, f, f.f, f.u, f.c, l, f.o);\n            bt += 46 + f.f.length + exfl(f.extra) + (f.o ? f.o.length : 0), l += f.b;\n        }\n        wzf(out, bt, this.u.length, tl, l);\n        this.ondata(null, out, true);\n        this.d = 2;\n    };\n    /**\n     * A method to terminate any internal workers used by the stream. Subsequent\n     * calls to add() will fail.\n     */\n    Zip.prototype.terminate = function () {\n        for (var _i = 0, _a = this.u; _i < _a.length; _i++) {\n            var f = _a[_i];\n            f.t();\n        }\n        this.d = 2;\n    };\n    return Zip;\n}());\nexport { Zip };\nexport function zip(data, opts, cb) {\n    if (!cb)\n        cb = opts, opts = {};\n    if (typeof cb != 'function')\n        throw 'no callback';\n    var r = {};\n    fltn(data, '', r, opts);\n    var k = Object.keys(r);\n    var lft = k.length, o = 0, tot = 0;\n    var slft = lft, files = new Array(lft);\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var cbf = function () {\n        var out = new u8(tot + 22), oe = o, cdl = tot - o;\n        tot = 0;\n        for (var i = 0; i < slft; ++i) {\n            var f = files[i];\n            try {\n                var l = f.c.length;\n                wzh(out, tot, f, f.f, f.u, l);\n                var badd = 30 + f.f.length + exfl(f.extra);\n                var loc = tot + badd;\n                out.set(f.c, loc);\n                wzh(out, o, f, f.f, f.u, l, tot, f.m), o += 16 + badd + (f.m ? f.m.length : 0), tot = loc + l;\n            }\n            catch (e) {\n                return cb(e, null);\n            }\n        }\n        wzf(out, o, files.length, cdl, oe);\n        cb(null, out);\n    };\n    if (!lft)\n        cbf();\n    var _loop_1 = function (i) {\n        var fn = k[i];\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var c = crc(), size = file.length;\n        c.p(file);\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        var compression = p.level == 0 ? 0 : 8;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            }\n            else {\n                var l = d.length;\n                files[i] = mrg(p, {\n                    size: size,\n                    crc: c.d(),\n                    c: d,\n                    f: f,\n                    m: m,\n                    u: s != fn.length || (m && (com.length != ms)),\n                    compression: compression\n                });\n                o += 30 + s + exl + l;\n                tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n                if (!--lft)\n                    cbf();\n            }\n        };\n        if (s > 65535)\n            cbl('filename too long', null);\n        if (!compression)\n            cbl(null, file);\n        else if (size < 160000) {\n            try {\n                cbl(null, deflateSync(file, p));\n            }\n            catch (e) {\n                cbl(e, null);\n            }\n        }\n        else\n            term.push(deflate(file, p, cbl));\n    };\n    // Cannot use lft because it can decrease\n    for (var i = 0; i < slft; ++i) {\n        _loop_1(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously creates a ZIP file. Prefer using `zip` for better performance\n * with more than one file.\n * @param data The directory structure for the ZIP archive\n * @param opts The main options, merged with per-file options\n * @returns The generated ZIP archive\n */\nexport function zipSync(data, opts) {\n    if (!opts)\n        opts = {};\n    var r = {};\n    var files = [];\n    fltn(data, '', r, opts);\n    var o = 0;\n    var tot = 0;\n    for (var fn in r) {\n        var _a = r[fn], file = _a[0], p = _a[1];\n        var compression = p.level == 0 ? 0 : 8;\n        var f = strToU8(fn), s = f.length;\n        var com = p.comment, m = com && strToU8(com), ms = m && m.length;\n        var exl = exfl(p.extra);\n        if (s > 65535)\n            throw 'filename too long';\n        var d = compression ? deflateSync(file, p) : file, l = d.length;\n        var c = crc();\n        c.p(file);\n        files.push(mrg(p, {\n            size: file.length,\n            crc: c.d(),\n            c: d,\n            f: f,\n            m: m,\n            u: s != fn.length || (m && (com.length != ms)),\n            o: o,\n            compression: compression\n        }));\n        o += 30 + s + exl + l;\n        tot += 76 + 2 * (s + exl) + (ms || 0) + l;\n    }\n    var out = new u8(tot + 22), oe = o, cdl = tot - o;\n    for (var i = 0; i < files.length; ++i) {\n        var f = files[i];\n        wzh(out, f.o, f, f.f, f.u, f.c.length);\n        var badd = 30 + f.f.length + exfl(f.extra);\n        out.set(f.c, f.o + badd);\n        wzh(out, o, f, f.f, f.u, f.c.length, f.o, f.m), o += 16 + badd + (f.m ? f.m.length : 0);\n    }\n    wzf(out, o, files.length, cdl, oe);\n    return out;\n}\n/**\n * Streaming pass-through decompression for ZIP archives\n */\nvar UnzipPassThrough = /*#__PURE__*/ (function () {\n    function UnzipPassThrough() {\n    }\n    UnzipPassThrough.prototype.push = function (data, final) {\n        this.ondata(null, data, final);\n    };\n    UnzipPassThrough.compression = 0;\n    return UnzipPassThrough;\n}());\nexport { UnzipPassThrough };\n/**\n * Streaming DEFLATE decompression for ZIP archives. Prefer AsyncZipInflate for\n * better performance.\n */\nvar UnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function UnzipInflate() {\n        var _this_1 = this;\n        this.i = new Inflate(function (dat, final) {\n            _this_1.ondata(null, dat, final);\n        });\n    }\n    UnzipInflate.prototype.push = function (data, final) {\n        try {\n            this.i.push(data, final);\n        }\n        catch (e) {\n            this.ondata(e, data, final);\n        }\n    };\n    UnzipInflate.compression = 8;\n    return UnzipInflate;\n}());\nexport { UnzipInflate };\n/**\n * Asynchronous streaming DEFLATE decompression for ZIP archives\n */\nvar AsyncUnzipInflate = /*#__PURE__*/ (function () {\n    /**\n     * Creates a DEFLATE decompression that can be used in ZIP archives\n     */\n    function AsyncUnzipInflate(_, sz) {\n        var _this_1 = this;\n        if (sz < 320000) {\n            this.i = new Inflate(function (dat, final) {\n                _this_1.ondata(null, dat, final);\n            });\n        }\n        else {\n            this.i = new AsyncInflate(function (err, dat, final) {\n                _this_1.ondata(err, dat, final);\n            });\n            this.terminate = this.i.terminate;\n        }\n    }\n    AsyncUnzipInflate.prototype.push = function (data, final) {\n        if (this.i.terminate)\n            data = slc(data, 0);\n        this.i.push(data, final);\n    };\n    AsyncUnzipInflate.compression = 8;\n    return AsyncUnzipInflate;\n}());\nexport { AsyncUnzipInflate };\n/**\n * A ZIP archive decompression stream that emits files as they are discovered\n */\nvar Unzip = /*#__PURE__*/ (function () {\n    /**\n     * Creates a ZIP decompression stream\n     * @param cb The callback to call whenever a file in the ZIP archive is found\n     */\n    function Unzip(cb) {\n        this.onfile = cb;\n        this.k = [];\n        this.o = {\n            0: UnzipPassThrough\n        };\n        this.p = et;\n    }\n    /**\n     * Pushes a chunk to be unzipped\n     * @param chunk The chunk to push\n     * @param final Whether this is the last chunk\n     */\n    Unzip.prototype.push = function (chunk, final) {\n        var _this_1 = this;\n        if (!this.onfile)\n            throw 'no callback';\n        if (!this.p)\n            throw 'stream finished';\n        if (this.c > 0) {\n            var len = Math.min(this.c, chunk.length);\n            var toAdd = chunk.subarray(0, len);\n            this.c -= len;\n            if (this.d)\n                this.d.push(toAdd, !this.c);\n            else\n                this.k[0].push(toAdd);\n            chunk = chunk.subarray(len);\n            if (chunk.length)\n                return this.push(chunk, final);\n        }\n        else {\n            var f = 0, i = 0, is = void 0, buf = void 0;\n            if (!this.p.length)\n                buf = chunk;\n            else if (!chunk.length)\n                buf = this.p;\n            else {\n                buf = new u8(this.p.length + chunk.length);\n                buf.set(this.p), buf.set(chunk, this.p.length);\n            }\n            var l = buf.length, oc = this.c, add = oc && this.d;\n            var _loop_2 = function () {\n                var _a;\n                var sig = b4(buf, i);\n                if (sig == 0x4034B50) {\n                    f = 1, is = i;\n                    this_1.d = null;\n                    this_1.c = 0;\n                    var bf = b2(buf, i + 6), cmp_1 = b2(buf, i + 8), u = bf & 2048, dd = bf & 8, fnl = b2(buf, i + 26), es = b2(buf, i + 28);\n                    if (l > i + 30 + fnl + es) {\n                        var chks_2 = [];\n                        this_1.k.unshift(chks_2);\n                        f = 2;\n                        var sc_1 = b4(buf, i + 18), su_1 = b4(buf, i + 22);\n                        var fn_1 = strFromU8(buf.subarray(i + 30, i += 30 + fnl), !u);\n                        if (sc_1 == 4294967295) {\n                            _a = dd ? [-2] : z64e(buf, i), sc_1 = _a[0], su_1 = _a[1];\n                        }\n                        else if (dd)\n                            sc_1 = -1;\n                        i += es;\n                        this_1.c = sc_1;\n                        var d_1;\n                        var file_1 = {\n                            name: fn_1,\n                            compression: cmp_1,\n                            start: function () {\n                                if (!file_1.ondata)\n                                    throw 'no callback';\n                                if (!sc_1)\n                                    file_1.ondata(null, et, true);\n                                else {\n                                    var ctr = _this_1.o[cmp_1];\n                                    if (!ctr)\n                                        throw 'unknown compression type ' + cmp_1;\n                                    d_1 = sc_1 < 0 ? new ctr(fn_1) : new ctr(fn_1, sc_1, su_1);\n                                    d_1.ondata = function (err, dat, final) { file_1.ondata(err, dat, final); };\n                                    for (var _i = 0, chks_3 = chks_2; _i < chks_3.length; _i++) {\n                                        var dat = chks_3[_i];\n                                        d_1.push(dat, false);\n                                    }\n                                    if (_this_1.k[0] == chks_2 && _this_1.c)\n                                        _this_1.d = d_1;\n                                    else\n                                        d_1.push(et, true);\n                                }\n                            },\n                            terminate: function () {\n                                if (d_1 && d_1.terminate)\n                                    d_1.terminate();\n                            }\n                        };\n                        if (sc_1 >= 0)\n                            file_1.size = sc_1, file_1.originalSize = su_1;\n                        this_1.onfile(file_1);\n                    }\n                    return \"break\";\n                }\n                else if (oc) {\n                    if (sig == 0x8074B50) {\n                        is = i += 12 + (oc == -2 && 8), f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                    else if (sig == 0x2014B50) {\n                        is = i -= 4, f = 3, this_1.c = 0;\n                        return \"break\";\n                    }\n                }\n            };\n            var this_1 = this;\n            for (; i < l - 4; ++i) {\n                var state_1 = _loop_2();\n                if (state_1 === \"break\")\n                    break;\n            }\n            this.p = et;\n            if (oc < 0) {\n                var dat = f ? buf.subarray(0, is - 12 - (oc == -2 && 8) - (b4(buf, is - 16) == 0x8074B50 && 4)) : buf.subarray(0, i);\n                if (add)\n                    add.push(dat, !!f);\n                else\n                    this.k[+(f == 2)].push(dat);\n            }\n            if (f & 2)\n                return this.push(buf.subarray(i), final);\n            this.p = buf.subarray(i);\n        }\n        if (final) {\n            if (this.c)\n                throw 'invalid zip file';\n            this.p = null;\n        }\n    };\n    /**\n     * Registers a decoder with the stream, allowing for files compressed with\n     * the compression type provided to be expanded correctly\n     * @param decoder The decoder constructor\n     */\n    Unzip.prototype.register = function (decoder) {\n        this.o[decoder.compression] = decoder;\n    };\n    return Unzip;\n}());\nexport { Unzip };\n/**\n * Asynchronously decompresses a ZIP archive\n * @param data The raw compressed ZIP file\n * @param cb The callback to call with the decompressed files\n * @returns A function that can be used to immediately terminate the unzipping\n */\nexport function unzip(data, cb) {\n    if (typeof cb != 'function')\n        throw 'no callback';\n    var term = [];\n    var tAll = function () {\n        for (var i = 0; i < term.length; ++i)\n            term[i]();\n    };\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558) {\n            cb('invalid zip file', null);\n            return;\n        }\n    }\n    ;\n    var lft = b2(data, e + 8);\n    if (!lft)\n        cb(null, {});\n    var c = lft;\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50) {\n            cb('invalid zip file', null);\n            return;\n        }\n        c = lft = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    var _loop_3 = function (i) {\n        var _a = zh(data, o, z), c_1 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        var cbl = function (e, d) {\n            if (e) {\n                tAll();\n                cb(e, null);\n            }\n            else {\n                files[fn] = d;\n                if (!--lft)\n                    cb(null, files);\n            }\n        };\n        if (!c_1)\n            cbl(null, slc(data, b, b + sc));\n        else if (c_1 == 8) {\n            var infl = data.subarray(b, b + sc);\n            if (sc < 320000) {\n                try {\n                    cbl(null, inflateSync(infl, new u8(su)));\n                }\n                catch (e) {\n                    cbl(e, null);\n                }\n            }\n            else\n                term.push(inflate(infl, { size: su }, cbl));\n        }\n        else\n            cbl('unknown compression type ' + c_1, null);\n    };\n    for (var i = 0; i < c; ++i) {\n        _loop_3(i);\n    }\n    return tAll;\n}\n/**\n * Synchronously decompresses a ZIP archive. Prefer using `unzip` for better\n * performance with more than one file.\n * @param data The raw compressed ZIP file\n * @returns The decompressed files\n */\nexport function unzipSync(data) {\n    var files = {};\n    var e = data.length - 22;\n    for (; b4(data, e) != 0x6054B50; --e) {\n        if (!e || data.length - e > 65558)\n            throw 'invalid zip file';\n    }\n    ;\n    var c = b2(data, e + 8);\n    if (!c)\n        return {};\n    var o = b4(data, e + 16);\n    var z = o == 4294967295;\n    if (z) {\n        e = b4(data, e - 12);\n        if (b4(data, e) != 0x6064B50)\n            throw 'invalid zip file';\n        c = b4(data, e + 32);\n        o = b4(data, e + 48);\n    }\n    for (var i = 0; i < c; ++i) {\n        var _a = zh(data, o, z), c_2 = _a[0], sc = _a[1], su = _a[2], fn = _a[3], no = _a[4], off = _a[5], b = slzh(data, off);\n        o = no;\n        if (!c_2)\n            files[fn] = slc(data, b, b + sc);\n        else if (c_2 == 8)\n            files[fn] = inflateSync(data.subarray(b, b + sc), new u8(su));\n        else\n            throw 'unknown compression type ' + c_2;\n    }\n    return files;\n}\n","import {\n  Texture,\n  DataTextureLoader,\n  DataUtils,\n  FloatType,\n  HalfFloatType,\n  LinearFilter,\n  RedFormat,\n  RGBAFormat,\n} from 'three'\nimport { unzlibSync } from 'fflate'\n\n/**\n * OpenEXR loader currently supports uncompressed, ZIP(S), RLE, PIZ and DWA/B compression.\n * Supports reading as UnsignedByte, HalfFloat and Float type data texture.\n *\n * Referred to the original Industrial Light & Magic OpenEXR implementation and the TinyEXR / Syoyo Fujita\n * implementation, so I have preserved their copyright notices.\n */\n\n// /*\n// Copyright (c) 2014 - 2017, Syoyo Fujita\n// All rights reserved.\n\n// Redistribution and use in source and binary forms, with or without\n// modification, are permitted provided that the following conditions are met:\n//     * Redistributions of source code must retain the above copyright\n//       notice, this list of conditions and the following disclaimer.\n//     * Redistributions in binary form must reproduce the above copyright\n//       notice, this list of conditions and the following disclaimer in the\n//       documentation and/or other materials provided with the distribution.\n//     * Neither the name of the Syoyo Fujita nor the\n//       names of its contributors may be used to endorse or promote products\n//       derived from this software without specific prior written permission.\n\n// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\n// ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n// WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n// DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY\n// DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n// (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n// LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\n// ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\n// SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// */\n\n// // TinyEXR contains some OpenEXR code, which is licensed under ------------\n\n// ///////////////////////////////////////////////////////////////////////////\n// //\n// // Copyright (c) 2002, Industrial Light & Magic, a division of Lucas\n// // Digital Ltd. LLC\n// //\n// // All rights reserved.\n// //\n// // Redistribution and use in source and binary forms, with or without\n// // modification, are permitted provided that the following conditions are\n// // met:\n// // *       Redistributions of source code must retain the above copyright\n// // notice, this list of conditions and the following disclaimer.\n// // *       Redistributions in binary form must reproduce the above\n// // copyright notice, this list of conditions and the following disclaimer\n// // in the documentation and/or other materials provided with the\n// // distribution.\n// // *       Neither the name of Industrial Light & Magic nor the names of\n// // its contributors may be used to endorse or promote products derived\n// // from this software without specific prior written permission.\n// //\n// // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n// // \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n// // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n// // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n// // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n// // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n// // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n// // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n// // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n// // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n// // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n// //\n// ///////////////////////////////////////////////////////////////////////////\n\n// // End of OpenEXR license -------------------------------------------------\n\nconst hasColorSpace = 'colorSpace' in new Texture()\n\nclass EXRLoader extends DataTextureLoader {\n  constructor(manager) {\n    super(manager)\n\n    this.type = HalfFloatType\n  }\n\n  parse(buffer) {\n    const USHORT_RANGE = 1 << 16\n    const BITMAP_SIZE = USHORT_RANGE >> 3\n\n    const HUF_ENCBITS = 16 // literal (value) bit length\n    const HUF_DECBITS = 14 // decoding bit size (>= 8)\n\n    const HUF_ENCSIZE = (1 << HUF_ENCBITS) + 1 // encoding table size\n    const HUF_DECSIZE = 1 << HUF_DECBITS // decoding table size\n    const HUF_DECMASK = HUF_DECSIZE - 1\n\n    const NBITS = 16\n    const A_OFFSET = 1 << (NBITS - 1)\n    const MOD_MASK = (1 << NBITS) - 1\n\n    const SHORT_ZEROCODE_RUN = 59\n    const LONG_ZEROCODE_RUN = 63\n    const SHORTEST_LONG_RUN = 2 + LONG_ZEROCODE_RUN - SHORT_ZEROCODE_RUN\n\n    const ULONG_SIZE = 8\n    const FLOAT32_SIZE = 4\n    const INT32_SIZE = 4\n    const INT16_SIZE = 2\n    const INT8_SIZE = 1\n\n    const STATIC_HUFFMAN = 0\n    const DEFLATE = 1\n\n    const UNKNOWN = 0\n    const LOSSY_DCT = 1\n    const RLE = 2\n\n    const logBase = Math.pow(2.7182818, 2.2)\n\n    function reverseLutFromBitmap(bitmap, lut) {\n      var k = 0\n\n      for (var i = 0; i < USHORT_RANGE; ++i) {\n        if (i == 0 || bitmap[i >> 3] & (1 << (i & 7))) {\n          lut[k++] = i\n        }\n      }\n\n      var n = k - 1\n\n      while (k < USHORT_RANGE) lut[k++] = 0\n\n      return n\n    }\n\n    function hufClearDecTable(hdec) {\n      for (var i = 0; i < HUF_DECSIZE; i++) {\n        hdec[i] = {}\n        hdec[i].len = 0\n        hdec[i].lit = 0\n        hdec[i].p = null\n      }\n    }\n\n    const getBitsReturn = { l: 0, c: 0, lc: 0 }\n\n    function getBits(nBits, c, lc, uInt8Array, inOffset) {\n      while (lc < nBits) {\n        c = (c << 8) | parseUint8Array(uInt8Array, inOffset)\n        lc += 8\n      }\n\n      lc -= nBits\n\n      getBitsReturn.l = (c >> lc) & ((1 << nBits) - 1)\n      getBitsReturn.c = c\n      getBitsReturn.lc = lc\n    }\n\n    const hufTableBuffer = new Array(59)\n\n    function hufCanonicalCodeTable(hcode) {\n      for (var i = 0; i <= 58; ++i) hufTableBuffer[i] = 0\n      for (var i = 0; i < HUF_ENCSIZE; ++i) hufTableBuffer[hcode[i]] += 1\n\n      var c = 0\n\n      for (var i = 58; i > 0; --i) {\n        var nc = (c + hufTableBuffer[i]) >> 1\n        hufTableBuffer[i] = c\n        c = nc\n      }\n\n      for (var i = 0; i < HUF_ENCSIZE; ++i) {\n        var l = hcode[i]\n        if (l > 0) hcode[i] = l | (hufTableBuffer[l]++ << 6)\n      }\n    }\n\n    function hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, hcode) {\n      var p = inOffset\n      var c = 0\n      var lc = 0\n\n      for (; im <= iM; im++) {\n        if (p.value - inOffset.value > ni) return false\n\n        getBits(6, c, lc, uInt8Array, p)\n\n        var l = getBitsReturn.l\n        c = getBitsReturn.c\n        lc = getBitsReturn.lc\n\n        hcode[im] = l\n\n        if (l == LONG_ZEROCODE_RUN) {\n          if (p.value - inOffset.value > ni) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          getBits(8, c, lc, uInt8Array, p)\n\n          var zerun = getBitsReturn.l + SHORTEST_LONG_RUN\n          c = getBitsReturn.c\n          lc = getBitsReturn.lc\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          while (zerun--) hcode[im++] = 0\n\n          im--\n        } else if (l >= SHORT_ZEROCODE_RUN) {\n          var zerun = l - SHORT_ZEROCODE_RUN + 2\n\n          if (im + zerun > iM + 1) {\n            throw 'Something wrong with hufUnpackEncTable'\n          }\n\n          while (zerun--) hcode[im++] = 0\n\n          im--\n        }\n      }\n\n      hufCanonicalCodeTable(hcode)\n    }\n\n    function hufLength(code) {\n      return code & 63\n    }\n\n    function hufCode(code) {\n      return code >> 6\n    }\n\n    function hufBuildDecTable(hcode, im, iM, hdecod) {\n      for (; im <= iM; im++) {\n        var c = hufCode(hcode[im])\n        var l = hufLength(hcode[im])\n\n        if (c >> l) {\n          throw 'Invalid table entry'\n        }\n\n        if (l > HUF_DECBITS) {\n          var pl = hdecod[c >> (l - HUF_DECBITS)]\n\n          if (pl.len) {\n            throw 'Invalid table entry'\n          }\n\n          pl.lit++\n\n          if (pl.p) {\n            var p = pl.p\n            pl.p = new Array(pl.lit)\n\n            for (var i = 0; i < pl.lit - 1; ++i) {\n              pl.p[i] = p[i]\n            }\n          } else {\n            pl.p = new Array(1)\n          }\n\n          pl.p[pl.lit - 1] = im\n        } else if (l) {\n          var plOffset = 0\n\n          for (var i = 1 << (HUF_DECBITS - l); i > 0; i--) {\n            var pl = hdecod[(c << (HUF_DECBITS - l)) + plOffset]\n\n            if (pl.len || pl.p) {\n              throw 'Invalid table entry'\n            }\n\n            pl.len = l\n            pl.lit = im\n\n            plOffset++\n          }\n        }\n      }\n\n      return true\n    }\n\n    const getCharReturn = { c: 0, lc: 0 }\n\n    function getChar(c, lc, uInt8Array, inOffset) {\n      c = (c << 8) | parseUint8Array(uInt8Array, inOffset)\n      lc += 8\n\n      getCharReturn.c = c\n      getCharReturn.lc = lc\n    }\n\n    const getCodeReturn = { c: 0, lc: 0 }\n\n    function getCode(po, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outBufferOffset, outBufferEndOffset) {\n      if (po == rlc) {\n        if (lc < 8) {\n          getChar(c, lc, uInt8Array, inOffset)\n          c = getCharReturn.c\n          lc = getCharReturn.lc\n        }\n\n        lc -= 8\n\n        var cs = c >> lc\n        var cs = new Uint8Array([cs])[0]\n\n        if (outBufferOffset.value + cs > outBufferEndOffset) {\n          return false\n        }\n\n        var s = outBuffer[outBufferOffset.value - 1]\n\n        while (cs-- > 0) {\n          outBuffer[outBufferOffset.value++] = s\n        }\n      } else if (outBufferOffset.value < outBufferEndOffset) {\n        outBuffer[outBufferOffset.value++] = po\n      } else {\n        return false\n      }\n\n      getCodeReturn.c = c\n      getCodeReturn.lc = lc\n    }\n\n    function UInt16(value) {\n      return value & 0xffff\n    }\n\n    function Int16(value) {\n      var ref = UInt16(value)\n      return ref > 0x7fff ? ref - 0x10000 : ref\n    }\n\n    const wdec14Return = { a: 0, b: 0 }\n\n    function wdec14(l, h) {\n      var ls = Int16(l)\n      var hs = Int16(h)\n\n      var hi = hs\n      var ai = ls + (hi & 1) + (hi >> 1)\n\n      var as = ai\n      var bs = ai - hi\n\n      wdec14Return.a = as\n      wdec14Return.b = bs\n    }\n\n    function wdec16(l, h) {\n      var m = UInt16(l)\n      var d = UInt16(h)\n\n      var bb = (m - (d >> 1)) & MOD_MASK\n      var aa = (d + bb - A_OFFSET) & MOD_MASK\n\n      wdec14Return.a = aa\n      wdec14Return.b = bb\n    }\n\n    function wav2Decode(buffer, j, nx, ox, ny, oy, mx) {\n      var w14 = mx < 1 << 14\n      var n = nx > ny ? ny : nx\n      var p = 1\n      var p2\n\n      while (p <= n) p <<= 1\n\n      p >>= 1\n      p2 = p\n      p >>= 1\n\n      while (p >= 1) {\n        var py = 0\n        var ey = py + oy * (ny - p2)\n        var oy1 = oy * p\n        var oy2 = oy * p2\n        var ox1 = ox * p\n        var ox2 = ox * p2\n        var i00, i01, i10, i11\n\n        for (; py <= ey; py += oy2) {\n          var px = py\n          var ex = py + ox * (nx - p2)\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1\n            var p10 = px + oy1\n            var p11 = p10 + ox1\n\n            if (w14) {\n              wdec14(buffer[px + j], buffer[p10 + j])\n\n              i00 = wdec14Return.a\n              i10 = wdec14Return.b\n\n              wdec14(buffer[p01 + j], buffer[p11 + j])\n\n              i01 = wdec14Return.a\n              i11 = wdec14Return.b\n\n              wdec14(i00, i01)\n\n              buffer[px + j] = wdec14Return.a\n              buffer[p01 + j] = wdec14Return.b\n\n              wdec14(i10, i11)\n\n              buffer[p10 + j] = wdec14Return.a\n              buffer[p11 + j] = wdec14Return.b\n            } else {\n              wdec16(buffer[px + j], buffer[p10 + j])\n\n              i00 = wdec14Return.a\n              i10 = wdec14Return.b\n\n              wdec16(buffer[p01 + j], buffer[p11 + j])\n\n              i01 = wdec14Return.a\n              i11 = wdec14Return.b\n\n              wdec16(i00, i01)\n\n              buffer[px + j] = wdec14Return.a\n              buffer[p01 + j] = wdec14Return.b\n\n              wdec16(i10, i11)\n\n              buffer[p10 + j] = wdec14Return.a\n              buffer[p11 + j] = wdec14Return.b\n            }\n          }\n\n          if (nx & p) {\n            var p10 = px + oy1\n\n            if (w14) wdec14(buffer[px + j], buffer[p10 + j])\n            else wdec16(buffer[px + j], buffer[p10 + j])\n\n            i00 = wdec14Return.a\n            buffer[p10 + j] = wdec14Return.b\n\n            buffer[px + j] = i00\n          }\n        }\n\n        if (ny & p) {\n          var px = py\n          var ex = py + ox * (nx - p2)\n\n          for (; px <= ex; px += ox2) {\n            var p01 = px + ox1\n\n            if (w14) wdec14(buffer[px + j], buffer[p01 + j])\n            else wdec16(buffer[px + j], buffer[p01 + j])\n\n            i00 = wdec14Return.a\n            buffer[p01 + j] = wdec14Return.b\n\n            buffer[px + j] = i00\n          }\n        }\n\n        p2 = p\n        p >>= 1\n      }\n\n      return py\n    }\n\n    function hufDecode(\n      encodingTable,\n      decodingTable,\n      uInt8Array,\n      inDataView,\n      inOffset,\n      ni,\n      rlc,\n      no,\n      outBuffer,\n      outOffset,\n    ) {\n      var c = 0\n      var lc = 0\n      var outBufferEndOffset = no\n      var inOffsetEnd = Math.trunc(inOffset.value + (ni + 7) / 8)\n\n      while (inOffset.value < inOffsetEnd) {\n        getChar(c, lc, uInt8Array, inOffset)\n\n        c = getCharReturn.c\n        lc = getCharReturn.lc\n\n        while (lc >= HUF_DECBITS) {\n          var index = (c >> (lc - HUF_DECBITS)) & HUF_DECMASK\n          var pl = decodingTable[index]\n\n          if (pl.len) {\n            lc -= pl.len\n\n            getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset)\n\n            c = getCodeReturn.c\n            lc = getCodeReturn.lc\n          } else {\n            if (!pl.p) {\n              throw 'hufDecode issues'\n            }\n\n            var j\n\n            for (j = 0; j < pl.lit; j++) {\n              var l = hufLength(encodingTable[pl.p[j]])\n\n              while (lc < l && inOffset.value < inOffsetEnd) {\n                getChar(c, lc, uInt8Array, inOffset)\n\n                c = getCharReturn.c\n                lc = getCharReturn.lc\n              }\n\n              if (lc >= l) {\n                if (hufCode(encodingTable[pl.p[j]]) == ((c >> (lc - l)) & ((1 << l) - 1))) {\n                  lc -= l\n\n                  getCode(\n                    pl.p[j],\n                    rlc,\n                    c,\n                    lc,\n                    uInt8Array,\n                    inDataView,\n                    inOffset,\n                    outBuffer,\n                    outOffset,\n                    outBufferEndOffset,\n                  )\n\n                  c = getCodeReturn.c\n                  lc = getCodeReturn.lc\n\n                  break\n                }\n              }\n            }\n\n            if (j == pl.lit) {\n              throw 'hufDecode issues'\n            }\n          }\n        }\n      }\n\n      var i = (8 - ni) & 7\n\n      c >>= i\n      lc -= i\n\n      while (lc > 0) {\n        var pl = decodingTable[(c << (HUF_DECBITS - lc)) & HUF_DECMASK]\n\n        if (pl.len) {\n          lc -= pl.len\n\n          getCode(pl.lit, rlc, c, lc, uInt8Array, inDataView, inOffset, outBuffer, outOffset, outBufferEndOffset)\n\n          c = getCodeReturn.c\n          lc = getCodeReturn.lc\n        } else {\n          throw 'hufDecode issues'\n        }\n      }\n\n      return true\n    }\n\n    function hufUncompress(uInt8Array, inDataView, inOffset, nCompressed, outBuffer, nRaw) {\n      var outOffset = { value: 0 }\n      var initialInOffset = inOffset.value\n\n      var im = parseUint32(inDataView, inOffset)\n      var iM = parseUint32(inDataView, inOffset)\n\n      inOffset.value += 4\n\n      var nBits = parseUint32(inDataView, inOffset)\n\n      inOffset.value += 4\n\n      if (im < 0 || im >= HUF_ENCSIZE || iM < 0 || iM >= HUF_ENCSIZE) {\n        throw 'Something wrong with HUF_ENCSIZE'\n      }\n\n      var freq = new Array(HUF_ENCSIZE)\n      var hdec = new Array(HUF_DECSIZE)\n\n      hufClearDecTable(hdec)\n\n      var ni = nCompressed - (inOffset.value - initialInOffset)\n\n      hufUnpackEncTable(uInt8Array, inDataView, inOffset, ni, im, iM, freq)\n\n      if (nBits > 8 * (nCompressed - (inOffset.value - initialInOffset))) {\n        throw 'Something wrong with hufUncompress'\n      }\n\n      hufBuildDecTable(freq, im, iM, hdec)\n\n      hufDecode(freq, hdec, uInt8Array, inDataView, inOffset, nBits, iM, nRaw, outBuffer, outOffset)\n    }\n\n    function applyLut(lut, data, nData) {\n      for (var i = 0; i < nData; ++i) {\n        data[i] = lut[data[i]]\n      }\n    }\n\n    function predictor(source) {\n      for (var t = 1; t < source.length; t++) {\n        var d = source[t - 1] + source[t] - 128\n        source[t] = d\n      }\n    }\n\n    function interleaveScalar(source, out) {\n      var t1 = 0\n      var t2 = Math.floor((source.length + 1) / 2)\n      var s = 0\n      var stop = source.length - 1\n\n      while (true) {\n        if (s > stop) break\n        out[s++] = source[t1++]\n\n        if (s > stop) break\n        out[s++] = source[t2++]\n      }\n    }\n\n    function decodeRunLength(source) {\n      var size = source.byteLength\n      var out = new Array()\n      var p = 0\n\n      var reader = new DataView(source)\n\n      while (size > 0) {\n        var l = reader.getInt8(p++)\n\n        if (l < 0) {\n          var count = -l\n          size -= count + 1\n\n          for (var i = 0; i < count; i++) {\n            out.push(reader.getUint8(p++))\n          }\n        } else {\n          var count = l\n          size -= 2\n\n          var value = reader.getUint8(p++)\n\n          for (var i = 0; i < count + 1; i++) {\n            out.push(value)\n          }\n        }\n      }\n\n      return out\n    }\n\n    function lossyDctDecode(cscSet, rowPtrs, channelData, acBuffer, dcBuffer, outBuffer) {\n      var dataView = new DataView(outBuffer.buffer)\n\n      var width = channelData[cscSet.idx[0]].width\n      var height = channelData[cscSet.idx[0]].height\n\n      var numComp = 3\n\n      var numFullBlocksX = Math.floor(width / 8.0)\n      var numBlocksX = Math.ceil(width / 8.0)\n      var numBlocksY = Math.ceil(height / 8.0)\n      var leftoverX = width - (numBlocksX - 1) * 8\n      var leftoverY = height - (numBlocksY - 1) * 8\n\n      var currAcComp = { value: 0 }\n      var currDcComp = new Array(numComp)\n      var dctData = new Array(numComp)\n      var halfZigBlock = new Array(numComp)\n      var rowBlock = new Array(numComp)\n      var rowOffsets = new Array(numComp)\n\n      for (let comp = 0; comp < numComp; ++comp) {\n        rowOffsets[comp] = rowPtrs[cscSet.idx[comp]]\n        currDcComp[comp] = comp < 1 ? 0 : currDcComp[comp - 1] + numBlocksX * numBlocksY\n        dctData[comp] = new Float32Array(64)\n        halfZigBlock[comp] = new Uint16Array(64)\n        rowBlock[comp] = new Uint16Array(numBlocksX * 64)\n      }\n\n      for (let blocky = 0; blocky < numBlocksY; ++blocky) {\n        var maxY = 8\n\n        if (blocky == numBlocksY - 1) maxY = leftoverY\n\n        var maxX = 8\n\n        for (let blockx = 0; blockx < numBlocksX; ++blockx) {\n          if (blockx == numBlocksX - 1) maxX = leftoverX\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            halfZigBlock[comp].fill(0)\n\n            // set block DC component\n            halfZigBlock[comp][0] = dcBuffer[currDcComp[comp]++]\n            // set block AC components\n            unRleAC(currAcComp, acBuffer, halfZigBlock[comp])\n\n            // UnZigZag block to float\n            unZigZag(halfZigBlock[comp], dctData[comp])\n            // decode float dct\n            dctInverse(dctData[comp])\n          }\n\n          if (numComp == 3) {\n            csc709Inverse(dctData)\n          }\n\n          for (let comp = 0; comp < numComp; ++comp) {\n            convertToHalf(dctData[comp], rowBlock[comp], blockx * 64)\n          }\n        } // blockx\n\n        let offset = 0\n\n        for (let comp = 0; comp < numComp; ++comp) {\n          const type = channelData[cscSet.idx[comp]].type\n\n          for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n            offset = rowOffsets[comp][y]\n\n            for (let blockx = 0; blockx < numFullBlocksX; ++blockx) {\n              const src = blockx * 64 + (y & 0x7) * 8\n\n              dataView.setUint16(offset + 0 * INT16_SIZE * type, rowBlock[comp][src + 0], true)\n              dataView.setUint16(offset + 1 * INT16_SIZE * type, rowBlock[comp][src + 1], true)\n              dataView.setUint16(offset + 2 * INT16_SIZE * type, rowBlock[comp][src + 2], true)\n              dataView.setUint16(offset + 3 * INT16_SIZE * type, rowBlock[comp][src + 3], true)\n\n              dataView.setUint16(offset + 4 * INT16_SIZE * type, rowBlock[comp][src + 4], true)\n              dataView.setUint16(offset + 5 * INT16_SIZE * type, rowBlock[comp][src + 5], true)\n              dataView.setUint16(offset + 6 * INT16_SIZE * type, rowBlock[comp][src + 6], true)\n              dataView.setUint16(offset + 7 * INT16_SIZE * type, rowBlock[comp][src + 7], true)\n\n              offset += 8 * INT16_SIZE * type\n            }\n          }\n\n          // handle partial X blocks\n          if (numFullBlocksX != numBlocksX) {\n            for (let y = 8 * blocky; y < 8 * blocky + maxY; ++y) {\n              const offset = rowOffsets[comp][y] + 8 * numFullBlocksX * INT16_SIZE * type\n              const src = numFullBlocksX * 64 + (y & 0x7) * 8\n\n              for (let x = 0; x < maxX; ++x) {\n                dataView.setUint16(offset + x * INT16_SIZE * type, rowBlock[comp][src + x], true)\n              }\n            }\n          }\n        } // comp\n      } // blocky\n\n      var halfRow = new Uint16Array(width)\n      var dataView = new DataView(outBuffer.buffer)\n\n      // convert channels back to float, if needed\n      for (var comp = 0; comp < numComp; ++comp) {\n        channelData[cscSet.idx[comp]].decoded = true\n        var type = channelData[cscSet.idx[comp]].type\n\n        if (channelData[comp].type != 2) continue\n\n        for (var y = 0; y < height; ++y) {\n          const offset = rowOffsets[comp][y]\n\n          for (var x = 0; x < width; ++x) {\n            halfRow[x] = dataView.getUint16(offset + x * INT16_SIZE * type, true)\n          }\n\n          for (var x = 0; x < width; ++x) {\n            dataView.setFloat32(offset + x * INT16_SIZE * type, decodeFloat16(halfRow[x]), true)\n          }\n        }\n      }\n    }\n\n    function unRleAC(currAcComp, acBuffer, halfZigBlock) {\n      var acValue\n      var dctComp = 1\n\n      while (dctComp < 64) {\n        acValue = acBuffer[currAcComp.value]\n\n        if (acValue == 0xff00) {\n          dctComp = 64\n        } else if (acValue >> 8 == 0xff) {\n          dctComp += acValue & 0xff\n        } else {\n          halfZigBlock[dctComp] = acValue\n          dctComp++\n        }\n\n        currAcComp.value++\n      }\n    }\n\n    function unZigZag(src, dst) {\n      dst[0] = decodeFloat16(src[0])\n      dst[1] = decodeFloat16(src[1])\n      dst[2] = decodeFloat16(src[5])\n      dst[3] = decodeFloat16(src[6])\n      dst[4] = decodeFloat16(src[14])\n      dst[5] = decodeFloat16(src[15])\n      dst[6] = decodeFloat16(src[27])\n      dst[7] = decodeFloat16(src[28])\n      dst[8] = decodeFloat16(src[2])\n      dst[9] = decodeFloat16(src[4])\n\n      dst[10] = decodeFloat16(src[7])\n      dst[11] = decodeFloat16(src[13])\n      dst[12] = decodeFloat16(src[16])\n      dst[13] = decodeFloat16(src[26])\n      dst[14] = decodeFloat16(src[29])\n      dst[15] = decodeFloat16(src[42])\n      dst[16] = decodeFloat16(src[3])\n      dst[17] = decodeFloat16(src[8])\n      dst[18] = decodeFloat16(src[12])\n      dst[19] = decodeFloat16(src[17])\n\n      dst[20] = decodeFloat16(src[25])\n      dst[21] = decodeFloat16(src[30])\n      dst[22] = decodeFloat16(src[41])\n      dst[23] = decodeFloat16(src[43])\n      dst[24] = decodeFloat16(src[9])\n      dst[25] = decodeFloat16(src[11])\n      dst[26] = decodeFloat16(src[18])\n      dst[27] = decodeFloat16(src[24])\n      dst[28] = decodeFloat16(src[31])\n      dst[29] = decodeFloat16(src[40])\n\n      dst[30] = decodeFloat16(src[44])\n      dst[31] = decodeFloat16(src[53])\n      dst[32] = decodeFloat16(src[10])\n      dst[33] = decodeFloat16(src[19])\n      dst[34] = decodeFloat16(src[23])\n      dst[35] = decodeFloat16(src[32])\n      dst[36] = decodeFloat16(src[39])\n      dst[37] = decodeFloat16(src[45])\n      dst[38] = decodeFloat16(src[52])\n      dst[39] = decodeFloat16(src[54])\n\n      dst[40] = decodeFloat16(src[20])\n      dst[41] = decodeFloat16(src[22])\n      dst[42] = decodeFloat16(src[33])\n      dst[43] = decodeFloat16(src[38])\n      dst[44] = decodeFloat16(src[46])\n      dst[45] = decodeFloat16(src[51])\n      dst[46] = decodeFloat16(src[55])\n      dst[47] = decodeFloat16(src[60])\n      dst[48] = decodeFloat16(src[21])\n      dst[49] = decodeFloat16(src[34])\n\n      dst[50] = decodeFloat16(src[37])\n      dst[51] = decodeFloat16(src[47])\n      dst[52] = decodeFloat16(src[50])\n      dst[53] = decodeFloat16(src[56])\n      dst[54] = decodeFloat16(src[59])\n      dst[55] = decodeFloat16(src[61])\n      dst[56] = decodeFloat16(src[35])\n      dst[57] = decodeFloat16(src[36])\n      dst[58] = decodeFloat16(src[48])\n      dst[59] = decodeFloat16(src[49])\n\n      dst[60] = decodeFloat16(src[57])\n      dst[61] = decodeFloat16(src[58])\n      dst[62] = decodeFloat16(src[62])\n      dst[63] = decodeFloat16(src[63])\n    }\n\n    function dctInverse(data) {\n      const a = 0.5 * Math.cos(3.14159 / 4.0)\n      const b = 0.5 * Math.cos(3.14159 / 16.0)\n      const c = 0.5 * Math.cos(3.14159 / 8.0)\n      const d = 0.5 * Math.cos((3.0 * 3.14159) / 16.0)\n      const e = 0.5 * Math.cos((5.0 * 3.14159) / 16.0)\n      const f = 0.5 * Math.cos((3.0 * 3.14159) / 8.0)\n      const g = 0.5 * Math.cos((7.0 * 3.14159) / 16.0)\n\n      var alpha = new Array(4)\n      var beta = new Array(4)\n      var theta = new Array(4)\n      var gamma = new Array(4)\n\n      for (var row = 0; row < 8; ++row) {\n        var rowPtr = row * 8\n\n        alpha[0] = c * data[rowPtr + 2]\n        alpha[1] = f * data[rowPtr + 2]\n        alpha[2] = c * data[rowPtr + 6]\n        alpha[3] = f * data[rowPtr + 6]\n\n        beta[0] = b * data[rowPtr + 1] + d * data[rowPtr + 3] + e * data[rowPtr + 5] + g * data[rowPtr + 7]\n        beta[1] = d * data[rowPtr + 1] - g * data[rowPtr + 3] - b * data[rowPtr + 5] - e * data[rowPtr + 7]\n        beta[2] = e * data[rowPtr + 1] - b * data[rowPtr + 3] + g * data[rowPtr + 5] + d * data[rowPtr + 7]\n        beta[3] = g * data[rowPtr + 1] - e * data[rowPtr + 3] + d * data[rowPtr + 5] - b * data[rowPtr + 7]\n\n        theta[0] = a * (data[rowPtr + 0] + data[rowPtr + 4])\n        theta[3] = a * (data[rowPtr + 0] - data[rowPtr + 4])\n        theta[1] = alpha[0] + alpha[3]\n        theta[2] = alpha[1] - alpha[2]\n\n        gamma[0] = theta[0] + theta[1]\n        gamma[1] = theta[3] + theta[2]\n        gamma[2] = theta[3] - theta[2]\n        gamma[3] = theta[0] - theta[1]\n\n        data[rowPtr + 0] = gamma[0] + beta[0]\n        data[rowPtr + 1] = gamma[1] + beta[1]\n        data[rowPtr + 2] = gamma[2] + beta[2]\n        data[rowPtr + 3] = gamma[3] + beta[3]\n\n        data[rowPtr + 4] = gamma[3] - beta[3]\n        data[rowPtr + 5] = gamma[2] - beta[2]\n        data[rowPtr + 6] = gamma[1] - beta[1]\n        data[rowPtr + 7] = gamma[0] - beta[0]\n      }\n\n      for (var column = 0; column < 8; ++column) {\n        alpha[0] = c * data[16 + column]\n        alpha[1] = f * data[16 + column]\n        alpha[2] = c * data[48 + column]\n        alpha[3] = f * data[48 + column]\n\n        beta[0] = b * data[8 + column] + d * data[24 + column] + e * data[40 + column] + g * data[56 + column]\n        beta[1] = d * data[8 + column] - g * data[24 + column] - b * data[40 + column] - e * data[56 + column]\n        beta[2] = e * data[8 + column] - b * data[24 + column] + g * data[40 + column] + d * data[56 + column]\n        beta[3] = g * data[8 + column] - e * data[24 + column] + d * data[40 + column] - b * data[56 + column]\n\n        theta[0] = a * (data[column] + data[32 + column])\n        theta[3] = a * (data[column] - data[32 + column])\n\n        theta[1] = alpha[0] + alpha[3]\n        theta[2] = alpha[1] - alpha[2]\n\n        gamma[0] = theta[0] + theta[1]\n        gamma[1] = theta[3] + theta[2]\n        gamma[2] = theta[3] - theta[2]\n        gamma[3] = theta[0] - theta[1]\n\n        data[0 + column] = gamma[0] + beta[0]\n        data[8 + column] = gamma[1] + beta[1]\n        data[16 + column] = gamma[2] + beta[2]\n        data[24 + column] = gamma[3] + beta[3]\n\n        data[32 + column] = gamma[3] - beta[3]\n        data[40 + column] = gamma[2] - beta[2]\n        data[48 + column] = gamma[1] - beta[1]\n        data[56 + column] = gamma[0] - beta[0]\n      }\n    }\n\n    function csc709Inverse(data) {\n      for (var i = 0; i < 64; ++i) {\n        var y = data[0][i]\n        var cb = data[1][i]\n        var cr = data[2][i]\n\n        data[0][i] = y + 1.5747 * cr\n        data[1][i] = y - 0.1873 * cb - 0.4682 * cr\n        data[2][i] = y + 1.8556 * cb\n      }\n    }\n\n    function convertToHalf(src, dst, idx) {\n      for (var i = 0; i < 64; ++i) {\n        dst[idx + i] = DataUtils.toHalfFloat(toLinear(src[i]))\n      }\n    }\n\n    function toLinear(float) {\n      if (float <= 1) {\n        return Math.sign(float) * Math.pow(Math.abs(float), 2.2)\n      } else {\n        return Math.sign(float) * Math.pow(logBase, Math.abs(float) - 1.0)\n      }\n    }\n\n    function uncompressRAW(info) {\n      return new DataView(info.array.buffer, info.offset.value, info.size)\n    }\n\n    function uncompressRLE(info) {\n      var compressed = info.viewer.buffer.slice(info.offset.value, info.offset.value + info.size)\n\n      var rawBuffer = new Uint8Array(decodeRunLength(compressed))\n      var tmpBuffer = new Uint8Array(rawBuffer.length)\n\n      predictor(rawBuffer) // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer) // interleave pixels\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressZIP(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size)\n      var rawBuffer = unzlibSync(compressed)\n      var tmpBuffer = new Uint8Array(rawBuffer.length)\n\n      predictor(rawBuffer) // revert predictor\n\n      interleaveScalar(rawBuffer, tmpBuffer) // interleave pixels\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressPIZ(info) {\n      var inDataView = info.viewer\n      var inOffset = { value: info.offset.value }\n\n      var outBuffer = new Uint16Array(info.width * info.scanlineBlockSize * (info.channels * info.type))\n      var bitmap = new Uint8Array(BITMAP_SIZE)\n\n      // Setup channel info\n      var outBufferEnd = 0\n      var pizChannelData = new Array(info.channels)\n      for (var i = 0; i < info.channels; i++) {\n        pizChannelData[i] = {}\n        pizChannelData[i]['start'] = outBufferEnd\n        pizChannelData[i]['end'] = pizChannelData[i]['start']\n        pizChannelData[i]['nx'] = info.width\n        pizChannelData[i]['ny'] = info.lines\n        pizChannelData[i]['size'] = info.type\n\n        outBufferEnd += pizChannelData[i].nx * pizChannelData[i].ny * pizChannelData[i].size\n      }\n\n      // Read range compression data\n\n      var minNonZero = parseUint16(inDataView, inOffset)\n      var maxNonZero = parseUint16(inDataView, inOffset)\n\n      if (maxNonZero >= BITMAP_SIZE) {\n        throw 'Something is wrong with PIZ_COMPRESSION BITMAP_SIZE'\n      }\n\n      if (minNonZero <= maxNonZero) {\n        for (var i = 0; i < maxNonZero - minNonZero + 1; i++) {\n          bitmap[i + minNonZero] = parseUint8(inDataView, inOffset)\n        }\n      }\n\n      // Reverse LUT\n      var lut = new Uint16Array(USHORT_RANGE)\n      var maxValue = reverseLutFromBitmap(bitmap, lut)\n\n      var length = parseUint32(inDataView, inOffset)\n\n      // Huffman decoding\n      hufUncompress(info.array, inDataView, inOffset, length, outBuffer, outBufferEnd)\n\n      // Wavelet decoding\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = pizChannelData[i]\n\n        for (var j = 0; j < pizChannelData[i].size; ++j) {\n          wav2Decode(outBuffer, cd.start + j, cd.nx, cd.size, cd.ny, cd.nx * cd.size, maxValue)\n        }\n      }\n\n      // Expand the pixel data to their original range\n      applyLut(lut, outBuffer, outBufferEnd)\n\n      // Rearrange the pixel data into the format expected by the caller.\n      var tmpOffset = 0\n      var tmpBuffer = new Uint8Array(outBuffer.buffer.byteLength)\n      for (var y = 0; y < info.lines; y++) {\n        for (var c = 0; c < info.channels; c++) {\n          var cd = pizChannelData[c]\n\n          var n = cd.nx * cd.size\n          var cp = new Uint8Array(outBuffer.buffer, cd.end * INT16_SIZE, n * INT16_SIZE)\n\n          tmpBuffer.set(cp, tmpOffset)\n          tmpOffset += n * INT16_SIZE\n          cd.end += n\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressPXR(info) {\n      var compressed = info.array.slice(info.offset.value, info.offset.value + info.size)\n      var rawBuffer = unzlibSync(compressed)\n\n      const sz = info.lines * info.channels * info.width\n      const tmpBuffer = info.type == 1 ? new Uint16Array(sz) : new Uint32Array(sz)\n\n      let tmpBufferEnd = 0\n      let writePtr = 0\n      const ptr = new Array(4)\n\n      for (let y = 0; y < info.lines; y++) {\n        for (let c = 0; c < info.channels; c++) {\n          let pixel = 0\n\n          switch (info.type) {\n            case 1:\n              ptr[0] = tmpBufferEnd\n              ptr[1] = ptr[0] + info.width\n              tmpBufferEnd = ptr[1] + info.width\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = (rawBuffer[ptr[0]++] << 8) | rawBuffer[ptr[1]++]\n\n                pixel += diff\n\n                tmpBuffer[writePtr] = pixel\n                writePtr++\n              }\n\n              break\n\n            case 2:\n              ptr[0] = tmpBufferEnd\n              ptr[1] = ptr[0] + info.width\n              ptr[2] = ptr[1] + info.width\n              tmpBufferEnd = ptr[2] + info.width\n\n              for (let j = 0; j < info.width; ++j) {\n                const diff = (rawBuffer[ptr[0]++] << 24) | (rawBuffer[ptr[1]++] << 16) | (rawBuffer[ptr[2]++] << 8)\n\n                pixel += diff\n\n                tmpBuffer[writePtr] = pixel\n                writePtr++\n              }\n\n              break\n          }\n        }\n      }\n\n      return new DataView(tmpBuffer.buffer)\n    }\n\n    function uncompressDWA(info) {\n      var inDataView = info.viewer\n      var inOffset = { value: info.offset.value }\n      var outBuffer = new Uint8Array(info.width * info.lines * (info.channels * info.type * INT16_SIZE))\n\n      // Read compression header information\n      var dwaHeader = {\n        version: parseInt64(inDataView, inOffset),\n        unknownUncompressedSize: parseInt64(inDataView, inOffset),\n        unknownCompressedSize: parseInt64(inDataView, inOffset),\n        acCompressedSize: parseInt64(inDataView, inOffset),\n        dcCompressedSize: parseInt64(inDataView, inOffset),\n        rleCompressedSize: parseInt64(inDataView, inOffset),\n        rleUncompressedSize: parseInt64(inDataView, inOffset),\n        rleRawSize: parseInt64(inDataView, inOffset),\n        totalAcUncompressedCount: parseInt64(inDataView, inOffset),\n        totalDcUncompressedCount: parseInt64(inDataView, inOffset),\n        acCompression: parseInt64(inDataView, inOffset),\n      }\n\n      if (dwaHeader.version < 2) {\n        throw 'EXRLoader.parse: ' + EXRHeader.compression + ' version ' + dwaHeader.version + ' is unsupported'\n      }\n\n      // Read channel ruleset information\n      var channelRules = new Array()\n      var ruleSize = parseUint16(inDataView, inOffset) - INT16_SIZE\n\n      while (ruleSize > 0) {\n        var name = parseNullTerminatedString(inDataView.buffer, inOffset)\n        var value = parseUint8(inDataView, inOffset)\n        var compression = (value >> 2) & 3\n        var csc = (value >> 4) - 1\n        var index = new Int8Array([csc])[0]\n        var type = parseUint8(inDataView, inOffset)\n\n        channelRules.push({\n          name: name,\n          index: index,\n          type: type,\n          compression: compression,\n        })\n\n        ruleSize -= name.length + 3\n      }\n\n      // Classify channels\n      var channels = EXRHeader.channels\n      var channelData = new Array(info.channels)\n\n      for (var i = 0; i < info.channels; ++i) {\n        var cd = (channelData[i] = {})\n        var channel = channels[i]\n\n        cd.name = channel.name\n        cd.compression = UNKNOWN\n        cd.decoded = false\n        cd.type = channel.pixelType\n        cd.pLinear = channel.pLinear\n        cd.width = info.width\n        cd.height = info.lines\n      }\n\n      var cscSet = {\n        idx: new Array(3),\n      }\n\n      for (var offset = 0; offset < info.channels; ++offset) {\n        var cd = channelData[offset]\n\n        for (var i = 0; i < channelRules.length; ++i) {\n          var rule = channelRules[i]\n\n          if (cd.name == rule.name) {\n            cd.compression = rule.compression\n\n            if (rule.index >= 0) {\n              cscSet.idx[rule.index] = offset\n            }\n\n            cd.offset = offset\n          }\n        }\n      }\n\n      // Read DCT - AC component data\n      if (dwaHeader.acCompressedSize > 0) {\n        switch (dwaHeader.acCompression) {\n          case STATIC_HUFFMAN:\n            var acBuffer = new Uint16Array(dwaHeader.totalAcUncompressedCount)\n            hufUncompress(\n              info.array,\n              inDataView,\n              inOffset,\n              dwaHeader.acCompressedSize,\n              acBuffer,\n              dwaHeader.totalAcUncompressedCount,\n            )\n            break\n\n          case DEFLATE:\n            var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.totalAcUncompressedCount)\n            var data = unzlibSync(compressed)\n            var acBuffer = new Uint16Array(data.buffer)\n            inOffset.value += dwaHeader.totalAcUncompressedCount\n            break\n        }\n      }\n\n      // Read DCT - DC component data\n      if (dwaHeader.dcCompressedSize > 0) {\n        var zlibInfo = {\n          array: info.array,\n          offset: inOffset,\n          size: dwaHeader.dcCompressedSize,\n        }\n        var dcBuffer = new Uint16Array(uncompressZIP(zlibInfo).buffer)\n        inOffset.value += dwaHeader.dcCompressedSize\n      }\n\n      // Read RLE compressed data\n      if (dwaHeader.rleRawSize > 0) {\n        var compressed = info.array.slice(inOffset.value, inOffset.value + dwaHeader.rleCompressedSize)\n        var data = unzlibSync(compressed)\n        var rleBuffer = decodeRunLength(data.buffer)\n\n        inOffset.value += dwaHeader.rleCompressedSize\n      }\n\n      // Prepare outbuffer data offset\n      var outBufferEnd = 0\n      var rowOffsets = new Array(channelData.length)\n      for (var i = 0; i < rowOffsets.length; ++i) {\n        rowOffsets[i] = new Array()\n      }\n\n      for (var y = 0; y < info.lines; ++y) {\n        for (var chan = 0; chan < channelData.length; ++chan) {\n          rowOffsets[chan].push(outBufferEnd)\n          outBufferEnd += channelData[chan].width * info.type * INT16_SIZE\n        }\n      }\n\n      // Lossy DCT decode RGB channels\n      lossyDctDecode(cscSet, rowOffsets, channelData, acBuffer, dcBuffer, outBuffer)\n\n      // Decode other channels\n      for (var i = 0; i < channelData.length; ++i) {\n        var cd = channelData[i]\n\n        if (cd.decoded) continue\n\n        switch (cd.compression) {\n          case RLE:\n            var row = 0\n            var rleOffset = 0\n\n            for (var y = 0; y < info.lines; ++y) {\n              var rowOffsetBytes = rowOffsets[i][row]\n\n              for (var x = 0; x < cd.width; ++x) {\n                for (var byte = 0; byte < INT16_SIZE * cd.type; ++byte) {\n                  outBuffer[rowOffsetBytes++] = rleBuffer[rleOffset + byte * cd.width * cd.height]\n                }\n\n                rleOffset++\n              }\n\n              row++\n            }\n\n            break\n\n          case LOSSY_DCT: // skip\n\n          default:\n            throw 'EXRLoader.parse: unsupported channel compression'\n        }\n      }\n\n      return new DataView(outBuffer.buffer)\n    }\n\n    function parseNullTerminatedString(buffer, offset) {\n      var uintBuffer = new Uint8Array(buffer)\n      var endOffset = 0\n\n      while (uintBuffer[offset.value + endOffset] != 0) {\n        endOffset += 1\n      }\n\n      var stringValue = new TextDecoder().decode(uintBuffer.slice(offset.value, offset.value + endOffset))\n\n      offset.value = offset.value + endOffset + 1\n\n      return stringValue\n    }\n\n    function parseFixedLengthString(buffer, offset, size) {\n      var stringValue = new TextDecoder().decode(new Uint8Array(buffer).slice(offset.value, offset.value + size))\n\n      offset.value = offset.value + size\n\n      return stringValue\n    }\n\n    function parseRational(dataView, offset) {\n      var x = parseInt32(dataView, offset)\n      var y = parseUint32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseTimecode(dataView, offset) {\n      var x = parseUint32(dataView, offset)\n      var y = parseUint32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseInt32(dataView, offset) {\n      var Int32 = dataView.getInt32(offset.value, true)\n\n      offset.value = offset.value + INT32_SIZE\n\n      return Int32\n    }\n\n    function parseUint32(dataView, offset) {\n      var Uint32 = dataView.getUint32(offset.value, true)\n\n      offset.value = offset.value + INT32_SIZE\n\n      return Uint32\n    }\n\n    function parseUint8Array(uInt8Array, offset) {\n      var Uint8 = uInt8Array[offset.value]\n\n      offset.value = offset.value + INT8_SIZE\n\n      return Uint8\n    }\n\n    function parseUint8(dataView, offset) {\n      var Uint8 = dataView.getUint8(offset.value)\n\n      offset.value = offset.value + INT8_SIZE\n\n      return Uint8\n    }\n\n    const parseInt64 = function (dataView, offset) {\n      let int\n\n      if ('getBigInt64' in DataView.prototype) {\n        int = Number(dataView.getBigInt64(offset.value, true))\n      } else {\n        int = dataView.getUint32(offset.value + 4, true) + Number(dataView.getUint32(offset.value, true) << 32)\n      }\n\n      offset.value += ULONG_SIZE\n\n      return int\n    }\n\n    function parseFloat32(dataView, offset) {\n      var float = dataView.getFloat32(offset.value, true)\n\n      offset.value += FLOAT32_SIZE\n\n      return float\n    }\n\n    function decodeFloat32(dataView, offset) {\n      return DataUtils.toHalfFloat(parseFloat32(dataView, offset))\n    }\n\n    // https://stackoverflow.com/questions/5678432/decompressing-half-precision-floats-in-javascript\n    function decodeFloat16(binary) {\n      var exponent = (binary & 0x7c00) >> 10,\n        fraction = binary & 0x03ff\n\n      return (\n        (binary >> 15 ? -1 : 1) *\n        (exponent\n          ? exponent === 0x1f\n            ? fraction\n              ? NaN\n              : Infinity\n            : Math.pow(2, exponent - 15) * (1 + fraction / 0x400)\n          : 6.103515625e-5 * (fraction / 0x400))\n      )\n    }\n\n    function parseUint16(dataView, offset) {\n      var Uint16 = dataView.getUint16(offset.value, true)\n\n      offset.value += INT16_SIZE\n\n      return Uint16\n    }\n\n    function parseFloat16(buffer, offset) {\n      return decodeFloat16(parseUint16(buffer, offset))\n    }\n\n    function parseChlist(dataView, buffer, offset, size) {\n      var startOffset = offset.value\n      var channels = []\n\n      while (offset.value < startOffset + size - 1) {\n        var name = parseNullTerminatedString(buffer, offset)\n        var pixelType = parseInt32(dataView, offset)\n        var pLinear = parseUint8(dataView, offset)\n        offset.value += 3 // reserved, three chars\n        var xSampling = parseInt32(dataView, offset)\n        var ySampling = parseInt32(dataView, offset)\n\n        channels.push({\n          name: name,\n          pixelType: pixelType,\n          pLinear: pLinear,\n          xSampling: xSampling,\n          ySampling: ySampling,\n        })\n      }\n\n      offset.value += 1\n\n      return channels\n    }\n\n    function parseChromaticities(dataView, offset) {\n      var redX = parseFloat32(dataView, offset)\n      var redY = parseFloat32(dataView, offset)\n      var greenX = parseFloat32(dataView, offset)\n      var greenY = parseFloat32(dataView, offset)\n      var blueX = parseFloat32(dataView, offset)\n      var blueY = parseFloat32(dataView, offset)\n      var whiteX = parseFloat32(dataView, offset)\n      var whiteY = parseFloat32(dataView, offset)\n\n      return {\n        redX: redX,\n        redY: redY,\n        greenX: greenX,\n        greenY: greenY,\n        blueX: blueX,\n        blueY: blueY,\n        whiteX: whiteX,\n        whiteY: whiteY,\n      }\n    }\n\n    function parseCompression(dataView, offset) {\n      var compressionCodes = [\n        'NO_COMPRESSION',\n        'RLE_COMPRESSION',\n        'ZIPS_COMPRESSION',\n        'ZIP_COMPRESSION',\n        'PIZ_COMPRESSION',\n        'PXR24_COMPRESSION',\n        'B44_COMPRESSION',\n        'B44A_COMPRESSION',\n        'DWAA_COMPRESSION',\n        'DWAB_COMPRESSION',\n      ]\n\n      var compression = parseUint8(dataView, offset)\n\n      return compressionCodes[compression]\n    }\n\n    function parseBox2i(dataView, offset) {\n      var xMin = parseUint32(dataView, offset)\n      var yMin = parseUint32(dataView, offset)\n      var xMax = parseUint32(dataView, offset)\n      var yMax = parseUint32(dataView, offset)\n\n      return { xMin: xMin, yMin: yMin, xMax: xMax, yMax: yMax }\n    }\n\n    function parseLineOrder(dataView, offset) {\n      var lineOrders = ['INCREASING_Y']\n\n      var lineOrder = parseUint8(dataView, offset)\n\n      return lineOrders[lineOrder]\n    }\n\n    function parseV2f(dataView, offset) {\n      var x = parseFloat32(dataView, offset)\n      var y = parseFloat32(dataView, offset)\n\n      return [x, y]\n    }\n\n    function parseV3f(dataView, offset) {\n      var x = parseFloat32(dataView, offset)\n      var y = parseFloat32(dataView, offset)\n      var z = parseFloat32(dataView, offset)\n\n      return [x, y, z]\n    }\n\n    function parseValue(dataView, buffer, offset, type, size) {\n      if (type === 'string' || type === 'stringvector' || type === 'iccProfile') {\n        return parseFixedLengthString(buffer, offset, size)\n      } else if (type === 'chlist') {\n        return parseChlist(dataView, buffer, offset, size)\n      } else if (type === 'chromaticities') {\n        return parseChromaticities(dataView, offset)\n      } else if (type === 'compression') {\n        return parseCompression(dataView, offset)\n      } else if (type === 'box2i') {\n        return parseBox2i(dataView, offset)\n      } else if (type === 'lineOrder') {\n        return parseLineOrder(dataView, offset)\n      } else if (type === 'float') {\n        return parseFloat32(dataView, offset)\n      } else if (type === 'v2f') {\n        return parseV2f(dataView, offset)\n      } else if (type === 'v3f') {\n        return parseV3f(dataView, offset)\n      } else if (type === 'int') {\n        return parseInt32(dataView, offset)\n      } else if (type === 'rational') {\n        return parseRational(dataView, offset)\n      } else if (type === 'timecode') {\n        return parseTimecode(dataView, offset)\n      } else if (type === 'preview') {\n        offset.value += size\n        return 'skipped'\n      } else {\n        offset.value += size\n        return undefined\n      }\n    }\n\n    function parseHeader(dataView, buffer, offset) {\n      const EXRHeader = {}\n\n      if (dataView.getUint32(0, true) != 20000630) {\n        // magic\n        throw \"THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.\"\n      }\n\n      EXRHeader.version = dataView.getUint8(4)\n\n      const spec = dataView.getUint8(5) // fullMask\n\n      EXRHeader.spec = {\n        singleTile: !!(spec & 2),\n        longName: !!(spec & 4),\n        deepFormat: !!(spec & 8),\n        multiPart: !!(spec & 16),\n      }\n\n      // start of header\n\n      offset.value = 8 // start at 8 - after pre-amble\n\n      var keepReading = true\n\n      while (keepReading) {\n        var attributeName = parseNullTerminatedString(buffer, offset)\n\n        if (attributeName == 0) {\n          keepReading = false\n        } else {\n          var attributeType = parseNullTerminatedString(buffer, offset)\n          var attributeSize = parseUint32(dataView, offset)\n          var attributeValue = parseValue(dataView, buffer, offset, attributeType, attributeSize)\n\n          if (attributeValue === undefined) {\n            console.warn(`EXRLoader.parse: skipped unknown header attribute type \\'${attributeType}\\'.`)\n          } else {\n            EXRHeader[attributeName] = attributeValue\n          }\n        }\n      }\n\n      if ((spec & ~0x04) != 0) {\n        // unsupported tiled, deep-image, multi-part\n        console.error('EXRHeader:', EXRHeader)\n        throw 'THREE.EXRLoader: provided file is currently unsupported.'\n      }\n\n      return EXRHeader\n    }\n\n    function setupDecoder(EXRHeader, dataView, uInt8Array, offset, outputType) {\n      const EXRDecoder = {\n        size: 0,\n        viewer: dataView,\n        array: uInt8Array,\n        offset: offset,\n        width: EXRHeader.dataWindow.xMax - EXRHeader.dataWindow.xMin + 1,\n        height: EXRHeader.dataWindow.yMax - EXRHeader.dataWindow.yMin + 1,\n        channels: EXRHeader.channels.length,\n        bytesPerLine: null,\n        lines: null,\n        inputSize: null,\n        type: EXRHeader.channels[0].pixelType,\n        uncompress: null,\n        getter: null,\n        format: null,\n        [hasColorSpace ? 'colorSpace' : 'encoding']: null,\n      }\n\n      switch (EXRHeader.compression) {\n        case 'NO_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressRAW\n          break\n\n        case 'RLE_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressRLE\n          break\n\n        case 'ZIPS_COMPRESSION':\n          EXRDecoder.lines = 1\n          EXRDecoder.uncompress = uncompressZIP\n          break\n\n        case 'ZIP_COMPRESSION':\n          EXRDecoder.lines = 16\n          EXRDecoder.uncompress = uncompressZIP\n          break\n\n        case 'PIZ_COMPRESSION':\n          EXRDecoder.lines = 32\n          EXRDecoder.uncompress = uncompressPIZ\n          break\n\n        case 'PXR24_COMPRESSION':\n          EXRDecoder.lines = 16\n          EXRDecoder.uncompress = uncompressPXR\n          break\n\n        case 'DWAA_COMPRESSION':\n          EXRDecoder.lines = 32\n          EXRDecoder.uncompress = uncompressDWA\n          break\n\n        case 'DWAB_COMPRESSION':\n          EXRDecoder.lines = 256\n          EXRDecoder.uncompress = uncompressDWA\n          break\n\n        default:\n          throw 'EXRLoader.parse: ' + EXRHeader.compression + ' is unsupported'\n      }\n\n      EXRDecoder.scanlineBlockSize = EXRDecoder.lines\n\n      if (EXRDecoder.type == 1) {\n        // half\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.getter = parseFloat16\n            EXRDecoder.inputSize = INT16_SIZE\n            break\n\n          case HalfFloatType:\n            EXRDecoder.getter = parseUint16\n            EXRDecoder.inputSize = INT16_SIZE\n            break\n        }\n      } else if (EXRDecoder.type == 2) {\n        // float\n        switch (outputType) {\n          case FloatType:\n            EXRDecoder.getter = parseFloat32\n            EXRDecoder.inputSize = FLOAT32_SIZE\n            break\n\n          case HalfFloatType:\n            EXRDecoder.getter = decodeFloat32\n            EXRDecoder.inputSize = FLOAT32_SIZE\n        }\n      } else {\n        throw 'EXRLoader.parse: unsupported pixelType ' + EXRDecoder.type + ' for ' + EXRHeader.compression + '.'\n      }\n\n      EXRDecoder.blockCount = (EXRHeader.dataWindow.yMax + 1) / EXRDecoder.scanlineBlockSize\n\n      for (var i = 0; i < EXRDecoder.blockCount; i++) parseInt64(dataView, offset) // scanlineOffset\n\n      // we should be passed the scanline offset table, ready to start reading pixel data.\n\n      // RGB images will be converted to RGBA format, preventing software emulation in select devices.\n      EXRDecoder.outputChannels = EXRDecoder.channels == 3 ? 4 : EXRDecoder.channels\n      const size = EXRDecoder.width * EXRDecoder.height * EXRDecoder.outputChannels\n\n      switch (outputType) {\n        case FloatType:\n          EXRDecoder.byteArray = new Float32Array(size)\n\n          // Fill initially with 1s for the alpha value if the texture is not RGBA, RGB values will be overwritten\n          if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(1, 0, size)\n\n          break\n\n        case HalfFloatType:\n          EXRDecoder.byteArray = new Uint16Array(size)\n\n          if (EXRDecoder.channels < EXRDecoder.outputChannels) EXRDecoder.byteArray.fill(0x3c00, 0, size) // Uint16Array holds half float data, 0x3C00 is 1\n\n          break\n\n        default:\n          console.error('THREE.EXRLoader: unsupported type: ', outputType)\n          break\n      }\n\n      EXRDecoder.bytesPerLine = EXRDecoder.width * EXRDecoder.inputSize * EXRDecoder.channels\n\n      if (EXRDecoder.outputChannels == 4) EXRDecoder.format = RGBAFormat\n      else EXRDecoder.format = RedFormat\n\n      if (hasColorSpace) EXRDecoder.colorSpace = 'srgb-linear'\n      else EXRDecoder.encoding = 3000 // LinearEncoding\n\n      return EXRDecoder\n    }\n\n    // start parsing file [START]\n\n    const bufferDataView = new DataView(buffer)\n    const uInt8Array = new Uint8Array(buffer)\n    const offset = { value: 0 }\n\n    // get header information and validate format.\n    const EXRHeader = parseHeader(bufferDataView, buffer, offset)\n\n    // get input compression information and prepare decoding.\n    const EXRDecoder = setupDecoder(EXRHeader, bufferDataView, uInt8Array, offset, this.type)\n\n    const tmpOffset = { value: 0 }\n    const channelOffsets = { R: 0, G: 1, B: 2, A: 3, Y: 0 }\n\n    for (\n      let scanlineBlockIdx = 0;\n      scanlineBlockIdx < EXRDecoder.height / EXRDecoder.scanlineBlockSize;\n      scanlineBlockIdx++\n    ) {\n      const line = parseUint32(bufferDataView, offset) // line_no\n      EXRDecoder.size = parseUint32(bufferDataView, offset) // data_len\n      EXRDecoder.lines =\n        line + EXRDecoder.scanlineBlockSize > EXRDecoder.height\n          ? EXRDecoder.height - line\n          : EXRDecoder.scanlineBlockSize\n\n      const isCompressed = EXRDecoder.size < EXRDecoder.lines * EXRDecoder.bytesPerLine\n      const viewer = isCompressed ? EXRDecoder.uncompress(EXRDecoder) : uncompressRAW(EXRDecoder)\n\n      offset.value += EXRDecoder.size\n\n      for (let line_y = 0; line_y < EXRDecoder.scanlineBlockSize; line_y++) {\n        const true_y = line_y + scanlineBlockIdx * EXRDecoder.scanlineBlockSize\n        if (true_y >= EXRDecoder.height) break\n\n        for (let channelID = 0; channelID < EXRDecoder.channels; channelID++) {\n          const cOff = channelOffsets[EXRHeader.channels[channelID].name]\n\n          for (let x = 0; x < EXRDecoder.width; x++) {\n            tmpOffset.value =\n              (line_y * (EXRDecoder.channels * EXRDecoder.width) + channelID * EXRDecoder.width + x) *\n              EXRDecoder.inputSize\n            const outIndex =\n              (EXRDecoder.height - 1 - true_y) * (EXRDecoder.width * EXRDecoder.outputChannels) +\n              x * EXRDecoder.outputChannels +\n              cOff\n            EXRDecoder.byteArray[outIndex] = EXRDecoder.getter(viewer, tmpOffset)\n          }\n        }\n      }\n    }\n\n    return {\n      header: EXRHeader,\n      width: EXRDecoder.width,\n      height: EXRDecoder.height,\n      data: EXRDecoder.byteArray,\n      format: EXRDecoder.format,\n      [hasColorSpace ? 'colorSpace' : 'encoding']: EXRDecoder[hasColorSpace ? 'colorSpace' : 'encoding'],\n      type: this.type,\n    }\n  }\n\n  setDataType(value) {\n    this.type = value\n    return this\n  }\n\n  load(url, onLoad, onProgress, onError) {\n    function onLoadCallback(texture, texData) {\n      if (hasColorSpace) texture.colorSpace = texData.colorSpace\n      else texture.encoding = texData.encoding\n      texture.minFilter = LinearFilter\n      texture.magFilter = LinearFilter\n      texture.generateMipmaps = false\n      texture.flipY = false\n\n      if (onLoad) onLoad(texture, texData)\n    }\n\n    return super.load(url, onLoadCallback, onProgress, onError)\n  }\n}\n\nexport { EXRLoader }\n","/**\n * @monogrid/gainmap-js v3.0.5\n * With , by MONOGRID <rnd@monogrid.com>\n */\n\nimport { RGBAFormat, LinearFilter, ClampToEdgeWrapping, Scene, OrthographicCamera, HalfFloatType, FloatType, Mesh, PlaneGeometry, WebGLRenderTarget, UVMapping, WebGLRenderer, DataTexture, LinearSRGBColorSpace, ShaderMaterial, Texture, IntType, ShortType, ByteType, UnsignedIntType, UnsignedByteType, MeshBasicMaterial } from 'three';\n\nconst getBufferForType = (type, width, height) => {\n    let out;\n    switch (type) {\n        case UnsignedByteType:\n            out = new Uint8ClampedArray(width * height * 4);\n            break;\n        case HalfFloatType:\n            out = new Uint16Array(width * height * 4);\n            break;\n        case UnsignedIntType:\n            out = new Uint32Array(width * height * 4);\n            break;\n        case ByteType:\n            out = new Int8Array(width * height * 4);\n            break;\n        case ShortType:\n            out = new Int16Array(width * height * 4);\n            break;\n        case IntType:\n            out = new Int32Array(width * height * 4);\n            break;\n        case FloatType:\n            out = new Float32Array(width * height * 4);\n            break;\n        default:\n            throw new Error('Unsupported data type');\n    }\n    return out;\n};\nlet _canReadPixelsResult;\n/**\n * Test if this browser implementation can correctly read pixels from the specified\n * Render target type.\n *\n * Runs only once\n *\n * @param type\n * @param renderer\n * @param camera\n * @param renderTargetOptions\n * @returns\n */\nconst canReadPixels = (type, renderer, camera, renderTargetOptions) => {\n    if (_canReadPixelsResult !== undefined)\n        return _canReadPixelsResult;\n    const testRT = new WebGLRenderTarget(1, 1, renderTargetOptions);\n    renderer.setRenderTarget(testRT);\n    const mesh = new Mesh(new PlaneGeometry(), new MeshBasicMaterial({ color: 0xffffff }));\n    renderer.render(mesh, camera);\n    renderer.setRenderTarget(null);\n    const out = getBufferForType(type, testRT.width, testRT.height);\n    renderer.readRenderTargetPixels(testRT, 0, 0, testRT.width, testRT.height, out);\n    testRT.dispose();\n    mesh.geometry.dispose();\n    mesh.material.dispose();\n    _canReadPixelsResult = out[0] !== 0;\n    return _canReadPixelsResult;\n};\n/**\n * Utility class used for rendering a texture with a material\n *\n * @category Core\n * @group Core\n */\nclass QuadRenderer {\n    /**\n     * Constructs a new QuadRenderer\n     *\n     * @param options Parameters for this QuadRenderer\n     */\n    constructor(options) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r;\n        this._rendererIsDisposable = false;\n        this._supportsReadPixels = true;\n        /**\n         * Renders the input texture using the specified material\n         */\n        this.render = () => {\n            this._renderer.setRenderTarget(this._renderTarget);\n            try {\n                this._renderer.render(this._scene, this._camera);\n            }\n            catch (e) {\n                this._renderer.setRenderTarget(null);\n                throw e;\n            }\n            this._renderer.setRenderTarget(null);\n        };\n        this._width = options.width;\n        this._height = options.height;\n        this._type = options.type;\n        this._colorSpace = options.colorSpace;\n        const rtOptions = {\n            // fixed options\n            format: RGBAFormat,\n            depthBuffer: false,\n            stencilBuffer: false,\n            // user options\n            type: this._type, // set in class property\n            colorSpace: this._colorSpace, // set in class property\n            anisotropy: ((_a = options.renderTargetOptions) === null || _a === void 0 ? void 0 : _a.anisotropy) !== undefined ? (_b = options.renderTargetOptions) === null || _b === void 0 ? void 0 : _b.anisotropy : 1,\n            generateMipmaps: ((_c = options.renderTargetOptions) === null || _c === void 0 ? void 0 : _c.generateMipmaps) !== undefined ? (_d = options.renderTargetOptions) === null || _d === void 0 ? void 0 : _d.generateMipmaps : false,\n            magFilter: ((_e = options.renderTargetOptions) === null || _e === void 0 ? void 0 : _e.magFilter) !== undefined ? (_f = options.renderTargetOptions) === null || _f === void 0 ? void 0 : _f.magFilter : LinearFilter,\n            minFilter: ((_g = options.renderTargetOptions) === null || _g === void 0 ? void 0 : _g.minFilter) !== undefined ? (_h = options.renderTargetOptions) === null || _h === void 0 ? void 0 : _h.minFilter : LinearFilter,\n            samples: ((_j = options.renderTargetOptions) === null || _j === void 0 ? void 0 : _j.samples) !== undefined ? (_k = options.renderTargetOptions) === null || _k === void 0 ? void 0 : _k.samples : undefined,\n            wrapS: ((_l = options.renderTargetOptions) === null || _l === void 0 ? void 0 : _l.wrapS) !== undefined ? (_m = options.renderTargetOptions) === null || _m === void 0 ? void 0 : _m.wrapS : ClampToEdgeWrapping,\n            wrapT: ((_o = options.renderTargetOptions) === null || _o === void 0 ? void 0 : _o.wrapT) !== undefined ? (_p = options.renderTargetOptions) === null || _p === void 0 ? void 0 : _p.wrapT : ClampToEdgeWrapping\n        };\n        this._material = options.material;\n        if (options.renderer) {\n            this._renderer = options.renderer;\n        }\n        else {\n            this._renderer = QuadRenderer.instantiateRenderer();\n            this._rendererIsDisposable = true;\n        }\n        this._scene = new Scene();\n        this._camera = new OrthographicCamera();\n        this._camera.position.set(0, 0, 10);\n        this._camera.left = -0.5;\n        this._camera.right = 0.5;\n        this._camera.top = 0.5;\n        this._camera.bottom = -0.5;\n        this._camera.updateProjectionMatrix();\n        if (!canReadPixels(this._type, this._renderer, this._camera, rtOptions)) {\n            let alternativeType;\n            switch (this._type) {\n                case HalfFloatType:\n                    alternativeType = this._renderer.extensions.has('EXT_color_buffer_float') ? FloatType : undefined;\n                    break;\n            }\n            if (alternativeType !== undefined) {\n                console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${FloatType}`);\n                this._type = alternativeType;\n            }\n            else {\n                this._supportsReadPixels = false;\n                console.warn('This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown');\n            }\n        }\n        this._quad = new Mesh(new PlaneGeometry(), this._material);\n        this._quad.geometry.computeBoundingBox();\n        this._scene.add(this._quad);\n        this._renderTarget = new WebGLRenderTarget(this.width, this.height, rtOptions);\n        this._renderTarget.texture.mapping = ((_q = options.renderTargetOptions) === null || _q === void 0 ? void 0 : _q.mapping) !== undefined ? (_r = options.renderTargetOptions) === null || _r === void 0 ? void 0 : _r.mapping : UVMapping;\n    }\n    /**\n     * Instantiates a temporary renderer\n     *\n     * @returns\n     */\n    static instantiateRenderer() {\n        const renderer = new WebGLRenderer();\n        renderer.setSize(128, 128);\n        // renderer.outputColorSpace = SRGBColorSpace\n        // renderer.toneMapping = LinearToneMapping\n        // renderer.debug.checkShaderErrors = false\n        // this._rendererIsDisposable = true\n        return renderer;\n    }\n    /**\n     * Obtains a Buffer containing the rendered texture.\n     *\n     * @throws Error if the browser cannot read pixels from this RenderTarget type.\n     * @returns a TypedArray containing RGBA values from this renderer\n     */\n    toArray() {\n        if (!this._supportsReadPixels)\n            throw new Error('Can\\'t read pixels in this browser');\n        const out = getBufferForType(this._type, this._width, this._height);\n        this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, out);\n        return out;\n    }\n    /**\n     * Performs a readPixel operation in the renderTarget\n     * and returns a DataTexture containing the read data\n     *\n     * @params options\n     * @returns\n     */\n    toDataTexture(options) {\n        const returnValue = new DataTexture(\n        // fixed values\n        this.toArray(), this.width, this.height, RGBAFormat, this._type, \n        // user values\n        (options === null || options === void 0 ? void 0 : options.mapping) || UVMapping, (options === null || options === void 0 ? void 0 : options.wrapS) || ClampToEdgeWrapping, (options === null || options === void 0 ? void 0 : options.wrapT) || ClampToEdgeWrapping, (options === null || options === void 0 ? void 0 : options.magFilter) || LinearFilter, (options === null || options === void 0 ? void 0 : options.minFilter) || LinearFilter, (options === null || options === void 0 ? void 0 : options.anisotropy) || 1, \n        // fixed value\n        LinearSRGBColorSpace);\n        // set this afterwards, we can't set it in constructor\n        returnValue.generateMipmaps = (options === null || options === void 0 ? void 0 : options.generateMipmaps) !== undefined ? options === null || options === void 0 ? void 0 : options.generateMipmaps : false;\n        return returnValue;\n    }\n    /**\n     * If using a disposable renderer, it will dispose it.\n     */\n    disposeOnDemandRenderer() {\n        this._renderer.setRenderTarget(null);\n        if (this._rendererIsDisposable) {\n            this._renderer.dispose();\n            this._renderer.forceContextLoss();\n        }\n    }\n    /**\n     * Will dispose of **all** assets used by this renderer.\n     *\n     *\n     * @param disposeRenderTarget will dispose of the renderTarget which will not be usable later\n     * set this to true if you passed the `renderTarget.texture` to a `PMREMGenerator`\n     * or are otherwise done with it.\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const mesh = new Mesh(geometry, new MeshBasicMaterial({ map: result.renderTarget.texture }) )\n     * // DO NOT dispose the renderTarget here,\n     * // it is used directly in the material\n     * result.dispose()\n     * ```\n     *\n     * @example\n     * ```js\n     * const loader = new HDRJPGLoader(renderer)\n     * const pmremGenerator = new PMREMGenerator( renderer );\n     * const result = await loader.loadAsync('gainmap.jpeg')\n     * const envMap = pmremGenerator.fromEquirectangular(result.renderTarget.texture)\n     * const mesh = new Mesh(geometry, new MeshStandardMaterial({ envMap }) )\n     * // renderTarget can be disposed here\n     * // because it was used to generate a PMREM texture\n     * result.dispose(true)\n     * ```\n     */\n    dispose(disposeRenderTarget) {\n        this.disposeOnDemandRenderer();\n        if (disposeRenderTarget) {\n            this.renderTarget.dispose();\n        }\n        // dispose shader material texture uniforms\n        if (this.material instanceof ShaderMaterial) {\n            Object.values(this.material.uniforms).forEach(v => {\n                if (v.value instanceof Texture)\n                    v.value.dispose();\n            });\n        }\n        // dispose other material properties\n        Object.values(this.material).forEach(value => {\n            if (value instanceof Texture)\n                value.dispose();\n        });\n        this.material.dispose();\n        this._quad.geometry.dispose();\n    }\n    /**\n     * Width of the texture\n     */\n    get width() { return this._width; }\n    set width(value) {\n        this._width = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * Height of the texture\n     */\n    get height() { return this._height; }\n    set height(value) {\n        this._height = value;\n        this._renderTarget.setSize(this._width, this._height);\n    }\n    /**\n     * The renderer used\n     */\n    get renderer() { return this._renderer; }\n    /**\n     * The `WebGLRenderTarget` used.\n     */\n    get renderTarget() { return this._renderTarget; }\n    set renderTarget(value) {\n        this._renderTarget = value;\n        this._width = value.width;\n        this._height = value.height;\n        // this._type = value.texture.type\n    }\n    /**\n     * The `Material` used.\n     */\n    get material() { return this._material; }\n    /**\n     *\n     */\n    get type() { return this._type; }\n    get colorSpace() { return this._colorSpace; }\n}\n\nexport { QuadRenderer as Q };\n","/**\n * @monogrid/gainmap-js v3.0.5\n * With , by MONOGRID <rnd@monogrid.com>\n */\n\nimport { Q as QuadRenderer } from './QuadRenderer-6HrRQdJM.js';\nimport { ShaderMaterial, Vector3, NoBlending, SRGBColorSpace, LinearSRGBColorSpace, HalfFloatType, Loader, LoadingManager, Texture, UVMapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, FileLoader } from 'three';\n\nconst vertexShader = /* glsl */ `\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n}\n`;\nconst fragmentShader = /* glsl */ `\n// min half float value\n#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )\n// max half float value\n#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )\n\nuniform sampler2D sdr;\nuniform sampler2D gainMap;\nuniform vec3 gamma;\nuniform vec3 offsetHdr;\nuniform vec3 offsetSdr;\nuniform vec3 gainMapMin;\nuniform vec3 gainMapMax;\nuniform float weightFactor;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec3 rgb = texture2D( sdr, vUv ).rgb;\n  vec3 recovery = texture2D( gainMap, vUv ).rgb;\n  vec3 logRecovery = pow( recovery, gamma );\n  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;\n  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;\n  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));\n  gl_FragColor = vec4( clampedHdrColor , 1.0 );\n}\n`;\n/**\n * A Material which is able to decode the Gainmap into a full HDR Representation\n *\n * @category Materials\n * @group Materials\n */\nclass GainMapDecoderMaterial extends ShaderMaterial {\n    /**\n     *\n     * @param params\n     */\n    constructor({ gamma, offsetHdr, offsetSdr, gainMapMin, gainMapMax, maxDisplayBoost, hdrCapacityMin, hdrCapacityMax, sdr, gainMap }) {\n        super({\n            name: 'GainMapDecoderMaterial',\n            vertexShader,\n            fragmentShader,\n            uniforms: {\n                sdr: { value: sdr },\n                gainMap: { value: gainMap },\n                gamma: { value: new Vector3(1.0 / gamma[0], 1.0 / gamma[1], 1.0 / gamma[2]) },\n                offsetHdr: { value: new Vector3().fromArray(offsetHdr) },\n                offsetSdr: { value: new Vector3().fromArray(offsetSdr) },\n                gainMapMin: { value: new Vector3().fromArray(gainMapMin) },\n                gainMapMax: { value: new Vector3().fromArray(gainMapMax) },\n                weightFactor: {\n                    value: (Math.log2(maxDisplayBoost) - hdrCapacityMin) / (hdrCapacityMax - hdrCapacityMin)\n                }\n            },\n            blending: NoBlending,\n            depthTest: false,\n            depthWrite: false\n        });\n        this._maxDisplayBoost = maxDisplayBoost;\n        this._hdrCapacityMin = hdrCapacityMin;\n        this._hdrCapacityMax = hdrCapacityMax;\n        this.needsUpdate = true;\n        this.uniformsNeedUpdate = true;\n    }\n    get sdr() { return this.uniforms.sdr.value; }\n    set sdr(value) { this.uniforms.sdr.value = value; }\n    get gainMap() { return this.uniforms.gainMap.value; }\n    set gainMap(value) { this.uniforms.gainMap.value = value; }\n    /**\n     * @see {@link GainMapMetadata.offsetHdr}\n     */\n    get offsetHdr() { return this.uniforms.offsetHdr.value.toArray(); }\n    set offsetHdr(value) { this.uniforms.offsetHdr.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.offsetSdr}\n     */\n    get offsetSdr() { return this.uniforms.offsetSdr.value.toArray(); }\n    set offsetSdr(value) { this.uniforms.offsetSdr.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gainMapMin}\n     */\n    get gainMapMin() { return this.uniforms.gainMapMin.value.toArray(); }\n    set gainMapMin(value) { this.uniforms.gainMapMin.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gainMapMax}\n     */\n    get gainMapMax() { return this.uniforms.gainMapMax.value.toArray(); }\n    set gainMapMax(value) { this.uniforms.gainMapMax.value.fromArray(value); }\n    /**\n     * @see {@link GainMapMetadata.gamma}\n     */\n    get gamma() {\n        const g = this.uniforms.gamma.value;\n        return [1 / g.x, 1 / g.y, 1 / g.z];\n    }\n    set gamma(value) {\n        const g = this.uniforms.gamma.value;\n        g.x = 1.0 / value[0];\n        g.y = 1.0 / value[1];\n        g.z = 1.0 / value[2];\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */\n    get hdrCapacityMin() { return this._hdrCapacityMin; }\n    set hdrCapacityMin(value) {\n        this._hdrCapacityMin = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainMapMetadata.hdrCapacityMin}\n     * @remarks Logarithmic space\n     */\n    get hdrCapacityMax() { return this._hdrCapacityMax; }\n    set hdrCapacityMax(value) {\n        this._hdrCapacityMax = value;\n        this.calculateWeight();\n    }\n    /**\n     * @see {@link GainmapDecodingParameters.maxDisplayBoost}\n     * @remarks Non Logarithmic space\n     */\n    get maxDisplayBoost() { return this._maxDisplayBoost; }\n    set maxDisplayBoost(value) {\n        this._maxDisplayBoost = Math.max(1, Math.min(65504, value));\n        this.calculateWeight();\n    }\n    calculateWeight() {\n        const val = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);\n        this.uniforms.weightFactor.value = Math.max(0, Math.min(1, val));\n    }\n}\n\n/**\n * Decodes a gain map using a WebGLRenderTarget\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @example\n * import { decode } from '@monogrid/gainmap-js'\n * import {\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   TextureLoader,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const textureLoader = new TextureLoader()\n *\n * // load SDR Representation\n * const sdr = await textureLoader.loadAsync('sdr.jpg')\n * // load Gain map recovery image\n * const gainMap = await textureLoader.loadAsync('gainmap.jpg')\n * // load metadata\n * const metadata = await (await fetch('metadata.json')).json()\n *\n * const result = await decode({\n *   sdr,\n *   gainMap,\n *   // this allows to use `result.renderTarget.texture` directly\n *   renderer,\n *   // this will restore the full HDR range\n *   maxDisplayBoost: Math.pow(2, metadata.hdrCapacityMax),\n *   ...metadata\n * })\n *\n * const scene = new Scene()\n * // `result` can be used to populate a Texture\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n * @param params\n * @returns\n * @throws {Error} if the WebGLRenderer fails to render the gain map\n */\nconst decode = (params) => {\n    const { sdr, gainMap, renderer } = params;\n    if (sdr.colorSpace !== SRGBColorSpace) {\n        console.warn('SDR Colorspace needs to be *SRGBColorSpace*, setting it automatically');\n        sdr.colorSpace = SRGBColorSpace;\n    }\n    sdr.needsUpdate = true;\n    if (gainMap.colorSpace !== LinearSRGBColorSpace) {\n        console.warn('Gainmap Colorspace needs to be *LinearSRGBColorSpace*, setting it automatically');\n        gainMap.colorSpace = LinearSRGBColorSpace;\n    }\n    gainMap.needsUpdate = true;\n    const material = new GainMapDecoderMaterial({\n        ...params,\n        sdr,\n        gainMap\n    });\n    const quadRenderer = new QuadRenderer({\n        // TODO: three types are generic, eslint complains here, see how we can solve\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        width: sdr.image.width,\n        // TODO: three types are generic, eslint complains here, see how we can solve\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access\n        height: sdr.image.height,\n        type: HalfFloatType,\n        colorSpace: LinearSRGBColorSpace,\n        material,\n        renderer,\n        renderTargetOptions: params.renderTargetOptions\n    });\n    try {\n        quadRenderer.render();\n    }\n    catch (e) {\n        quadRenderer.disposeOnDemandRenderer();\n        throw e;\n    }\n    return quadRenderer;\n};\n\nclass GainMapNotFoundError extends Error {\n}\n\nclass XMPMetadataNotFoundError extends Error {\n}\n\nconst getAttribute = (description, name, defaultValue) => {\n    var _a;\n    let returnValue;\n    const parsedValue = (_a = description.attributes.getNamedItem(name)) === null || _a === void 0 ? void 0 : _a.nodeValue;\n    if (!parsedValue) {\n        const node = description.getElementsByTagName(name)[0];\n        if (node) {\n            const values = node.getElementsByTagName('rdf:li');\n            if (values.length === 3) {\n                returnValue = Array.from(values).map(v => v.innerHTML);\n            }\n            else {\n                throw new Error(`Gainmap metadata contains an array of items for ${name} but its length is not 3`);\n            }\n        }\n        else {\n            if (defaultValue)\n                return defaultValue;\n            else\n                throw new Error(`Can't find ${name} in gainmap metadata`);\n        }\n    }\n    else {\n        returnValue = parsedValue;\n    }\n    return returnValue;\n};\n/**\n *\n * @param input\n * @returns\n */\nconst extractXMP = (input) => {\n    var _a, _b;\n    let str;\n    // support node test environment\n    if (typeof TextDecoder !== 'undefined')\n        str = new TextDecoder().decode(input);\n    else\n        str = input.toString();\n    let start = str.indexOf('<x:xmpmeta');\n    const parser = new DOMParser();\n    while (start !== -1) {\n        const end = str.indexOf('x:xmpmeta>', start);\n        str.slice(start, end + 10);\n        const xmpBlock = str.slice(start, end + 10);\n        try {\n            const xmlDocument = parser.parseFromString(xmpBlock, 'text/xml');\n            const description = xmlDocument.getElementsByTagName('rdf:Description')[0];\n            const gainMapMin = getAttribute(description, 'hdrgm:GainMapMin', '0');\n            const gainMapMax = getAttribute(description, 'hdrgm:GainMapMax');\n            const gamma = getAttribute(description, 'hdrgm:Gamma', '1');\n            const offsetSDR = getAttribute(description, 'hdrgm:OffsetSDR', '0.015625');\n            const offsetHDR = getAttribute(description, 'hdrgm:OffsetHDR', '0.015625');\n            let hdrCapacityMin = (_a = description.attributes.getNamedItem('hdrgm:HDRCapacityMin')) === null || _a === void 0 ? void 0 : _a.nodeValue;\n            if (!hdrCapacityMin)\n                hdrCapacityMin = '0';\n            const hdrCapacityMax = (_b = description.attributes.getNamedItem('hdrgm:HDRCapacityMax')) === null || _b === void 0 ? void 0 : _b.nodeValue;\n            if (!hdrCapacityMax)\n                throw new Error('Incomplete gainmap metadata');\n            return {\n                gainMapMin: Array.isArray(gainMapMin) ? gainMapMin.map(v => parseFloat(v)) : [parseFloat(gainMapMin), parseFloat(gainMapMin), parseFloat(gainMapMin)],\n                gainMapMax: Array.isArray(gainMapMax) ? gainMapMax.map(v => parseFloat(v)) : [parseFloat(gainMapMax), parseFloat(gainMapMax), parseFloat(gainMapMax)],\n                gamma: Array.isArray(gamma) ? gamma.map(v => parseFloat(v)) : [parseFloat(gamma), parseFloat(gamma), parseFloat(gamma)],\n                offsetSdr: Array.isArray(offsetSDR) ? offsetSDR.map(v => parseFloat(v)) : [parseFloat(offsetSDR), parseFloat(offsetSDR), parseFloat(offsetSDR)],\n                offsetHdr: Array.isArray(offsetHDR) ? offsetHDR.map(v => parseFloat(v)) : [parseFloat(offsetHDR), parseFloat(offsetHDR), parseFloat(offsetHDR)],\n                hdrCapacityMin: parseFloat(hdrCapacityMin),\n                hdrCapacityMax: parseFloat(hdrCapacityMax)\n            };\n        }\n        catch (e) {\n        }\n        start = str.indexOf('<x:xmpmeta', end);\n    }\n};\n\n/**\n * MPF Extractor (Multi Picture Format Extractor)\n * By Henrik S Nilsson 2019\n *\n * Extracts images stored in images based on the MPF format (found here: https://www.cipa.jp/e/std/std-sec.html\n * under \"CIPA DC-007-Translation-2021 Multi-Picture Format\"\n *\n * Overly commented, and without intention of being complete or production ready.\n * Created to extract depth maps from iPhone images, and to learn about image metadata.\n * Kudos to: Phil Harvey (exiftool), Jaume Sanchez (android-lens-blur-depth-extractor)\n */\nclass MPFExtractor {\n    constructor(options) {\n        this.options = {\n            debug: options && options.debug !== undefined ? options.debug : false,\n            extractFII: options && options.extractFII !== undefined ? options.extractFII : true,\n            extractNonFII: options && options.extractNonFII !== undefined ? options.extractNonFII : true\n        };\n    }\n    extract(imageArrayBuffer) {\n        return new Promise((resolve, reject) => {\n            const debug = this.options.debug;\n            const dataView = new DataView(imageArrayBuffer.buffer);\n            // If you're executing this line on a big endian machine, it'll be reversed.\n            // bigEnd further down though, refers to the endianness of the image itself.\n            if (dataView.getUint16(0) !== 0xffd8) {\n                reject(new Error('Not a valid jpeg'));\n                return;\n            }\n            const length = dataView.byteLength;\n            let offset = 2;\n            let loops = 0;\n            let marker; // APP# marker\n            while (offset < length) {\n                if (++loops > 250) {\n                    reject(new Error(`Found no marker after ${loops} loops `));\n                    return;\n                }\n                if (dataView.getUint8(offset) !== 0xff) {\n                    reject(new Error(`Not a valid marker at offset 0x${offset.toString(16)}, found: 0x${dataView.getUint8(offset).toString(16)}`));\n                    return;\n                }\n                marker = dataView.getUint8(offset + 1);\n                if (debug)\n                    console.log(`Marker: ${marker.toString(16)}`);\n                if (marker === 0xe2) {\n                    if (debug)\n                        console.log('Found APP2 marker (0xffe2)');\n                    // Works for iPhone 8 Plus, X, and XSMax. Or any photos of MPF format.\n                    // Great way to visualize image information in html is using Exiftool. E.g.:\n                    // ./exiftool.exe -htmldump -wantTrailer photo.jpg > photo.html\n                    const formatPt = offset + 4;\n                    /*\n                     *  Structure of the MP Format Identifier\n                     *\n                     *  Offset Addr.  | Code (Hex)  | Description\n                     *  +00             ff            Marker Prefix      <-- offset\n                     *  +01             e2            APP2\n                     *  +02             #n            APP2 Field Length\n                     *  +03             #n            APP2 Field Length\n                     *  +04             4d            'M'                <-- formatPt\n                     *  +05             50            'P'\n                     *  +06             46            'F'\n                     *  +07             00            NULL\n                     *                                                   <-- tiffOffset\n                     */\n                    if (dataView.getUint32(formatPt) === 0x4d504600) {\n                        // Found MPF tag, so we start dig out sub images\n                        const tiffOffset = formatPt + 4;\n                        let bigEnd; // Endianness from TIFF header\n                        // Test for TIFF validity and endianness\n                        // 0x4949 and 0x4D4D ('II' and 'MM') marks Little Endian and Big Endian\n                        if (dataView.getUint16(tiffOffset) === 0x4949) {\n                            bigEnd = false;\n                        }\n                        else if (dataView.getUint16(tiffOffset) === 0x4d4d) {\n                            bigEnd = true;\n                        }\n                        else {\n                            reject(new Error('No valid endianness marker found in TIFF header'));\n                            return;\n                        }\n                        if (dataView.getUint16(tiffOffset + 2, !bigEnd) !== 0x002a) {\n                            reject(new Error('Not valid TIFF data! (no 0x002A marker)'));\n                            return;\n                        }\n                        // 32 bit number stating the offset from the start of the 8 Byte MP Header\n                        // to MP Index IFD Least possible value is thus 8 (means 0 offset)\n                        const firstIFDOffset = dataView.getUint32(tiffOffset + 4, !bigEnd);\n                        if (firstIFDOffset < 0x00000008) {\n                            reject(new Error('Not valid TIFF data! (First offset less than 8)'));\n                            return;\n                        }\n                        // Move ahead to MP Index IFD\n                        // Assume we're at the first IFD, so firstIFDOffset points to\n                        // MP Index IFD and not MP Attributes IFD. (If we try extract from a sub image,\n                        // we fail silently here due to this assumption)\n                        // Count (2 Byte) | MP Index Fields a.k.a. MP Entries (count * 12 Byte) | Offset of Next IFD (4 Byte)\n                        const dirStart = tiffOffset + firstIFDOffset; // Start of IFD (Image File Directory)\n                        const count = dataView.getUint16(dirStart, !bigEnd); // Count of MPEntries (2 Byte)\n                        // Extract info from MPEntries (starting after Count)\n                        const entriesStart = dirStart + 2;\n                        let numberOfImages = 0;\n                        for (let i = entriesStart; i < entriesStart + 12 * count; i += 12) {\n                            // Each entry is 12 Bytes long\n                            // Check MP Index IFD tags, here we only take tag 0xb001 = Number of images\n                            if (dataView.getUint16(i, !bigEnd) === 0xb001) {\n                                // stored in Last 4 bytes of its 12 Byte entry.\n                                numberOfImages = dataView.getUint32(i + 8, !bigEnd);\n                            }\n                        }\n                        const nextIFDOffsetLen = 4; // 4 Byte offset field that appears after MP Index IFD tags\n                        const MPImageListValPt = dirStart + 2 + count * 12 + nextIFDOffsetLen;\n                        const images = [];\n                        for (let i = MPImageListValPt; i < MPImageListValPt + numberOfImages * 16; i += 16) {\n                            const image = {\n                                MPType: dataView.getUint32(i, !bigEnd),\n                                size: dataView.getUint32(i + 4, !bigEnd),\n                                // This offset is specified relative to the address of the MP Endian\n                                // field in the MP Header, unless the image is a First Individual Image,\n                                // in which case the value of the offset shall be NULL (0x00000000).\n                                dataOffset: dataView.getUint32(i + 8, !bigEnd),\n                                dependantImages: dataView.getUint32(i + 12, !bigEnd),\n                                start: -1,\n                                end: -1,\n                                isFII: false\n                            };\n                            if (!image.dataOffset) {\n                                // dataOffset is 0x00000000 for First Individual Image\n                                image.start = 0;\n                                image.isFII = true;\n                            }\n                            else {\n                                image.start = tiffOffset + image.dataOffset;\n                                image.isFII = false;\n                            }\n                            image.end = image.start + image.size;\n                            images.push(image);\n                        }\n                        if (this.options.extractNonFII && images.length) {\n                            const bufferBlob = new Blob([dataView]);\n                            const imgs = [];\n                            for (const image of images) {\n                                if (image.isFII && !this.options.extractFII) {\n                                    continue; // Skip FII\n                                }\n                                const imageBlob = bufferBlob.slice(image.start, image.end + 1, 'image/jpeg');\n                                // we don't need this\n                                // const imageUrl = URL.createObjectURL(imageBlob)\n                                // image.img = document.createElement('img')\n                                // image.img.src = imageUrl\n                                imgs.push(imageBlob);\n                            }\n                            resolve(imgs);\n                        }\n                    }\n                }\n                offset += 2 + dataView.getUint16(offset + 2);\n            }\n        });\n    }\n}\n\n/**\n * Extracts XMP Metadata and the gain map recovery image\n * from a single JPEG file.\n *\n * @category Decoding Functions\n * @group Decoding Functions\n * @param jpegFile an `Uint8Array` containing and encoded JPEG file\n * @returns an sdr `Uint8Array` compressed in JPEG, a gainMap `Uint8Array` compressed in JPEG and the XMP parsed XMP metadata\n * @throws Error if XMP Metadata is not found\n * @throws Error if Gain map image is not found\n * @example\n * import { FileLoader } from 'three'\n * import { extractGainmapFromJPEG } from '@monogrid/gainmap-js'\n *\n * const jpegFile = await new FileLoader()\n *  .setResponseType('arraybuffer')\n *  .loadAsync('image.jpg')\n *\n * const { sdr, gainMap, metadata } = extractGainmapFromJPEG(jpegFile)\n */\nconst extractGainmapFromJPEG = async (jpegFile) => {\n    const metadata = extractXMP(jpegFile);\n    if (!metadata)\n        throw new XMPMetadataNotFoundError('Gain map XMP metadata not found');\n    const mpfExtractor = new MPFExtractor({ extractFII: true, extractNonFII: true });\n    const images = await mpfExtractor.extract(jpegFile);\n    if (images.length !== 2)\n        throw new GainMapNotFoundError('Gain map recovery image not found');\n    return {\n        sdr: new Uint8Array(await images[0].arrayBuffer()),\n        gainMap: new Uint8Array(await images[1].arrayBuffer()),\n        metadata\n    };\n};\n\n/**\n * private function, async get image from blob\n *\n * @param blob\n * @returns\n */\nconst getHTMLImageFromBlob = (blob) => {\n    return new Promise((resolve, reject) => {\n        const img = document.createElement('img');\n        img.onload = () => { resolve(img); };\n        img.onerror = (e) => { reject(e); };\n        img.src = URL.createObjectURL(blob);\n    });\n};\n\nclass LoaderBase extends Loader {\n    /**\n     *\n     * @param renderer\n     * @param manager\n     */\n    constructor(renderer, manager) {\n        super(manager);\n        if (renderer)\n            this._renderer = renderer;\n        this._internalLoadingManager = new LoadingManager();\n    }\n    /**\n     * Specify the renderer to use when rendering the gain map\n     *\n     * @param renderer\n     * @returns\n     */\n    setRenderer(renderer) {\n        this._renderer = renderer;\n        return this;\n    }\n    /**\n     * Specify the renderTarget options to use when rendering the gain map\n     *\n     * @param options\n     * @returns\n     */\n    setRenderTargetOptions(options) {\n        this._renderTargetOptions = options;\n        return this;\n    }\n    /**\n     * @private\n     * @returns\n     */\n    prepareQuadRenderer() {\n        if (!this._renderer)\n            console.warn('WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.');\n        // temporary values\n        const material = new GainMapDecoderMaterial({\n            gainMapMax: [1, 1, 1],\n            gainMapMin: [0, 0, 0],\n            gamma: [1, 1, 1],\n            offsetHdr: [1, 1, 1],\n            offsetSdr: [1, 1, 1],\n            hdrCapacityMax: 1,\n            hdrCapacityMin: 0,\n            maxDisplayBoost: 1,\n            gainMap: new Texture(),\n            sdr: new Texture()\n        });\n        return new QuadRenderer({\n            width: 16,\n            height: 16,\n            type: HalfFloatType,\n            colorSpace: LinearSRGBColorSpace,\n            material,\n            renderer: this._renderer,\n            renderTargetOptions: this._renderTargetOptions\n        });\n    }\n    /**\n   * @private\n   * @param quadRenderer\n   * @param metadata\n   * @param sdrBuffer\n   * @param gainMapBuffer\n   */\n    async render(quadRenderer, metadata, sdrBuffer, gainMapBuffer) {\n        // this is optional, will render a black gain-map if not present\n        const gainMapBlob = gainMapBuffer ? new Blob([gainMapBuffer], { type: 'image/jpeg' }) : undefined;\n        const sdrBlob = new Blob([sdrBuffer], { type: 'image/jpeg' });\n        let sdrImage;\n        let gainMapImage;\n        let needsFlip = false;\n        if (typeof createImageBitmap === 'undefined') {\n            const res = await Promise.all([\n                gainMapBlob ? getHTMLImageFromBlob(gainMapBlob) : Promise.resolve(undefined),\n                getHTMLImageFromBlob(sdrBlob)\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n            needsFlip = true;\n        }\n        else {\n            const res = await Promise.all([\n                gainMapBlob ? createImageBitmap(gainMapBlob, { imageOrientation: 'flipY' }) : Promise.resolve(undefined),\n                createImageBitmap(sdrBlob, { imageOrientation: 'flipY' })\n            ]);\n            gainMapImage = res[0];\n            sdrImage = res[1];\n        }\n        const gainMap = new Texture(gainMapImage || new ImageData(2, 2), UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, LinearSRGBColorSpace);\n        gainMap.flipY = needsFlip;\n        gainMap.needsUpdate = true;\n        const sdr = new Texture(sdrImage, UVMapping, ClampToEdgeWrapping, ClampToEdgeWrapping, LinearFilter, LinearMipMapLinearFilter, RGBAFormat, UnsignedByteType, 1, SRGBColorSpace);\n        sdr.flipY = needsFlip;\n        sdr.needsUpdate = true;\n        quadRenderer.width = sdrImage.width;\n        quadRenderer.height = sdrImage.height;\n        quadRenderer.material.gainMap = gainMap;\n        quadRenderer.material.sdr = sdr;\n        quadRenderer.material.gainMapMin = metadata.gainMapMin;\n        quadRenderer.material.gainMapMax = metadata.gainMapMax;\n        quadRenderer.material.offsetHdr = metadata.offsetHdr;\n        quadRenderer.material.offsetSdr = metadata.offsetSdr;\n        quadRenderer.material.gamma = metadata.gamma;\n        quadRenderer.material.hdrCapacityMin = metadata.hdrCapacityMin;\n        quadRenderer.material.hdrCapacityMax = metadata.hdrCapacityMax;\n        quadRenderer.material.maxDisplayBoost = Math.pow(2, metadata.hdrCapacityMax);\n        quadRenderer.material.needsUpdate = true;\n        quadRenderer.render();\n    }\n}\n\n/**\n * A Three.js Loader for the gain map format.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { GainMapLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   LinearFilter,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new GainMapLoader(renderer)\n *\n * const result = await loader.loadAsync(['sdr.jpeg', 'gainmap.jpeg', 'metadata.json'])\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n * scene.background.mapping = EquirectangularReflectionMapping\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass GainMapLoader extends LoaderBase {\n    /**\n     * Loads a gainmap using separate data\n     * * sdr image\n     * * gain map image\n     * * metadata json\n     *\n     * useful for webp gain maps\n     *\n     * @param urls An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a {@link ProgressEvent}\n     * @param onError Error callback\n     * @returns\n     */\n    load([sdrUrl, gainMapUrl, metadataUrl], onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        let sdr;\n        let gainMap;\n        let metadata;\n        const loadCheck = async () => {\n            if (sdr && gainMap && metadata) {\n                // solves #16\n                try {\n                    await this.render(quadRenderer, metadata, sdr, gainMap);\n                }\n                catch (error) {\n                    this.manager.itemError(sdrUrl);\n                    this.manager.itemError(gainMapUrl);\n                    this.manager.itemError(metadataUrl);\n                    if (typeof onError === 'function')\n                        onError(error);\n                    quadRenderer.disposeOnDemandRenderer();\n                    return;\n                }\n                if (typeof onLoad === 'function')\n                    onLoad(quadRenderer);\n                this.manager.itemEnd(sdrUrl);\n                this.manager.itemEnd(gainMapUrl);\n                this.manager.itemEnd(metadataUrl);\n                quadRenderer.disposeOnDemandRenderer();\n            }\n        };\n        let sdrLengthComputable = true;\n        let sdrTotal = 0;\n        let sdrLoaded = 0;\n        let gainMapLengthComputable = true;\n        let gainMapTotal = 0;\n        let gainMapLoaded = 0;\n        let metadataLengthComputable = true;\n        let metadataTotal = 0;\n        let metadataLoaded = 0;\n        const progressHandler = () => {\n            if (typeof onProgress === 'function') {\n                const total = sdrTotal + gainMapTotal + metadataTotal;\n                const loaded = sdrLoaded + gainMapLoaded + metadataLoaded;\n                const lengthComputable = sdrLengthComputable && gainMapLengthComputable && metadataLengthComputable;\n                onProgress(new ProgressEvent('progress', { lengthComputable, loaded, total }));\n            }\n        };\n        this.manager.itemStart(sdrUrl);\n        this.manager.itemStart(gainMapUrl);\n        this.manager.itemStart(metadataUrl);\n        const sdrLoader = new FileLoader(this._internalLoadingManager);\n        sdrLoader.setResponseType('arraybuffer');\n        sdrLoader.setRequestHeader(this.requestHeader);\n        sdrLoader.setPath(this.path);\n        sdrLoader.setWithCredentials(this.withCredentials);\n        sdrLoader.load(sdrUrl, async (buffer) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof buffer === 'string')\n                throw new Error('Invalid sdr buffer');\n            sdr = buffer;\n            await loadCheck();\n        }, (e) => {\n            sdrLengthComputable = e.lengthComputable;\n            sdrLoaded = e.loaded;\n            sdrTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(sdrUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        const gainMapLoader = new FileLoader(this._internalLoadingManager);\n        gainMapLoader.setResponseType('arraybuffer');\n        gainMapLoader.setRequestHeader(this.requestHeader);\n        gainMapLoader.setPath(this.path);\n        gainMapLoader.setWithCredentials(this.withCredentials);\n        gainMapLoader.load(gainMapUrl, async (buffer) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof buffer === 'string')\n                throw new Error('Invalid gainmap buffer');\n            gainMap = buffer;\n            await loadCheck();\n        }, (e) => {\n            gainMapLengthComputable = e.lengthComputable;\n            gainMapLoaded = e.loaded;\n            gainMapTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(gainMapUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        const metadataLoader = new FileLoader(this._internalLoadingManager);\n        // metadataLoader.setResponseType('json')\n        metadataLoader.setRequestHeader(this.requestHeader);\n        metadataLoader.setPath(this.path);\n        metadataLoader.setWithCredentials(this.withCredentials);\n        metadataLoader.load(metadataUrl, async (json) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof json !== 'string')\n                throw new Error('Invalid metadata string');\n            // TODO: implement check on JSON file and remove this eslint disable\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            metadata = JSON.parse(json);\n            await loadCheck();\n        }, (e) => {\n            metadataLengthComputable = e.lengthComputable;\n            metadataLoaded = e.loaded;\n            metadataTotal = e.total;\n            progressHandler();\n        }, (error) => {\n            this.manager.itemError(metadataUrl);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        return quadRenderer;\n    }\n}\n\n/**\n * A Three.js Loader for a JPEG with embedded gainmap metadata.\n *\n * @category Loaders\n * @group Loaders\n *\n * @example\n * import { HDRJPGLoader } from '@monogrid/gainmap-js'\n * import {\n *   EquirectangularReflectionMapping,\n *   LinearFilter,\n *   Mesh,\n *   MeshBasicMaterial,\n *   PerspectiveCamera,\n *   PlaneGeometry,\n *   Scene,\n *   WebGLRenderer\n * } from 'three'\n *\n * const renderer = new WebGLRenderer()\n *\n * const loader = new HDRJPGLoader(renderer)\n *\n * const result = await loader.loadAsync('gainmap.jpeg')\n * // `result` can be used to populate a Texture\n *\n * const scene = new Scene()\n * const mesh = new Mesh(\n *   new PlaneGeometry(),\n *   new MeshBasicMaterial({ map: result.renderTarget.texture })\n * )\n * scene.add(mesh)\n * renderer.render(scene, new PerspectiveCamera())\n *\n * // Starting from three.js r159\n * // `result.renderTarget.texture` can\n * // also be used as Equirectangular scene background\n * //\n * // it was previously needed to convert it\n * // to a DataTexture with `result.toDataTexture()`\n * scene.background = result.renderTarget.texture\n * scene.background.mapping = EquirectangularReflectionMapping\n *\n * // result must be manually disposed\n * // when you are done using it\n * result.dispose()\n *\n */\nclass HDRJPGLoader extends LoaderBase {\n    /**\n     * Loads a JPEG containing gain map metadata\n     * Renders a normal SDR image if gainmap data is not found\n     *\n     * @param url An array in the form of [sdr.jpg, gainmap.jpg, metadata.json]\n     * @param onLoad Load complete callback, will receive the result\n     * @param onProgress Progress callback, will receive a {@link ProgressEvent}\n     * @param onError Error callback\n     * @returns\n     */\n    load(url, onLoad, onProgress, onError) {\n        const quadRenderer = this.prepareQuadRenderer();\n        const loader = new FileLoader(this._internalLoadingManager);\n        loader.setResponseType('arraybuffer');\n        loader.setRequestHeader(this.requestHeader);\n        loader.setPath(this.path);\n        loader.setWithCredentials(this.withCredentials);\n        this.manager.itemStart(url);\n        loader.load(url, async (jpeg) => {\n            /* istanbul ignore if\n             this condition exists only because of three.js types + strict mode\n            */\n            if (typeof jpeg === 'string')\n                throw new Error('Invalid buffer, received [string], was expecting [ArrayBuffer]');\n            const jpegBuffer = new Uint8Array(jpeg);\n            let sdrJPEG;\n            let gainMapJPEG;\n            let metadata;\n            try {\n                const extractionResult = await extractGainmapFromJPEG(jpegBuffer);\n                // gain map is successfully reconstructed\n                sdrJPEG = extractionResult.sdr;\n                gainMapJPEG = extractionResult.gainMap;\n                metadata = extractionResult.metadata;\n            }\n            catch (e) {\n                // render the SDR version if this is not a gainmap\n                if (e instanceof XMPMetadataNotFoundError || e instanceof GainMapNotFoundError) {\n                    console.warn(`Failure to reconstruct an HDR image from ${url}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`);\n                    metadata = {\n                        gainMapMin: [0, 0, 0],\n                        gainMapMax: [1, 1, 1],\n                        gamma: [1, 1, 1],\n                        hdrCapacityMin: 0,\n                        hdrCapacityMax: 1,\n                        offsetHdr: [0, 0, 0],\n                        offsetSdr: [0, 0, 0]\n                    };\n                    sdrJPEG = jpegBuffer;\n                }\n                else {\n                    throw e;\n                }\n            }\n            // solves #16\n            try {\n                await this.render(quadRenderer, metadata, sdrJPEG, gainMapJPEG);\n            }\n            catch (error) {\n                this.manager.itemError(url);\n                if (typeof onError === 'function')\n                    onError(error);\n                quadRenderer.disposeOnDemandRenderer();\n                return;\n            }\n            if (typeof onLoad === 'function')\n                onLoad(quadRenderer);\n            this.manager.itemEnd(url);\n            quadRenderer.disposeOnDemandRenderer();\n        }, onProgress, (error) => {\n            this.manager.itemError(url);\n            if (typeof onError === 'function')\n                onError(error);\n        });\n        return quadRenderer;\n    }\n}\n\nexport { GainMapDecoderMaterial, GainMapLoader, HDRJPGLoader, HDRJPGLoader as JPEGRLoader, MPFExtractor, QuadRenderer, decode, extractGainmapFromJPEG, extractXMP };\n","const presetsObj = {\n  apartment: 'lebombo_1k.hdr',\n  city: 'potsdamer_platz_1k.hdr',\n  dawn: 'kiara_1_dawn_1k.hdr',\n  forest: 'forest_slope_1k.hdr',\n  lobby: 'st_fagans_interior_1k.hdr',\n  night: 'dikhololo_night_1k.hdr',\n  park: 'rooitou_park_1k.hdr',\n  studio: 'studio_small_03_1k.hdr',\n  sunset: 'venice_sunset_1k.hdr',\n  warehouse: 'empty_warehouse_01_1k.hdr'\n};\n\nexport { presetsObj };\n","/**\n * Sets `BufferAttribute.updateRange` since r159.\n */\nconst setUpdateRange = (attribute, updateRange) => {\n  if ('updateRanges' in attribute) {\n    // r159\n    // @ts-ignore\n    attribute.updateRanges[0] = updateRange;\n  } else {\n    attribute.updateRange = updateRange;\n  }\n};\nconst LinearEncoding = 3000;\nconst sRGBEncoding = 3001;\n\n/**\n * TextureEncoding was deprecated in r152, and removed in r162.\n */\n\nexport { LinearEncoding, sRGBEncoding, setUpdateRange };\n","import { useThree, useLoader } from '@react-three/fiber';\nimport { CubeReflectionMapping, EquirectangularReflectionMapping, CubeTextureLoader } from 'three';\nimport { RGBELoader, EXRLoader } from 'three-stdlib';\nimport { HDRJPGLoader, GainMapLoader } from '@monogrid/gainmap-js';\nimport { presetsObj } from '../helpers/environment-assets.js';\nimport { sRGBEncoding, LinearEncoding } from '../helpers/deprecated.js';\n\nconst CUBEMAP_ROOT = 'https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/';\nconst isArray = arr => Array.isArray(arr);\nfunction useEnvironment({\n  files = ['/px.png', '/nx.png', '/py.png', '/ny.png', '/pz.png', '/nz.png'],\n  path = '',\n  preset = undefined,\n  encoding = undefined,\n  extensions\n} = {}) {\n  var _firstEntry$split$pop;\n  let loader = null;\n  let multiFile = false;\n  let extension;\n  if (preset) {\n    if (!(preset in presetsObj)) throw new Error('Preset must be one of: ' + Object.keys(presetsObj).join(', '));\n    files = presetsObj[preset];\n    path = CUBEMAP_ROOT;\n  }\n  const isCubemap = isArray(files) && files.length === 6;\n  const isGainmap = isArray(files) && files.length === 3 && files.some(file => file.endsWith('json'));\n  const firstEntry = isArray(files) ? files[0] : files;\n\n  // Everything else\n  multiFile = isArray(files);\n  extension = isCubemap ? 'cube' : isGainmap ? 'webp' : firstEntry.startsWith('data:application/exr') ? 'exr' : firstEntry.startsWith('data:application/hdr') ? 'hdr' : firstEntry.startsWith('data:image/jpeg') ? 'jpg' : (_firstEntry$split$pop = firstEntry.split('.').pop()) == null || (_firstEntry$split$pop = _firstEntry$split$pop.split('?')) == null || (_firstEntry$split$pop = _firstEntry$split$pop.shift()) == null ? void 0 : _firstEntry$split$pop.toLowerCase();\n  loader = extension === 'cube' ? CubeTextureLoader : extension === 'hdr' ? RGBELoader : extension === 'exr' ? EXRLoader : extension === 'jpg' || extension === 'jpeg' ? HDRJPGLoader : extension === 'webp' ? GainMapLoader : null;\n  if (!loader) throw new Error('useEnvironment: Unrecognized file extension: ' + files);\n  const gl = useThree(state => state.gl);\n  const loaderResult = useLoader(\n  // @ts-expect-error\n  loader, multiFile ? [files] : files, loader => {\n    // Gainmap requires a renderer\n    if (extension === 'webp' || extension === 'jpg' || extension === 'jpeg') {\n      loader.setRenderer(gl);\n    }\n    loader.setPath == null || loader.setPath(path);\n    if (extensions) extensions(loader);\n  });\n  let texture = multiFile ?\n  // @ts-ignore\n  loaderResult[0] : loaderResult;\n  if (extension === 'jpg' || extension === 'jpeg' || extension === 'webp') {\n    var _renderTarget;\n    texture = (_renderTarget = texture.renderTarget) == null ? void 0 : _renderTarget.texture;\n  }\n  texture.mapping = isCubemap ? CubeReflectionMapping : EquirectangularReflectionMapping;\n  if ('colorSpace' in texture) texture.colorSpace = (encoding !== null && encoding !== void 0 ? encoding : isCubemap) ? 'srgb' : 'srgb-linear';else texture.encoding = (encoding !== null && encoding !== void 0 ? encoding : isCubemap) ? sRGBEncoding : LinearEncoding;\n  return texture;\n}\n\nexport { useEnvironment };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { useThree, useFrame, createPortal, applyProps, extend } from '@react-three/fiber';\nimport { Scene, WebGLCubeRenderTarget, HalfFloatType } from 'three';\nimport { GroundProjectedEnv } from 'three-stdlib';\nimport { useEnvironment } from './useEnvironment.js';\n\nconst isRef = obj => obj.current && obj.current.isScene;\nconst resolveScene = scene => isRef(scene) ? scene.current : scene;\nfunction setEnvProps(background, scene, defaultScene, texture, sceneProps = {}) {\n  var _sceneProps$blur, _target$backgroundRot, _target$backgroundRot2, _target$environmentRo, _target$environmentRo2;\n  // defaults\n  sceneProps = {\n    backgroundBlurriness: (_sceneProps$blur = sceneProps.blur) !== null && _sceneProps$blur !== void 0 ? _sceneProps$blur : 0,\n    backgroundIntensity: 1,\n    backgroundRotation: [0, 0, 0],\n    environmentIntensity: 1,\n    environmentRotation: [0, 0, 0],\n    ...sceneProps\n  };\n  const target = resolveScene(scene || defaultScene);\n  const oldbg = target.background;\n  const oldenv = target.environment;\n  const oldSceneProps = {\n    // @ts-ignore\n    backgroundBlurriness: target.backgroundBlurriness,\n    // @ts-ignore\n    backgroundIntensity: target.backgroundIntensity,\n    // @ts-ignore\n    backgroundRotation: (_target$backgroundRot = (_target$backgroundRot2 = target.backgroundRotation) == null || _target$backgroundRot2.clone == null ? void 0 : _target$backgroundRot2.clone()) !== null && _target$backgroundRot !== void 0 ? _target$backgroundRot : [0, 0, 0],\n    // @ts-ignore\n    environmentIntensity: target.environmentIntensity,\n    // @ts-ignore\n    environmentRotation: (_target$environmentRo = (_target$environmentRo2 = target.environmentRotation) == null || _target$environmentRo2.clone == null ? void 0 : _target$environmentRo2.clone()) !== null && _target$environmentRo !== void 0 ? _target$environmentRo : [0, 0, 0]\n  };\n  if (background !== 'only') target.environment = texture;\n  if (background) target.background = texture;\n  applyProps(target, sceneProps);\n  return () => {\n    if (background !== 'only') target.environment = oldenv;\n    if (background) target.background = oldbg;\n    applyProps(target, oldSceneProps);\n  };\n}\nfunction EnvironmentMap({\n  scene,\n  background = false,\n  map,\n  ...config\n}) {\n  const defaultScene = useThree(state => state.scene);\n  React.useLayoutEffect(() => {\n    if (map) return setEnvProps(background, scene, defaultScene, map, config);\n  });\n  return null;\n}\nfunction EnvironmentCube({\n  background = false,\n  scene,\n  blur,\n  backgroundBlurriness,\n  backgroundIntensity,\n  backgroundRotation,\n  environmentIntensity,\n  environmentRotation,\n  ...rest\n}) {\n  const texture = useEnvironment(rest);\n  const defaultScene = useThree(state => state.scene);\n  React.useLayoutEffect(() => {\n    return setEnvProps(background, scene, defaultScene, texture, {\n      blur,\n      backgroundBlurriness,\n      backgroundIntensity,\n      backgroundRotation,\n      environmentIntensity,\n      environmentRotation\n    });\n  });\n  return null;\n}\nfunction EnvironmentPortal({\n  children,\n  near = 1,\n  far = 1000,\n  resolution = 256,\n  frames = 1,\n  map,\n  background = false,\n  blur,\n  backgroundBlurriness,\n  backgroundIntensity,\n  backgroundRotation,\n  environmentIntensity,\n  environmentRotation,\n  scene,\n  files,\n  path,\n  preset = undefined,\n  extensions\n}) {\n  const gl = useThree(state => state.gl);\n  const defaultScene = useThree(state => state.scene);\n  const camera = React.useRef(null);\n  const [virtualScene] = React.useState(() => new Scene());\n  const fbo = React.useMemo(() => {\n    const fbo = new WebGLCubeRenderTarget(resolution);\n    fbo.texture.type = HalfFloatType;\n    return fbo;\n  }, [resolution]);\n  React.useLayoutEffect(() => {\n    if (frames === 1) camera.current.update(gl, virtualScene);\n    return setEnvProps(background, scene, defaultScene, fbo.texture, {\n      blur,\n      backgroundBlurriness,\n      backgroundIntensity,\n      backgroundRotation,\n      environmentIntensity,\n      environmentRotation\n    });\n  }, [children, virtualScene, fbo.texture, scene, defaultScene, background, frames, gl]);\n  let count = 1;\n  useFrame(() => {\n    if (frames === Infinity || count < frames) {\n      camera.current.update(gl, virtualScene);\n      count++;\n    }\n  });\n  return /*#__PURE__*/React.createElement(React.Fragment, null, createPortal( /*#__PURE__*/React.createElement(React.Fragment, null, children, /*#__PURE__*/React.createElement(\"cubeCamera\", {\n    ref: camera,\n    args: [near, far, fbo]\n  }), files || preset ? /*#__PURE__*/React.createElement(EnvironmentCube, {\n    background: true,\n    files: files,\n    preset: preset,\n    path: path,\n    extensions: extensions\n  }) : map ? /*#__PURE__*/React.createElement(EnvironmentMap, {\n    background: true,\n    map: map,\n    extensions: extensions\n  }) : null), virtualScene));\n}\nfunction EnvironmentGround(props) {\n  var _props$ground, _props$ground2, _scale, _props$ground3;\n  const textureDefault = useEnvironment(props);\n  const texture = props.map || textureDefault;\n  React.useMemo(() => extend({\n    GroundProjectedEnvImpl: GroundProjectedEnv\n  }), []);\n  const args = React.useMemo(() => [texture], [texture]);\n  const height = (_props$ground = props.ground) == null ? void 0 : _props$ground.height;\n  const radius = (_props$ground2 = props.ground) == null ? void 0 : _props$ground2.radius;\n  const scale = (_scale = (_props$ground3 = props.ground) == null ? void 0 : _props$ground3.scale) !== null && _scale !== void 0 ? _scale : 1000;\n  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(EnvironmentMap, _extends({}, props, {\n    map: texture\n  })), /*#__PURE__*/React.createElement(\"groundProjectedEnvImpl\", {\n    args: args,\n    scale: scale,\n    height: height,\n    radius: radius\n  }));\n}\nfunction Environment(props) {\n  return props.ground ? /*#__PURE__*/React.createElement(EnvironmentGround, props) : props.map ? /*#__PURE__*/React.createElement(EnvironmentMap, props) : props.children ? /*#__PURE__*/React.createElement(EnvironmentPortal, props) : /*#__PURE__*/React.createElement(EnvironmentCube, props);\n}\n\nexport { Environment, EnvironmentCube, EnvironmentMap, EnvironmentPortal };\n","import {\n  EventDispatcher,\n  Matrix4,\n  MOUSE,\n  OrthographicCamera,\n  PerspectiveCamera,\n  Quaternion,\n  Spherical,\n  TOUCH,\n  Vector2,\n  Vector3,\n  Ray,\n  Plane,\n} from 'three'\n\nconst _ray = new Ray()\nconst _plane = new Plane()\nconst TILT_LIMIT = Math.cos(70 * (Math.PI / 180))\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n//\n//    Orbit - left mouse / touch: one-finger move\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - right mouse, or left mouse + ctrl/meta/shiftKey, or arrow keys / touch: two-finger move\n\nconst moduloWrapAround = (offset: number, capacity: number) => ((offset % capacity) + capacity) % capacity\n\nclass OrbitControls extends EventDispatcher {\n  object: PerspectiveCamera | OrthographicCamera\n  domElement: HTMLElement | undefined\n  // Set to false to disable this control\n  enabled = true\n  // \"target\" sets the location of focus, where the object orbits around\n  target = new Vector3()\n  // How far you can dolly in and out ( PerspectiveCamera only )\n  minDistance = 0\n  maxDistance = Infinity\n  // How far you can zoom in and out ( OrthographicCamera only )\n  minZoom = 0\n  maxZoom = Infinity\n  // How far you can orbit vertically, upper and lower limits.\n  // Range is 0 to Math.PI radians.\n  minPolarAngle = 0 // radians\n  maxPolarAngle = Math.PI // radians\n  // How far you can orbit horizontally, upper and lower limits.\n  // If set, the interval [ min, max ] must be a sub-interval of [ - 2 PI, 2 PI ], with ( max - min < 2 PI )\n  minAzimuthAngle = -Infinity // radians\n  maxAzimuthAngle = Infinity // radians\n  // Set to true to enable damping (inertia)\n  // If damping is enabled, you must call controls.update() in your animation loop\n  enableDamping = false\n  dampingFactor = 0.05\n  // This option actually enables dollying in and out; left as \"zoom\" for backwards compatibility.\n  // Set to false to disable zooming\n  enableZoom = true\n  zoomSpeed = 1.0\n  // Set to false to disable rotating\n  enableRotate = true\n  rotateSpeed = 1.0\n  // Set to false to disable panning\n  enablePan = true\n  panSpeed = 1.0\n  screenSpacePanning = true // if false, pan orthogonal to world-space direction camera.up\n  keyPanSpeed = 7.0 // pixels moved per arrow key push\n  zoomToCursor = false\n  // Set to true to automatically rotate around the target\n  // If auto-rotate is enabled, you must call controls.update() in your animation loop\n  autoRotate = false\n  autoRotateSpeed = 2.0 // 30 seconds per orbit when fps is 60\n  reverseOrbit = false // true if you want to reverse the orbit to mouse drag from left to right = orbits left\n  reverseHorizontalOrbit = false // true if you want to reverse the horizontal orbit direction\n  reverseVerticalOrbit = false // true if you want to reverse the vertical orbit direction\n  // The four arrow keys\n  keys = { LEFT: 'ArrowLeft', UP: 'ArrowUp', RIGHT: 'ArrowRight', BOTTOM: 'ArrowDown' }\n  // Mouse buttons\n  mouseButtons: Partial<{\n    LEFT: MOUSE\n    MIDDLE: MOUSE\n    RIGHT: MOUSE\n  }> = {\n    LEFT: MOUSE.ROTATE,\n    MIDDLE: MOUSE.DOLLY,\n    RIGHT: MOUSE.PAN,\n  }\n  // Touch fingers\n  touches: Partial<{\n    ONE: TOUCH\n    TWO: TOUCH\n  }> = { ONE: TOUCH.ROTATE, TWO: TOUCH.DOLLY_PAN }\n  target0: Vector3\n  position0: Vector3\n  zoom0: number\n  // the target DOM element for key events\n  _domElementKeyEvents: any = null\n\n  getPolarAngle: () => number\n  getAzimuthalAngle: () => number\n  setPolarAngle: (x: number) => void\n  setAzimuthalAngle: (x: number) => void\n  getDistance: () => number\n\n  listenToKeyEvents: (domElement: HTMLElement) => void\n  stopListenToKeyEvents: () => void\n  saveState: () => void\n  reset: () => void\n  update: () => void\n  connect: (domElement: HTMLElement) => void\n  dispose: () => void\n\n  constructor(object: PerspectiveCamera | OrthographicCamera, domElement?: HTMLElement) {\n    super()\n\n    this.object = object\n    this.domElement = domElement\n\n    // for reset\n    this.target0 = this.target.clone()\n    this.position0 = this.object.position.clone()\n    this.zoom0 = this.object.zoom\n\n    //\n    // public methods\n    //\n\n    this.getPolarAngle = (): number => spherical.phi\n\n    this.getAzimuthalAngle = (): number => spherical.theta\n\n    this.setPolarAngle = (value: number): void => {\n      // use modulo wrapping to safeguard value\n      let phi = moduloWrapAround(value, 2 * Math.PI)\n      let currentPhi = spherical.phi\n\n      // convert to the equivalent shortest angle\n      if (currentPhi < 0) currentPhi += 2 * Math.PI\n      if (phi < 0) phi += 2 * Math.PI\n      let phiDist = Math.abs(phi - currentPhi)\n      if (2 * Math.PI - phiDist < phiDist) {\n        if (phi < currentPhi) {\n          phi += 2 * Math.PI\n        } else {\n          currentPhi += 2 * Math.PI\n        }\n      }\n      sphericalDelta.phi = phi - currentPhi\n      scope.update()\n    }\n\n    this.setAzimuthalAngle = (value: number): void => {\n      // use modulo wrapping to safeguard value\n      let theta = moduloWrapAround(value, 2 * Math.PI)\n      let currentTheta = spherical.theta\n\n      // convert to the equivalent shortest angle\n      if (currentTheta < 0) currentTheta += 2 * Math.PI\n      if (theta < 0) theta += 2 * Math.PI\n      let thetaDist = Math.abs(theta - currentTheta)\n      if (2 * Math.PI - thetaDist < thetaDist) {\n        if (theta < currentTheta) {\n          theta += 2 * Math.PI\n        } else {\n          currentTheta += 2 * Math.PI\n        }\n      }\n      sphericalDelta.theta = theta - currentTheta\n      scope.update()\n    }\n\n    this.getDistance = (): number => scope.object.position.distanceTo(scope.target)\n\n    this.listenToKeyEvents = (domElement: HTMLElement): void => {\n      domElement.addEventListener('keydown', onKeyDown)\n      this._domElementKeyEvents = domElement\n    }\n\n    this.stopListenToKeyEvents = (): void => {\n      this._domElementKeyEvents.removeEventListener('keydown', onKeyDown)\n      this._domElementKeyEvents = null\n    }\n\n    this.saveState = (): void => {\n      scope.target0.copy(scope.target)\n      scope.position0.copy(scope.object.position)\n      scope.zoom0 = scope.object.zoom\n    }\n\n    this.reset = (): void => {\n      scope.target.copy(scope.target0)\n      scope.object.position.copy(scope.position0)\n      scope.object.zoom = scope.zoom0\n      scope.object.updateProjectionMatrix()\n\n      // @ts-ignore\n      scope.dispatchEvent(changeEvent)\n\n      scope.update()\n\n      state = STATE.NONE\n    }\n\n    // this method is exposed, but perhaps it would be better if we can make it private...\n    this.update = ((): (() => void) => {\n      const offset = new Vector3()\n      const up = new Vector3(0, 1, 0)\n\n      // so camera.up is the orbit axis\n      const quat = new Quaternion().setFromUnitVectors(object.up, up)\n      const quatInverse = quat.clone().invert()\n\n      const lastPosition = new Vector3()\n      const lastQuaternion = new Quaternion()\n\n      const twoPI = 2 * Math.PI\n\n      return function update(): boolean {\n        const position = scope.object.position\n\n        // update new up direction\n        quat.setFromUnitVectors(object.up, up)\n        quatInverse.copy(quat).invert()\n\n        offset.copy(position).sub(scope.target)\n\n        // rotate offset to \"y-axis-is-up\" space\n        offset.applyQuaternion(quat)\n\n        // angle from z-axis around y-axis\n        spherical.setFromVector3(offset)\n\n        if (scope.autoRotate && state === STATE.NONE) {\n          rotateLeft(getAutoRotationAngle())\n        }\n\n        if (scope.enableDamping) {\n          spherical.theta += sphericalDelta.theta * scope.dampingFactor\n          spherical.phi += sphericalDelta.phi * scope.dampingFactor\n        } else {\n          spherical.theta += sphericalDelta.theta\n          spherical.phi += sphericalDelta.phi\n        }\n\n        // restrict theta to be between desired limits\n\n        let min = scope.minAzimuthAngle\n        let max = scope.maxAzimuthAngle\n\n        if (isFinite(min) && isFinite(max)) {\n          if (min < -Math.PI) min += twoPI\n          else if (min > Math.PI) min -= twoPI\n\n          if (max < -Math.PI) max += twoPI\n          else if (max > Math.PI) max -= twoPI\n\n          if (min <= max) {\n            spherical.theta = Math.max(min, Math.min(max, spherical.theta))\n          } else {\n            spherical.theta =\n              spherical.theta > (min + max) / 2 ? Math.max(min, spherical.theta) : Math.min(max, spherical.theta)\n          }\n        }\n\n        // restrict phi to be between desired limits\n        spherical.phi = Math.max(scope.minPolarAngle, Math.min(scope.maxPolarAngle, spherical.phi))\n        spherical.makeSafe()\n\n        // move target to panned location\n\n        if (scope.enableDamping === true) {\n          scope.target.addScaledVector(panOffset, scope.dampingFactor)\n        } else {\n          scope.target.add(panOffset)\n        }\n\n        // adjust the camera position based on zoom only if we're not zooming to the cursor or if it's an ortho camera\n        // we adjust zoom later in these cases\n        if ((scope.zoomToCursor && performCursorZoom) || (scope.object as OrthographicCamera).isOrthographicCamera) {\n          spherical.radius = clampDistance(spherical.radius)\n        } else {\n          spherical.radius = clampDistance(spherical.radius * scale)\n        }\n\n        offset.setFromSpherical(spherical)\n\n        // rotate offset back to \"camera-up-vector-is-up\" space\n        offset.applyQuaternion(quatInverse)\n\n        position.copy(scope.target).add(offset)\n\n        if (!scope.object.matrixAutoUpdate) scope.object.updateMatrix()\n        scope.object.lookAt(scope.target)\n\n        if (scope.enableDamping === true) {\n          sphericalDelta.theta *= 1 - scope.dampingFactor\n          sphericalDelta.phi *= 1 - scope.dampingFactor\n\n          panOffset.multiplyScalar(1 - scope.dampingFactor)\n        } else {\n          sphericalDelta.set(0, 0, 0)\n\n          panOffset.set(0, 0, 0)\n        }\n\n        // adjust camera position\n        let zoomChanged = false\n        if (scope.zoomToCursor && performCursorZoom) {\n          let newRadius = null\n          if (scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) {\n            // move the camera down the pointer ray\n            // this method avoids floating point error\n            const prevRadius = offset.length()\n            newRadius = clampDistance(prevRadius * scale)\n\n            const radiusDelta = prevRadius - newRadius\n            scope.object.position.addScaledVector(dollyDirection, radiusDelta)\n            scope.object.updateMatrixWorld()\n          } else if ((scope.object as OrthographicCamera).isOrthographicCamera) {\n            // adjust the ortho camera position based on zoom changes\n            const mouseBefore = new Vector3(mouse.x, mouse.y, 0)\n            mouseBefore.unproject(scope.object)\n\n            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale))\n            scope.object.updateProjectionMatrix()\n            zoomChanged = true\n\n            const mouseAfter = new Vector3(mouse.x, mouse.y, 0)\n            mouseAfter.unproject(scope.object)\n\n            scope.object.position.sub(mouseAfter).add(mouseBefore)\n            scope.object.updateMatrixWorld()\n\n            newRadius = offset.length()\n          } else {\n            console.warn('WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled.')\n            scope.zoomToCursor = false\n          }\n\n          // handle the placement of the target\n          if (newRadius !== null) {\n            if (scope.screenSpacePanning) {\n              // position the orbit target in front of the new camera position\n              scope.target\n                .set(0, 0, -1)\n                .transformDirection(scope.object.matrix)\n                .multiplyScalar(newRadius)\n                .add(scope.object.position)\n            } else {\n              // get the ray and translation plane to compute target\n              _ray.origin.copy(scope.object.position)\n              _ray.direction.set(0, 0, -1).transformDirection(scope.object.matrix)\n\n              // if the camera is 20 degrees above the horizon then don't adjust the focus target to avoid\n              // extremely large values\n              if (Math.abs(scope.object.up.dot(_ray.direction)) < TILT_LIMIT) {\n                object.lookAt(scope.target)\n              } else {\n                _plane.setFromNormalAndCoplanarPoint(scope.object.up, scope.target)\n                _ray.intersectPlane(_plane, scope.target)\n              }\n            }\n          }\n        } else if (scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera) {\n          zoomChanged = scale !== 1\n\n          if (zoomChanged) {\n            scope.object.zoom = Math.max(scope.minZoom, Math.min(scope.maxZoom, scope.object.zoom / scale))\n            scope.object.updateProjectionMatrix()\n          }\n        }\n\n        scale = 1\n        performCursorZoom = false\n\n        // update condition is:\n        // min(camera displacement, camera rotation in radians)^2 > EPS\n        // using small-angle approximation cos(x/2) = 1 - x^2 / 8\n\n        if (\n          zoomChanged ||\n          lastPosition.distanceToSquared(scope.object.position) > EPS ||\n          8 * (1 - lastQuaternion.dot(scope.object.quaternion)) > EPS\n        ) {\n          // @ts-ignore\n          scope.dispatchEvent(changeEvent)\n\n          lastPosition.copy(scope.object.position)\n          lastQuaternion.copy(scope.object.quaternion)\n          zoomChanged = false\n\n          return true\n        }\n\n        return false\n      }\n    })()\n\n    // https://github.com/mrdoob/three.js/issues/20575\n    this.connect = (domElement: HTMLElement): void => {\n      if ((domElement as any) === document) {\n        console.error(\n          'THREE.OrbitControls: \"document\" should not be used as the target \"domElement\". Please use \"renderer.domElement\" instead.',\n        )\n      }\n      scope.domElement = domElement\n      // disables touch scroll\n      // touch-action needs to be defined for pointer events to work on mobile\n      // https://stackoverflow.com/a/48254578\n      scope.domElement.style.touchAction = 'none'\n      scope.domElement.addEventListener('contextmenu', onContextMenu)\n      scope.domElement.addEventListener('pointerdown', onPointerDown)\n      scope.domElement.addEventListener('pointercancel', onPointerUp)\n      scope.domElement.addEventListener('wheel', onMouseWheel)\n    }\n\n    this.dispose = (): void => {\n      // Enabling touch scroll\n      if (scope.domElement) {\n        scope.domElement.style.touchAction = 'auto'\n      }\n      scope.domElement?.removeEventListener('contextmenu', onContextMenu)\n      scope.domElement?.removeEventListener('pointerdown', onPointerDown)\n      scope.domElement?.removeEventListener('pointercancel', onPointerUp)\n      scope.domElement?.removeEventListener('wheel', onMouseWheel)\n      scope.domElement?.ownerDocument.removeEventListener('pointermove', onPointerMove)\n      scope.domElement?.ownerDocument.removeEventListener('pointerup', onPointerUp)\n      if (scope._domElementKeyEvents !== null) {\n        scope._domElementKeyEvents.removeEventListener('keydown', onKeyDown)\n      }\n      //scope.dispatchEvent( { type: 'dispose' } ); // should this be added here?\n    }\n\n    //\n    // internals\n    //\n\n    const scope = this\n\n    const changeEvent = { type: 'change' }\n    const startEvent = { type: 'start' }\n    const endEvent = { type: 'end' }\n\n    const STATE = {\n      NONE: -1,\n      ROTATE: 0,\n      DOLLY: 1,\n      PAN: 2,\n      TOUCH_ROTATE: 3,\n      TOUCH_PAN: 4,\n      TOUCH_DOLLY_PAN: 5,\n      TOUCH_DOLLY_ROTATE: 6,\n    }\n\n    let state = STATE.NONE\n\n    const EPS = 0.000001\n\n    // current position in spherical coordinates\n    const spherical = new Spherical()\n    const sphericalDelta = new Spherical()\n\n    let scale = 1\n    const panOffset = new Vector3()\n\n    const rotateStart = new Vector2()\n    const rotateEnd = new Vector2()\n    const rotateDelta = new Vector2()\n\n    const panStart = new Vector2()\n    const panEnd = new Vector2()\n    const panDelta = new Vector2()\n\n    const dollyStart = new Vector2()\n    const dollyEnd = new Vector2()\n    const dollyDelta = new Vector2()\n\n    const dollyDirection = new Vector3()\n    const mouse = new Vector2()\n    let performCursorZoom = false\n\n    const pointers: PointerEvent[] = []\n    const pointerPositions: { [key: string]: Vector2 } = {}\n\n    function getAutoRotationAngle(): number {\n      return ((2 * Math.PI) / 60 / 60) * scope.autoRotateSpeed\n    }\n\n    function getZoomScale(): number {\n      return Math.pow(0.95, scope.zoomSpeed)\n    }\n\n    function rotateLeft(angle: number): void {\n      if (scope.reverseOrbit || scope.reverseHorizontalOrbit) {\n        sphericalDelta.theta += angle\n      } else {\n        sphericalDelta.theta -= angle\n      }\n    }\n\n    function rotateUp(angle: number): void {\n      if (scope.reverseOrbit || scope.reverseVerticalOrbit) {\n        sphericalDelta.phi += angle\n      } else {\n        sphericalDelta.phi -= angle\n      }\n    }\n\n    const panLeft = (() => {\n      const v = new Vector3()\n\n      return function panLeft(distance: number, objectMatrix: Matrix4) {\n        v.setFromMatrixColumn(objectMatrix, 0) // get X column of objectMatrix\n        v.multiplyScalar(-distance)\n\n        panOffset.add(v)\n      }\n    })()\n\n    const panUp = (() => {\n      const v = new Vector3()\n\n      return function panUp(distance: number, objectMatrix: Matrix4) {\n        if (scope.screenSpacePanning === true) {\n          v.setFromMatrixColumn(objectMatrix, 1)\n        } else {\n          v.setFromMatrixColumn(objectMatrix, 0)\n          v.crossVectors(scope.object.up, v)\n        }\n\n        v.multiplyScalar(distance)\n\n        panOffset.add(v)\n      }\n    })()\n\n    // deltaX and deltaY are in pixels; right and down are positive\n    const pan = (() => {\n      const offset = new Vector3()\n\n      return function pan(deltaX: number, deltaY: number) {\n        const element = scope.domElement\n\n        if (element && scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) {\n          // perspective\n          const position = scope.object.position\n          offset.copy(position).sub(scope.target)\n          let targetDistance = offset.length()\n\n          // half of the fov is center to top of screen\n          targetDistance *= Math.tan(((scope.object.fov / 2) * Math.PI) / 180.0)\n\n          // we use only clientHeight here so aspect ratio does not distort speed\n          panLeft((2 * deltaX * targetDistance) / element.clientHeight, scope.object.matrix)\n          panUp((2 * deltaY * targetDistance) / element.clientHeight, scope.object.matrix)\n        } else if (element && scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera) {\n          // orthographic\n          panLeft(\n            (deltaX * (scope.object.right - scope.object.left)) / scope.object.zoom / element.clientWidth,\n            scope.object.matrix,\n          )\n          panUp(\n            (deltaY * (scope.object.top - scope.object.bottom)) / scope.object.zoom / element.clientHeight,\n            scope.object.matrix,\n          )\n        } else {\n          // camera neither orthographic nor perspective\n          console.warn('WARNING: OrbitControls.js encountered an unknown camera type - pan disabled.')\n          scope.enablePan = false\n        }\n      }\n    })()\n\n    function dollyOut(dollyScale: number) {\n      if (\n        (scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) ||\n        (scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera)\n      ) {\n        scale /= dollyScale\n      } else {\n        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.')\n        scope.enableZoom = false\n      }\n    }\n\n    function dollyIn(dollyScale: number) {\n      if (\n        (scope.object instanceof PerspectiveCamera && scope.object.isPerspectiveCamera) ||\n        (scope.object instanceof OrthographicCamera && scope.object.isOrthographicCamera)\n      ) {\n        scale *= dollyScale\n      } else {\n        console.warn('WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled.')\n        scope.enableZoom = false\n      }\n    }\n\n    function updateMouseParameters(event: MouseEvent): void {\n      if (!scope.zoomToCursor || !scope.domElement) {\n        return\n      }\n\n      performCursorZoom = true\n\n      const rect = scope.domElement.getBoundingClientRect()\n      const x = event.clientX - rect.left\n      const y = event.clientY - rect.top\n      const w = rect.width\n      const h = rect.height\n\n      mouse.x = (x / w) * 2 - 1\n      mouse.y = -(y / h) * 2 + 1\n\n      dollyDirection.set(mouse.x, mouse.y, 1).unproject(scope.object).sub(scope.object.position).normalize()\n    }\n\n    function clampDistance(dist: number): number {\n      return Math.max(scope.minDistance, Math.min(scope.maxDistance, dist))\n    }\n\n    //\n    // event callbacks - update the object state\n    //\n\n    function handleMouseDownRotate(event: MouseEvent) {\n      rotateStart.set(event.clientX, event.clientY)\n    }\n\n    function handleMouseDownDolly(event: MouseEvent) {\n      updateMouseParameters(event)\n      dollyStart.set(event.clientX, event.clientY)\n    }\n\n    function handleMouseDownPan(event: MouseEvent) {\n      panStart.set(event.clientX, event.clientY)\n    }\n\n    function handleMouseMoveRotate(event: MouseEvent) {\n      rotateEnd.set(event.clientX, event.clientY)\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed)\n\n      const element = scope.domElement\n\n      if (element) {\n        rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight) // yes, height\n        rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight)\n      }\n      rotateStart.copy(rotateEnd)\n      scope.update()\n    }\n\n    function handleMouseMoveDolly(event: MouseEvent) {\n      dollyEnd.set(event.clientX, event.clientY)\n      dollyDelta.subVectors(dollyEnd, dollyStart)\n\n      if (dollyDelta.y > 0) {\n        dollyOut(getZoomScale())\n      } else if (dollyDelta.y < 0) {\n        dollyIn(getZoomScale())\n      }\n\n      dollyStart.copy(dollyEnd)\n      scope.update()\n    }\n\n    function handleMouseMovePan(event: MouseEvent) {\n      panEnd.set(event.clientX, event.clientY)\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed)\n      pan(panDelta.x, panDelta.y)\n      panStart.copy(panEnd)\n      scope.update()\n    }\n\n    function handleMouseWheel(event: WheelEvent) {\n      updateMouseParameters(event)\n\n      if (event.deltaY < 0) {\n        dollyIn(getZoomScale())\n      } else if (event.deltaY > 0) {\n        dollyOut(getZoomScale())\n      }\n\n      scope.update()\n    }\n\n    function handleKeyDown(event: KeyboardEvent) {\n      let needsUpdate = false\n\n      switch (event.code) {\n        case scope.keys.UP:\n          pan(0, scope.keyPanSpeed)\n          needsUpdate = true\n          break\n\n        case scope.keys.BOTTOM:\n          pan(0, -scope.keyPanSpeed)\n          needsUpdate = true\n          break\n\n        case scope.keys.LEFT:\n          pan(scope.keyPanSpeed, 0)\n          needsUpdate = true\n          break\n\n        case scope.keys.RIGHT:\n          pan(-scope.keyPanSpeed, 0)\n          needsUpdate = true\n          break\n      }\n\n      if (needsUpdate) {\n        // prevent the browser from scrolling on cursor keys\n        event.preventDefault()\n        scope.update()\n      }\n    }\n\n    function handleTouchStartRotate() {\n      if (pointers.length == 1) {\n        rotateStart.set(pointers[0].pageX, pointers[0].pageY)\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX)\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY)\n\n        rotateStart.set(x, y)\n      }\n    }\n\n    function handleTouchStartPan() {\n      if (pointers.length == 1) {\n        panStart.set(pointers[0].pageX, pointers[0].pageY)\n      } else {\n        const x = 0.5 * (pointers[0].pageX + pointers[1].pageX)\n        const y = 0.5 * (pointers[0].pageY + pointers[1].pageY)\n\n        panStart.set(x, y)\n      }\n    }\n\n    function handleTouchStartDolly() {\n      const dx = pointers[0].pageX - pointers[1].pageX\n      const dy = pointers[0].pageY - pointers[1].pageY\n      const distance = Math.sqrt(dx * dx + dy * dy)\n\n      dollyStart.set(0, distance)\n    }\n\n    function handleTouchStartDollyPan() {\n      if (scope.enableZoom) handleTouchStartDolly()\n      if (scope.enablePan) handleTouchStartPan()\n    }\n\n    function handleTouchStartDollyRotate() {\n      if (scope.enableZoom) handleTouchStartDolly()\n      if (scope.enableRotate) handleTouchStartRotate()\n    }\n\n    function handleTouchMoveRotate(event: PointerEvent) {\n      if (pointers.length == 1) {\n        rotateEnd.set(event.pageX, event.pageY)\n      } else {\n        const position = getSecondPointerPosition(event)\n        const x = 0.5 * (event.pageX + position.x)\n        const y = 0.5 * (event.pageY + position.y)\n        rotateEnd.set(x, y)\n      }\n\n      rotateDelta.subVectors(rotateEnd, rotateStart).multiplyScalar(scope.rotateSpeed)\n\n      const element = scope.domElement\n\n      if (element) {\n        rotateLeft((2 * Math.PI * rotateDelta.x) / element.clientHeight) // yes, height\n        rotateUp((2 * Math.PI * rotateDelta.y) / element.clientHeight)\n      }\n      rotateStart.copy(rotateEnd)\n    }\n\n    function handleTouchMovePan(event: PointerEvent) {\n      if (pointers.length == 1) {\n        panEnd.set(event.pageX, event.pageY)\n      } else {\n        const position = getSecondPointerPosition(event)\n        const x = 0.5 * (event.pageX + position.x)\n        const y = 0.5 * (event.pageY + position.y)\n        panEnd.set(x, y)\n      }\n\n      panDelta.subVectors(panEnd, panStart).multiplyScalar(scope.panSpeed)\n      pan(panDelta.x, panDelta.y)\n      panStart.copy(panEnd)\n    }\n\n    function handleTouchMoveDolly(event: PointerEvent) {\n      const position = getSecondPointerPosition(event)\n      const dx = event.pageX - position.x\n      const dy = event.pageY - position.y\n      const distance = Math.sqrt(dx * dx + dy * dy)\n\n      dollyEnd.set(0, distance)\n      dollyDelta.set(0, Math.pow(dollyEnd.y / dollyStart.y, scope.zoomSpeed))\n      dollyOut(dollyDelta.y)\n      dollyStart.copy(dollyEnd)\n    }\n\n    function handleTouchMoveDollyPan(event: PointerEvent) {\n      if (scope.enableZoom) handleTouchMoveDolly(event)\n      if (scope.enablePan) handleTouchMovePan(event)\n    }\n\n    function handleTouchMoveDollyRotate(event: PointerEvent) {\n      if (scope.enableZoom) handleTouchMoveDolly(event)\n      if (scope.enableRotate) handleTouchMoveRotate(event)\n    }\n\n    //\n    // event handlers - FSM: listen for events and reset state\n    //\n\n    function onPointerDown(event: PointerEvent) {\n      if (scope.enabled === false) return\n\n      if (pointers.length === 0) {\n        scope.domElement?.ownerDocument.addEventListener('pointermove', onPointerMove)\n        scope.domElement?.ownerDocument.addEventListener('pointerup', onPointerUp)\n      }\n\n      addPointer(event)\n\n      if (event.pointerType === 'touch') {\n        onTouchStart(event)\n      } else {\n        onMouseDown(event)\n      }\n    }\n\n    function onPointerMove(event: PointerEvent) {\n      if (scope.enabled === false) return\n\n      if (event.pointerType === 'touch') {\n        onTouchMove(event)\n      } else {\n        onMouseMove(event)\n      }\n    }\n\n    function onPointerUp(event: PointerEvent) {\n      removePointer(event)\n\n      if (pointers.length === 0) {\n        scope.domElement?.releasePointerCapture(event.pointerId)\n\n        scope.domElement?.ownerDocument.removeEventListener('pointermove', onPointerMove)\n        scope.domElement?.ownerDocument.removeEventListener('pointerup', onPointerUp)\n      }\n\n      // @ts-ignore\n      scope.dispatchEvent(endEvent)\n\n      state = STATE.NONE\n    }\n\n    function onMouseDown(event: MouseEvent) {\n      let mouseAction\n\n      switch (event.button) {\n        case 0:\n          mouseAction = scope.mouseButtons.LEFT\n          break\n\n        case 1:\n          mouseAction = scope.mouseButtons.MIDDLE\n          break\n\n        case 2:\n          mouseAction = scope.mouseButtons.RIGHT\n          break\n\n        default:\n          mouseAction = -1\n      }\n\n      switch (mouseAction) {\n        case MOUSE.DOLLY:\n          if (scope.enableZoom === false) return\n          handleMouseDownDolly(event)\n          state = STATE.DOLLY\n          break\n\n        case MOUSE.ROTATE:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enablePan === false) return\n            handleMouseDownPan(event)\n            state = STATE.PAN\n          } else {\n            if (scope.enableRotate === false) return\n            handleMouseDownRotate(event)\n            state = STATE.ROTATE\n          }\n          break\n\n        case MOUSE.PAN:\n          if (event.ctrlKey || event.metaKey || event.shiftKey) {\n            if (scope.enableRotate === false) return\n            handleMouseDownRotate(event)\n            state = STATE.ROTATE\n          } else {\n            if (scope.enablePan === false) return\n            handleMouseDownPan(event)\n            state = STATE.PAN\n          }\n          break\n\n        default:\n          state = STATE.NONE\n      }\n\n      if (state !== STATE.NONE) {\n        // @ts-ignore\n        scope.dispatchEvent(startEvent)\n      }\n    }\n\n    function onMouseMove(event: MouseEvent) {\n      if (scope.enabled === false) return\n\n      switch (state) {\n        case STATE.ROTATE:\n          if (scope.enableRotate === false) return\n          handleMouseMoveRotate(event)\n          break\n\n        case STATE.DOLLY:\n          if (scope.enableZoom === false) return\n          handleMouseMoveDolly(event)\n          break\n\n        case STATE.PAN:\n          if (scope.enablePan === false) return\n          handleMouseMovePan(event)\n          break\n      }\n    }\n\n    function onMouseWheel(event: WheelEvent) {\n      if (scope.enabled === false || scope.enableZoom === false || (state !== STATE.NONE && state !== STATE.ROTATE)) {\n        return\n      }\n\n      event.preventDefault()\n\n      // @ts-ignore\n      scope.dispatchEvent(startEvent)\n\n      handleMouseWheel(event)\n\n      // @ts-ignore\n      scope.dispatchEvent(endEvent)\n    }\n\n    function onKeyDown(event: KeyboardEvent) {\n      if (scope.enabled === false || scope.enablePan === false) return\n      handleKeyDown(event)\n    }\n\n    function onTouchStart(event: PointerEvent) {\n      trackPointer(event)\n\n      switch (pointers.length) {\n        case 1:\n          switch (scope.touches.ONE) {\n            case TOUCH.ROTATE:\n              if (scope.enableRotate === false) return\n              handleTouchStartRotate()\n              state = STATE.TOUCH_ROTATE\n              break\n\n            case TOUCH.PAN:\n              if (scope.enablePan === false) return\n              handleTouchStartPan()\n              state = STATE.TOUCH_PAN\n              break\n\n            default:\n              state = STATE.NONE\n          }\n\n          break\n\n        case 2:\n          switch (scope.touches.TWO) {\n            case TOUCH.DOLLY_PAN:\n              if (scope.enableZoom === false && scope.enablePan === false) return\n              handleTouchStartDollyPan()\n              state = STATE.TOUCH_DOLLY_PAN\n              break\n\n            case TOUCH.DOLLY_ROTATE:\n              if (scope.enableZoom === false && scope.enableRotate === false) return\n              handleTouchStartDollyRotate()\n              state = STATE.TOUCH_DOLLY_ROTATE\n              break\n\n            default:\n              state = STATE.NONE\n          }\n\n          break\n\n        default:\n          state = STATE.NONE\n      }\n\n      if (state !== STATE.NONE) {\n        // @ts-ignore\n        scope.dispatchEvent(startEvent)\n      }\n    }\n\n    function onTouchMove(event: PointerEvent) {\n      trackPointer(event)\n\n      switch (state) {\n        case STATE.TOUCH_ROTATE:\n          if (scope.enableRotate === false) return\n          handleTouchMoveRotate(event)\n          scope.update()\n          break\n\n        case STATE.TOUCH_PAN:\n          if (scope.enablePan === false) return\n          handleTouchMovePan(event)\n          scope.update()\n          break\n\n        case STATE.TOUCH_DOLLY_PAN:\n          if (scope.enableZoom === false && scope.enablePan === false) return\n          handleTouchMoveDollyPan(event)\n          scope.update()\n          break\n\n        case STATE.TOUCH_DOLLY_ROTATE:\n          if (scope.enableZoom === false && scope.enableRotate === false) return\n          handleTouchMoveDollyRotate(event)\n          scope.update()\n          break\n\n        default:\n          state = STATE.NONE\n      }\n    }\n\n    function onContextMenu(event: Event) {\n      if (scope.enabled === false) return\n      event.preventDefault()\n    }\n\n    function addPointer(event: PointerEvent) {\n      pointers.push(event)\n    }\n\n    function removePointer(event: PointerEvent) {\n      delete pointerPositions[event.pointerId]\n\n      for (let i = 0; i < pointers.length; i++) {\n        if (pointers[i].pointerId == event.pointerId) {\n          pointers.splice(i, 1)\n          return\n        }\n      }\n    }\n\n    function trackPointer(event: PointerEvent) {\n      let position = pointerPositions[event.pointerId]\n\n      if (position === undefined) {\n        position = new Vector2()\n        pointerPositions[event.pointerId] = position\n      }\n\n      position.set(event.pageX, event.pageY)\n    }\n\n    function getSecondPointerPosition(event: PointerEvent) {\n      const pointer = event.pointerId === pointers[0].pointerId ? pointers[1] : pointers[0]\n      return pointerPositions[pointer.pointerId]\n    }\n\n    // connect events\n    if (domElement !== undefined) this.connect(domElement)\n    // force an update at start\n    this.update()\n  }\n}\n\n// This set of controls performs orbiting, dollying (zooming), and panning.\n// Unlike TrackballControls, it maintains the \"up\" direction object.up (+Y by default).\n// This is very similar to OrbitControls, another set of touch behavior\n//\n//    Orbit - right mouse, or left mouse + ctrl/meta/shiftKey / touch: two-finger rotate\n//    Zoom - middle mouse, or mousewheel / touch: two-finger spread or squish\n//    Pan - left mouse, or arrow keys / touch: one-finger move\n\nclass MapControls extends OrbitControls {\n  constructor(object: PerspectiveCamera | OrthographicCamera, domElement?: HTMLElement) {\n    super(object, domElement)\n\n    this.screenSpacePanning = false // pan orthogonal to world-space direction camera.up\n\n    this.mouseButtons.LEFT = MOUSE.PAN\n    this.mouseButtons.RIGHT = MOUSE.ROTATE\n\n    this.touches.ONE = TOUCH.PAN\n    this.touches.TWO = TOUCH.DOLLY_ROTATE\n  }\n}\n\nexport { OrbitControls, MapControls }\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport { useThree, useFrame } from '@react-three/fiber';\nimport * as React from 'react';\nimport { OrbitControls as OrbitControls$1 } from 'three-stdlib';\n\nconst OrbitControls = /* @__PURE__ */React.forwardRef(({\n  makeDefault,\n  camera,\n  regress,\n  domElement,\n  enableDamping = true,\n  keyEvents = false,\n  onChange,\n  onStart,\n  onEnd,\n  ...restProps\n}, ref) => {\n  const invalidate = useThree(state => state.invalidate);\n  const defaultCamera = useThree(state => state.camera);\n  const gl = useThree(state => state.gl);\n  const events = useThree(state => state.events);\n  const setEvents = useThree(state => state.setEvents);\n  const set = useThree(state => state.set);\n  const get = useThree(state => state.get);\n  const performance = useThree(state => state.performance);\n  const explCamera = camera || defaultCamera;\n  const explDomElement = domElement || events.connected || gl.domElement;\n  const controls = React.useMemo(() => new OrbitControls$1(explCamera), [explCamera]);\n  useFrame(() => {\n    if (controls.enabled) controls.update();\n  }, -1);\n  React.useEffect(() => {\n    if (keyEvents) {\n      controls.connect(keyEvents === true ? explDomElement : keyEvents);\n    }\n    controls.connect(explDomElement);\n    return () => void controls.dispose();\n  }, [keyEvents, explDomElement, regress, controls, invalidate]);\n  React.useEffect(() => {\n    const callback = e => {\n      invalidate();\n      if (regress) performance.regress();\n      if (onChange) onChange(e);\n    };\n    const onStartCb = e => {\n      if (onStart) onStart(e);\n    };\n    const onEndCb = e => {\n      if (onEnd) onEnd(e);\n    };\n    controls.addEventListener('change', callback);\n    controls.addEventListener('start', onStartCb);\n    controls.addEventListener('end', onEndCb);\n    return () => {\n      controls.removeEventListener('start', onStartCb);\n      controls.removeEventListener('end', onEndCb);\n      controls.removeEventListener('change', callback);\n    };\n  }, [onChange, onStart, onEnd, controls, invalidate, setEvents]);\n  React.useEffect(() => {\n    if (makeDefault) {\n      const old = get().controls;\n      set({\n        controls\n      });\n      return () => set({\n        controls: old\n      });\n    }\n  }, [makeDefault, controls]);\n  return /*#__PURE__*/React.createElement(\"primitive\", _extends({\n    ref: ref,\n    object: controls,\n    enableDamping: enableDamping\n  }, restProps));\n});\n\nexport { OrbitControls };\n","import { ExtrudeGeometry } from 'three'\n\nimport type { Font } from '../loaders/FontLoader'\n\nexport type TextGeometryParameters = {\n  bevelEnabled?: boolean\n  bevelOffset?: number\n  bevelSize?: number\n  bevelThickness?: number\n  curveSegments?: number\n  font: Font\n  height?: number\n  size?: number\n  lineHeight?: number\n  letterSpacing?: number\n}\n\nexport class TextGeometry extends ExtrudeGeometry {\n  constructor(text: string, parameters: TextGeometryParameters = {} as TextGeometryParameters) {\n    const {\n      bevelEnabled = false,\n      bevelSize = 8,\n      bevelThickness = 10,\n      font,\n      height = 50,\n      size = 100,\n      lineHeight = 1,\n      letterSpacing = 0,\n      ...rest\n    } = parameters\n\n    if (font === undefined) {\n      // @ts-ignore\n      super() // generate default extrude geometry\n    } else {\n      const shapes = font.generateShapes(text, size, { lineHeight, letterSpacing })\n      super(shapes, { ...rest, bevelEnabled, bevelSize, bevelThickness, depth: height })\n    }\n    // @ts-ignore\n    this.type = 'TextGeometry'\n  }\n}\n\nexport { TextGeometry as TextBufferGeometry }\n","import { Loader, FileLoader, ShapePath } from 'three'\n\nimport type { LoadingManager, Shape } from 'three'\n\ntype Options = {\n  lineHeight: number\n  letterSpacing: number\n}\n\nexport class FontLoader extends Loader {\n  constructor(manager?: LoadingManager) {\n    super(manager)\n  }\n\n  public load(\n    url: string,\n    onLoad?: (responseFont: Font) => void,\n    onProgress?: (event: ProgressEvent) => void,\n    onError?: (event: ErrorEvent) => void,\n  ): void {\n    const loader = new FileLoader(this.manager)\n\n    loader.setPath(this.path)\n    loader.setRequestHeader(this.requestHeader)\n    loader.setWithCredentials(this.withCredentials)\n\n    loader.load(\n      url,\n      (response) => {\n        if (typeof response !== 'string') throw new Error('unsupported data type')\n\n        const json = JSON.parse(response)\n\n        const font = this.parse(json)\n\n        if (onLoad) onLoad(font)\n      },\n      onProgress,\n      onError as (event: unknown) => void,\n    )\n  }\n\n  loadAsync(url: string, onProgress?: (event: ProgressEvent) => void): Promise<Font> {\n    // @ts-ignore\n    return super.loadAsync(url, onProgress)\n  }\n\n  public parse(json: FontData): Font {\n    return new Font(json)\n  }\n}\n\ntype Glyph = {\n  _cachedOutline: string[]\n  ha: number\n  o: string\n}\n\ntype FontData = {\n  boundingBox: { yMax: number; yMin: number }\n  familyName: string\n  glyphs: { [k: string]: Glyph }\n  resolution: number\n  underlineThickness: number\n}\n\nexport class Font {\n  public data: FontData\n  public static isFont: true\n  public static type: 'Font'\n\n  constructor(data: FontData) {\n    this.data = data\n  }\n\n  public generateShapes(text: string, size = 100, _options?: Partial<Options>): Shape[] {\n    const shapes: Shape[] = []\n    const options = { letterSpacing: 0, lineHeight: 1, ..._options }\n    const paths = createPaths(text, size, this.data, options)\n    for (let p = 0, pl = paths.length; p < pl; p++) {\n      Array.prototype.push.apply(shapes, paths[p].toShapes(false))\n    }\n    return shapes\n  }\n}\n\nfunction createPaths(text: string, size: number, data: FontData, options: Options): ShapePath[] {\n  const chars = Array.from(text)\n  const scale = size / data.resolution\n  const line_height = (data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness) * scale\n\n  const paths: ShapePath[] = []\n\n  let offsetX = 0,\n    offsetY = 0\n\n  for (let i = 0; i < chars.length; i++) {\n    const char = chars[i]\n\n    if (char === '\\n') {\n      offsetX = 0\n      offsetY -= line_height * options.lineHeight\n    } else {\n      const ret = createPath(char, scale, offsetX, offsetY, data)\n      if (ret) {\n        offsetX += ret.offsetX + options.letterSpacing\n        paths.push(ret.path)\n      }\n    }\n  }\n\n  return paths\n}\n\nfunction createPath(\n  char: string,\n  scale: number,\n  offsetX: number,\n  offsetY: number,\n  data: FontData,\n): { offsetX: number; path: ShapePath } | undefined {\n  const glyph = data.glyphs[char] || data.glyphs['?']\n\n  if (!glyph) {\n    console.error('THREE.Font: character \"' + char + '\" does not exists in font family ' + data.familyName + '.')\n    return\n  }\n\n  const path = new ShapePath()\n\n  let x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2\n\n  if (glyph.o) {\n    const outline = glyph._cachedOutline || (glyph._cachedOutline = glyph.o.split(' '))\n\n    for (let i = 0, l = outline.length; i < l; ) {\n      const action = outline[i++]\n\n      switch (action) {\n        case 'm': // moveTo\n          x = parseInt(outline[i++]) * scale + offsetX\n          y = parseInt(outline[i++]) * scale + offsetY\n\n          path.moveTo(x, y)\n\n          break\n\n        case 'l': // lineTo\n          x = parseInt(outline[i++]) * scale + offsetX\n          y = parseInt(outline[i++]) * scale + offsetY\n\n          path.lineTo(x, y)\n\n          break\n\n        case 'q': // quadraticCurveTo\n          cpx = parseInt(outline[i++]) * scale + offsetX\n          cpy = parseInt(outline[i++]) * scale + offsetY\n          cpx1 = parseInt(outline[i++]) * scale + offsetX\n          cpy1 = parseInt(outline[i++]) * scale + offsetY\n\n          path.quadraticCurveTo(cpx1, cpy1, cpx, cpy)\n\n          break\n\n        case 'b': // bezierCurveTo\n          cpx = parseInt(outline[i++]) * scale + offsetX\n          cpy = parseInt(outline[i++]) * scale + offsetY\n          cpx1 = parseInt(outline[i++]) * scale + offsetX\n          cpy1 = parseInt(outline[i++]) * scale + offsetY\n          cpx2 = parseInt(outline[i++]) * scale + offsetX\n          cpy2 = parseInt(outline[i++]) * scale + offsetY\n\n          path.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, cpx, cpy)\n\n          break\n      }\n    }\n  }\n\n  return { offsetX: glyph.ha * scale, path }\n}\n","import { FontLoader } from 'three-stdlib';\nimport { suspend, preload, clear } from 'suspend-react';\n\nlet fontLoader = null;\nasync function loadFontData(font) {\n  return typeof font === 'string' ? await (await fetch(font)).json() : font;\n}\nfunction parseFontData(fontData) {\n  if (!fontLoader) {\n    fontLoader = new FontLoader();\n  }\n  return fontLoader.parse(fontData);\n}\nasync function loader(font) {\n  const data = await loadFontData(font);\n  return parseFontData(data);\n}\nfunction useFont(font) {\n  return suspend(loader, [font]);\n}\nuseFont.preload = font => preload(loader, [font]);\nuseFont.clear = font => clear([font]);\n\nexport { useFont };\n","import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as React from 'react';\nimport { useMemo } from 'react';\nimport { extend } from '@react-three/fiber';\nimport { TextGeometry, mergeVertices } from 'three-stdlib';\nimport { useFont } from './useFont.js';\n\nconst types = ['string', 'number'];\nconst getTextFromChildren = children => {\n  let label = '';\n  const rest = [];\n  React.Children.forEach(children, child => {\n    if (types.includes(typeof child)) label += child + '';else rest.push(child);\n  });\n  return [label, ...rest];\n};\nconst Text3D = /* @__PURE__ */React.forwardRef(({\n  font: _font,\n  letterSpacing = 0,\n  lineHeight = 1,\n  size = 1,\n  height = 0.2,\n  bevelThickness = 0.1,\n  bevelSize = 0.01,\n  bevelEnabled = false,\n  bevelOffset = 0,\n  bevelSegments = 4,\n  curveSegments = 8,\n  smooth,\n  children,\n  ...props\n}, fref) => {\n  React.useMemo(() => extend({\n    RenamedTextGeometry: TextGeometry\n  }), []);\n  const ref = React.useRef(null);\n  const font = useFont(_font);\n  const opts = useMemo(() => {\n    return {\n      font,\n      size,\n      height,\n      bevelThickness,\n      bevelSize,\n      bevelEnabled,\n      bevelSegments,\n      bevelOffset,\n      curveSegments,\n      letterSpacing,\n      lineHeight\n    };\n  }, [font, size, height, bevelThickness, bevelSize, bevelEnabled, bevelSegments, bevelOffset, curveSegments, letterSpacing, lineHeight]);\n\n  /**\n   * We need the `children` in the deps because we\n   * need to be able to do `<Text3d>{state}</Text3d>`.\n   */\n  const [label, ...rest] = useMemo(() => getTextFromChildren(children), [children]);\n  const args = React.useMemo(() => [label, opts], [label, opts]);\n  React.useLayoutEffect(() => {\n    if (smooth) {\n      ref.current.geometry = mergeVertices(ref.current.geometry, smooth);\n      ref.current.geometry.computeVertexNormals();\n    }\n  }, [args, smooth]);\n  React.useImperativeHandle(fref, () => ref.current, []);\n  return /*#__PURE__*/React.createElement(\"mesh\", _extends({}, props, {\n    ref: ref\n  }), /*#__PURE__*/React.createElement(\"renamedTextGeometry\", {\n    args: args\n  }), rest);\n});\n\nexport { Text3D };\n","import {\n  BufferAttribute,\n  BufferGeometry,\n  Float32BufferAttribute,\n  InterleavedBuffer,\n  InterleavedBufferAttribute,\n  TriangleFanDrawMode,\n  TriangleStripDrawMode,\n  TrianglesDrawMode,\n  Vector3,\n  Mesh,\n  Line,\n  Points,\n  Material,\n  SkinnedMesh,\n} from 'three'\n\nimport { getWithKey } from '../types/helpers'\nimport type { TypedArrayConstructors, TypedArray } from '../types/shared'\n\n/**\n * @param  {Array<BufferGeometry>} geometries\n * @param  {Boolean} useGroups\n * @return {BufferGeometry}\n */\nexport const mergeBufferGeometries = (geometries: BufferGeometry[], useGroups?: boolean): BufferGeometry | null => {\n  const isIndexed = geometries[0].index !== null\n\n  const attributesUsed = new Set(Object.keys(geometries[0].attributes))\n  const morphAttributesUsed = new Set(Object.keys(geometries[0].morphAttributes))\n\n  const attributes: { [key: string]: Array<InterleavedBufferAttribute | BufferAttribute> } = {}\n  const morphAttributes: { [key: string]: Array<BufferAttribute | InterleavedBufferAttribute>[] } = {}\n\n  const morphTargetsRelative = geometries[0].morphTargetsRelative\n\n  const mergedGeometry = new BufferGeometry()\n\n  let offset = 0\n\n  geometries.forEach((geom, i) => {\n    let attributesCount = 0\n\n    // ensure that all geometries are indexed, or none\n\n    if (isIndexed !== (geom.index !== null)) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them.',\n      )\n      return null\n    }\n\n    // gather attributes, exit early if they're different\n\n    for (let name in geom.attributes) {\n      if (!attributesUsed.has(name)) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '. All geometries must have compatible attributes; make sure \"' +\n            name +\n            '\" attribute exists among all geometries, or in none of them.',\n        )\n        return null\n      }\n\n      if (attributes[name] === undefined) {\n        attributes[name] = []\n      }\n\n      attributes[name].push(geom.attributes[name])\n\n      attributesCount++\n    }\n\n    // ensure geometries have the same number of attributes\n\n    if (attributesCount !== attributesUsed.size) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. Make sure all geometries have the same number of attributes.',\n      )\n      return null\n    }\n\n    // gather morph attributes, exit early if they're different\n\n    if (morphTargetsRelative !== geom.morphTargetsRelative) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n          i +\n          '. .morphTargetsRelative must be consistent throughout all geometries.',\n      )\n      return null\n    }\n\n    for (let name in geom.morphAttributes) {\n      if (!morphAttributesUsed.has(name)) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '.  .morphAttributes must be consistent throughout all geometries.',\n        )\n        return null\n      }\n\n      if (morphAttributes[name] === undefined) morphAttributes[name] = []\n\n      morphAttributes[name].push(geom.morphAttributes[name])\n    }\n\n    // gather .userData\n\n    mergedGeometry.userData.mergedUserData = mergedGeometry.userData.mergedUserData || []\n    mergedGeometry.userData.mergedUserData.push(geom.userData)\n\n    if (useGroups) {\n      let count\n\n      if (geom.index) {\n        count = geom.index.count\n      } else if (geom.attributes.position !== undefined) {\n        count = geom.attributes.position.count\n      } else {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed with geometry at index ' +\n            i +\n            '. The geometry must have either an index or a position attribute',\n        )\n        return null\n      }\n\n      mergedGeometry.addGroup(offset, count, i)\n\n      offset += count\n    }\n  })\n\n  // merge indices\n\n  if (isIndexed) {\n    let indexOffset = 0\n    const mergedIndex: number[] = []\n\n    geometries.forEach((geom) => {\n      const index = geom.index as BufferAttribute\n\n      for (let j = 0; j < index.count; ++j) {\n        mergedIndex.push(index.getX(j) + indexOffset)\n      }\n\n      indexOffset += geom.attributes.position.count\n    })\n\n    mergedGeometry.setIndex(mergedIndex)\n  }\n\n  // merge attributes\n\n  for (let name in attributes) {\n    const mergedAttribute = mergeBufferAttributes(attributes[name] as BufferAttribute[])\n\n    if (!mergedAttribute) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' + name + ' attribute.',\n      )\n      return null\n    }\n\n    mergedGeometry.setAttribute(name, mergedAttribute)\n  }\n\n  // merge morph attributes\n\n  for (let name in morphAttributes) {\n    const numMorphTargets = morphAttributes[name][0].length\n\n    if (numMorphTargets === 0) break\n\n    mergedGeometry.morphAttributes = mergedGeometry.morphAttributes || {}\n    mergedGeometry.morphAttributes[name] = []\n\n    for (let i = 0; i < numMorphTargets; ++i) {\n      const morphAttributesToMerge = []\n\n      for (let j = 0; j < morphAttributes[name].length; ++j) {\n        morphAttributesToMerge.push(morphAttributes[name][j][i])\n      }\n\n      const mergedMorphAttribute = mergeBufferAttributes(morphAttributesToMerge as BufferAttribute[])\n\n      if (!mergedMorphAttribute) {\n        console.error(\n          'THREE.BufferGeometryUtils: .mergeBufferGeometries() failed while trying to merge the ' +\n            name +\n            ' morphAttribute.',\n        )\n        return null\n      }\n\n      mergedGeometry.morphAttributes[name].push(mergedMorphAttribute)\n    }\n  }\n\n  return mergedGeometry\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {BufferAttribute}\n */\nexport const mergeBufferAttributes = (attributes: BufferAttribute[]): BufferAttribute | null | undefined => {\n  let TypedArray: TypedArrayConstructors | undefined = undefined\n  let itemSize: number | undefined = undefined\n  let normalized: boolean | undefined = undefined\n  let arrayLength = 0\n\n  attributes.forEach((attr) => {\n    if (TypedArray === undefined) {\n      TypedArray = attr.array.constructor\n    }\n    if (TypedArray !== attr.array.constructor) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes.',\n      )\n      return null\n    }\n\n    if (itemSize === undefined) itemSize = attr.itemSize\n    if (itemSize !== attr.itemSize) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes.',\n      )\n      return null\n    }\n\n    if (normalized === undefined) normalized = attr.normalized\n    if (normalized !== attr.normalized) {\n      console.error(\n        'THREE.BufferGeometryUtils: .mergeBufferAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes.',\n      )\n      return null\n    }\n\n    arrayLength += attr.array.length\n  })\n\n  if (TypedArray && itemSize) {\n    // @ts-ignore this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n    const array = new TypedArray(arrayLength)\n    let offset = 0\n\n    attributes.forEach((attr) => {\n      array.set(attr.array, offset)\n      offset += attr.array.length\n    })\n\n    return new BufferAttribute(array, itemSize, normalized)\n  }\n}\n\n/**\n * @param {Array<BufferAttribute>} attributes\n * @return {Array<InterleavedBufferAttribute>}\n */\nexport const interleaveAttributes = (attributes: BufferAttribute[]): InterleavedBufferAttribute[] | null => {\n  // Interleaves the provided attributes into an InterleavedBuffer and returns\n  // a set of InterleavedBufferAttributes for each attribute\n  let TypedArray: TypedArrayConstructors | undefined = undefined\n  let arrayLength = 0\n  let stride = 0\n\n  // calculate the the length and type of the interleavedBuffer\n  for (let i = 0, l = attributes.length; i < l; ++i) {\n    const attribute = attributes[i]\n\n    if (TypedArray === undefined) TypedArray = attribute.array.constructor\n    if (TypedArray !== attribute.array.constructor) {\n      console.error('AttributeBuffers of different types cannot be interleaved')\n      return null\n    }\n\n    arrayLength += attribute.array.length\n    stride += attribute.itemSize\n  }\n\n  // Create the set of buffer attributes\n  // @ts-ignore this works in JS and TS is complaining but it's such a tiny thing I can live with the guilt\n  const interleavedBuffer = new InterleavedBuffer(new TypedArray(arrayLength), stride)\n  let offset = 0\n  const res = []\n  const getters = ['getX', 'getY', 'getZ', 'getW']\n  const setters = ['setX', 'setY', 'setZ', 'setW']\n\n  for (let j = 0, l = attributes.length; j < l; j++) {\n    const attribute = attributes[j]\n    const itemSize = attribute.itemSize\n    const count = attribute.count\n    const iba = new InterleavedBufferAttribute(interleavedBuffer, itemSize, offset, attribute.normalized)\n    res.push(iba)\n\n    offset += itemSize\n\n    // Move the data for each attribute into the new interleavedBuffer\n    // at the appropriate offset\n    for (let c = 0; c < count; c++) {\n      for (let k = 0; k < itemSize; k++) {\n        const set = getWithKey(iba, setters[k] as keyof InterleavedBufferAttribute) as InterleavedBufferAttribute[\n          | 'setX'\n          | 'setY'\n          | 'setZ'\n          | 'setW']\n        const get = getWithKey(attribute, getters[k] as keyof BufferAttribute) as BufferAttribute[\n          | 'getX'\n          | 'getY'\n          | 'getZ'\n          | 'getW']\n        set(c, get(c))\n      }\n    }\n  }\n\n  return res\n}\n\n/**\n * @param {Array<BufferGeometry>} geometry\n * @return {number}\n */\nexport function estimateBytesUsed(geometry: BufferGeometry): number {\n  // Return the estimated memory used by this geometry in bytes\n  // Calculate using itemSize, count, and BYTES_PER_ELEMENT to account\n  // for InterleavedBufferAttributes.\n  let mem = 0\n  for (let name in geometry.attributes) {\n    const attr = geometry.getAttribute(name)\n    mem += attr.count * attr.itemSize * (attr.array as TypedArray).BYTES_PER_ELEMENT\n  }\n\n  const indices = geometry.getIndex()\n  mem += indices ? indices.count * indices.itemSize * (indices.array as TypedArray).BYTES_PER_ELEMENT : 0\n  return mem\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} tolerance\n * @return {BufferGeometry>}\n */\nexport function mergeVertices(geometry: BufferGeometry, tolerance = 1e-4): BufferGeometry {\n  tolerance = Math.max(tolerance, Number.EPSILON)\n\n  // Generate an index buffer if the geometry doesn't have one, or optimize it\n  // if it's already available.\n  const hashToIndex: {\n    [key: string]: number\n  } = {}\n  const indices = geometry.getIndex()\n  const positions = geometry.getAttribute('position')\n  const vertexCount = indices ? indices.count : positions.count\n\n  // next value for triangle indices\n  let nextIndex = 0\n\n  // attributes and new attribute arrays\n  const attributeNames = Object.keys(geometry.attributes)\n  const attrArrays: {\n    [key: string]: []\n  } = {}\n  const morphAttrsArrays: {\n    [key: string]: Array<Array<BufferAttribute | InterleavedBufferAttribute>>\n  } = {}\n  const newIndices = []\n  const getters = ['getX', 'getY', 'getZ', 'getW']\n\n  // initialize the arrays\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i]\n\n    attrArrays[name] = []\n\n    const morphAttr = geometry.morphAttributes[name]\n    if (morphAttr) {\n      morphAttrsArrays[name] = new Array(morphAttr.length).fill(0).map(() => [])\n    }\n  }\n\n  // convert the error tolerance to an amount of decimal places to truncate to\n  const decimalShift = Math.log10(1 / tolerance)\n  const shiftMultiplier = Math.pow(10, decimalShift)\n  for (let i = 0; i < vertexCount; i++) {\n    const index = indices ? indices.getX(i) : i\n\n    // Generate a hash for the vertex attributes at the current index 'i'\n    let hash = ''\n    for (let j = 0, l = attributeNames.length; j < l; j++) {\n      const name = attributeNames[j]\n      const attribute = geometry.getAttribute(name)\n      const itemSize = attribute.itemSize\n\n      for (let k = 0; k < itemSize; k++) {\n        // double tilde truncates the decimal value\n        // @ts-ignore no\n        hash += `${~~(attribute[getters[k]](index) * shiftMultiplier)},`\n      }\n    }\n\n    // Add another reference to the vertex if it's already\n    // used by another index\n    if (hash in hashToIndex) {\n      newIndices.push(hashToIndex[hash])\n    } else {\n      // copy data to the new index in the attribute arrays\n      for (let j = 0, l = attributeNames.length; j < l; j++) {\n        const name = attributeNames[j]\n        const attribute = geometry.getAttribute(name)\n        const morphAttr = geometry.morphAttributes[name]\n        const itemSize = attribute.itemSize\n        const newarray = attrArrays[name]\n        const newMorphArrays = morphAttrsArrays[name]\n\n        for (let k = 0; k < itemSize; k++) {\n          const getterFunc = getters[k]\n          // @ts-ignore\n          newarray.push(attribute[getterFunc](index))\n\n          if (morphAttr) {\n            for (let m = 0, ml = morphAttr.length; m < ml; m++) {\n              // @ts-ignore\n              newMorphArrays[m].push(morphAttr[m][getterFunc](index))\n            }\n          }\n        }\n      }\n\n      hashToIndex[hash] = nextIndex\n      newIndices.push(nextIndex)\n      nextIndex++\n    }\n  }\n\n  // Generate typed arrays from new attribute arrays and update\n  // the attributeBuffers\n  const result = geometry.clone()\n  for (let i = 0, l = attributeNames.length; i < l; i++) {\n    const name = attributeNames[i]\n    const oldAttribute = geometry.getAttribute(name)\n    //@ts-expect-error  something to do with functions and constructors and new\n    const buffer = new (oldAttribute.array as TypedArray).constructor(attrArrays[name])\n    const attribute = new BufferAttribute(buffer, oldAttribute.itemSize, oldAttribute.normalized)\n\n    result.setAttribute(name, attribute)\n\n    // Update the attribute arrays\n    if (name in morphAttrsArrays) {\n      for (let j = 0; j < morphAttrsArrays[name].length; j++) {\n        const oldMorphAttribute = geometry.morphAttributes[name][j]\n        //@ts-expect-error something to do with functions and constructors and new\n        const buffer = new (oldMorphAttribute.array as TypedArray).constructor(morphAttrsArrays[name][j])\n        const morphAttribute = new BufferAttribute(buffer, oldMorphAttribute.itemSize, oldMorphAttribute.normalized)\n        result.morphAttributes[name][j] = morphAttribute\n      }\n    }\n  }\n\n  // indices\n\n  result.setIndex(newIndices)\n\n  return result\n}\n\n/**\n * @param {BufferGeometry} geometry\n * @param {number} drawMode\n * @return {BufferGeometry}\n */\nexport function toTrianglesDrawMode(geometry: BufferGeometry, drawMode: number): BufferGeometry {\n  if (drawMode === TrianglesDrawMode) {\n    console.warn('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles.')\n    return geometry\n  }\n\n  if (drawMode === TriangleFanDrawMode || drawMode === TriangleStripDrawMode) {\n    let index = geometry.getIndex()\n\n    // generate index if not present\n\n    if (index === null) {\n      const indices = []\n\n      const position = geometry.getAttribute('position')\n\n      if (position !== undefined) {\n        for (let i = 0; i < position.count; i++) {\n          indices.push(i)\n        }\n\n        geometry.setIndex(indices)\n        index = geometry.getIndex()\n      } else {\n        console.error(\n          'THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible.',\n        )\n        return geometry\n      }\n    }\n\n    //\n\n    const numberOfTriangles = (index as BufferAttribute).count - 2\n    const newIndices = []\n\n    if (index) {\n      if (drawMode === TriangleFanDrawMode) {\n        // gl.TRIANGLE_FAN\n\n        for (let i = 1; i <= numberOfTriangles; i++) {\n          newIndices.push(index.getX(0))\n          newIndices.push(index.getX(i))\n          newIndices.push(index.getX(i + 1))\n        }\n      } else {\n        // gl.TRIANGLE_STRIP\n\n        for (let i = 0; i < numberOfTriangles; i++) {\n          if (i % 2 === 0) {\n            newIndices.push(index.getX(i))\n            newIndices.push(index.getX(i + 1))\n            newIndices.push(index.getX(i + 2))\n          } else {\n            newIndices.push(index.getX(i + 2))\n            newIndices.push(index.getX(i + 1))\n            newIndices.push(index.getX(i))\n          }\n        }\n      }\n    }\n\n    if (newIndices.length / 3 !== numberOfTriangles) {\n      console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.')\n    }\n\n    // build final geometry\n\n    const newGeometry = geometry.clone()\n    newGeometry.setIndex(newIndices)\n    newGeometry.clearGroups()\n\n    return newGeometry\n  } else {\n    console.error('THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:', drawMode)\n    return geometry\n  }\n}\n\n/**\n * Calculates the morphed attributes of a morphed/skinned BufferGeometry.\n * Helpful for Raytracing or Decals.\n * @param {Mesh | Line | Points} object An instance of Mesh, Line or Points.\n * @return {Object} An Object with original position/normal attributes and morphed ones.\n */\nexport type ComputedMorphedAttribute = {\n  positionAttribute: BufferAttribute | InterleavedBufferAttribute\n  normalAttribute: BufferAttribute | InterleavedBufferAttribute\n  morphedPositionAttribute: Float32BufferAttribute\n  morphedNormalAttribute: Float32BufferAttribute\n}\n\nexport function computeMorphedAttributes(object: Mesh | Line | Points): ComputedMorphedAttribute | null {\n  if (object.geometry.isBufferGeometry !== true) {\n    console.error('THREE.BufferGeometryUtils: Geometry is not of type BufferGeometry.')\n    return null\n  }\n\n  const _vA = new Vector3()\n  const _vB = new Vector3()\n  const _vC = new Vector3()\n\n  const _tempA = new Vector3()\n  const _tempB = new Vector3()\n  const _tempC = new Vector3()\n\n  const _morphA = new Vector3()\n  const _morphB = new Vector3()\n  const _morphC = new Vector3()\n\n  function _calculateMorphedAttributeData(\n    object: Mesh | Line | Points,\n    material: Material,\n    attribute: BufferAttribute | InterleavedBufferAttribute,\n    morphAttribute: (BufferAttribute | InterleavedBufferAttribute)[],\n    morphTargetsRelative: boolean,\n    a: number,\n    b: number,\n    c: number,\n    modifiedAttributeArray: Float32Array,\n  ): void {\n    _vA.fromBufferAttribute(attribute, a)\n    _vB.fromBufferAttribute(attribute, b)\n    _vC.fromBufferAttribute(attribute, c)\n\n    const morphInfluences = object.morphTargetInfluences\n\n    if (\n      // @ts-ignore\n      material.morphTargets &&\n      morphAttribute &&\n      morphInfluences\n    ) {\n      _morphA.set(0, 0, 0)\n      _morphB.set(0, 0, 0)\n      _morphC.set(0, 0, 0)\n\n      for (let i = 0, il = morphAttribute.length; i < il; i++) {\n        const influence = morphInfluences[i]\n        const morph = morphAttribute[i]\n\n        if (influence === 0) continue\n\n        _tempA.fromBufferAttribute(morph, a)\n        _tempB.fromBufferAttribute(morph, b)\n        _tempC.fromBufferAttribute(morph, c)\n\n        if (morphTargetsRelative) {\n          _morphA.addScaledVector(_tempA, influence)\n          _morphB.addScaledVector(_tempB, influence)\n          _morphC.addScaledVector(_tempC, influence)\n        } else {\n          _morphA.addScaledVector(_tempA.sub(_vA), influence)\n          _morphB.addScaledVector(_tempB.sub(_vB), influence)\n          _morphC.addScaledVector(_tempC.sub(_vC), influence)\n        }\n      }\n\n      _vA.add(_morphA)\n      _vB.add(_morphB)\n      _vC.add(_morphC)\n    }\n\n    if ((object as SkinnedMesh).isSkinnedMesh) {\n      // @ts-ignore  https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(a, _vA)\n      // @ts-ignore  https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(b, _vB)\n      // @ts-ignore  https://github.com/three-types/three-ts-types/issues/37\n      object.boneTransform(c, _vC)\n    }\n\n    modifiedAttributeArray[a * 3 + 0] = _vA.x\n    modifiedAttributeArray[a * 3 + 1] = _vA.y\n    modifiedAttributeArray[a * 3 + 2] = _vA.z\n    modifiedAttributeArray[b * 3 + 0] = _vB.x\n    modifiedAttributeArray[b * 3 + 1] = _vB.y\n    modifiedAttributeArray[b * 3 + 2] = _vB.z\n    modifiedAttributeArray[c * 3 + 0] = _vC.x\n    modifiedAttributeArray[c * 3 + 1] = _vC.y\n    modifiedAttributeArray[c * 3 + 2] = _vC.z\n  }\n\n  const geometry = object.geometry\n  const material = object.material\n\n  let a, b, c\n  const index = geometry.index\n  const positionAttribute = geometry.attributes.position\n  const morphPosition = geometry.morphAttributes.position\n  const morphTargetsRelative = geometry.morphTargetsRelative\n  const normalAttribute = geometry.attributes.normal\n  const morphNormal = geometry.morphAttributes.position\n\n  const groups = geometry.groups\n  const drawRange = geometry.drawRange\n  let i, j, il, jl\n  let group, groupMaterial\n  let start, end\n\n  const modifiedPosition = new Float32Array(positionAttribute.count * positionAttribute.itemSize)\n  const modifiedNormal = new Float32Array(normalAttribute.count * normalAttribute.itemSize)\n\n  if (index !== null) {\n    // indexed buffer geometry\n\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i]\n        groupMaterial = material[group.materialIndex as number]\n\n        start = Math.max(group.start, drawRange.start)\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count)\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = index.getX(j)\n          b = index.getX(j + 1)\n          c = index.getX(j + 2)\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition,\n          )\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal,\n          )\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start)\n      end = Math.min(index.count, drawRange.start + drawRange.count)\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = index.getX(i)\n        b = index.getX(i + 1)\n        c = index.getX(i + 2)\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition,\n        )\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal,\n        )\n      }\n    }\n  } else if (positionAttribute !== undefined) {\n    // non-indexed buffer geometry\n\n    if (Array.isArray(material)) {\n      for (i = 0, il = groups.length; i < il; i++) {\n        group = groups[i]\n        groupMaterial = material[group.materialIndex as number]\n\n        start = Math.max(group.start, drawRange.start)\n        end = Math.min(group.start + group.count, drawRange.start + drawRange.count)\n\n        for (j = start, jl = end; j < jl; j += 3) {\n          a = j\n          b = j + 1\n          c = j + 2\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            positionAttribute,\n            morphPosition,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedPosition,\n          )\n\n          _calculateMorphedAttributeData(\n            object,\n            groupMaterial,\n            normalAttribute,\n            morphNormal,\n            morphTargetsRelative,\n            a,\n            b,\n            c,\n            modifiedNormal,\n          )\n        }\n      }\n    } else {\n      start = Math.max(0, drawRange.start)\n      end = Math.min(positionAttribute.count, drawRange.start + drawRange.count)\n\n      for (i = start, il = end; i < il; i += 3) {\n        a = i\n        b = i + 1\n        c = i + 2\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          positionAttribute,\n          morphPosition,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedPosition,\n        )\n\n        _calculateMorphedAttributeData(\n          object,\n          material,\n          normalAttribute,\n          morphNormal,\n          morphTargetsRelative,\n          a,\n          b,\n          c,\n          modifiedNormal,\n        )\n      }\n    }\n  }\n\n  const morphedPositionAttribute = new Float32BufferAttribute(modifiedPosition, 3)\n  const morphedNormalAttribute = new Float32BufferAttribute(modifiedNormal, 3)\n\n  return {\n    positionAttribute: positionAttribute,\n    normalAttribute: normalAttribute,\n    morphedPositionAttribute: morphedPositionAttribute,\n    morphedNormalAttribute: morphedNormalAttribute,\n  }\n}\n\n/**\n * Modifies the supplied geometry if it is non-indexed, otherwise creates a new,\n * non-indexed geometry. Returns the geometry with smooth normals everywhere except\n * faces that meet at an angle greater than the crease angle.\n *\n * Backwards compatible with code such as @react-three/drei's `<RoundedBox>`\n * which uses this method to operate on the original geometry.\n *\n * As of this writing, BufferGeometry.toNonIndexed() warns if the geometry is\n * non-indexed and returns `this`, i.e. the same geometry on which it was called:\n * `BufferGeometry is already non-indexed.`\n *\n * @param geometry\n * @param creaseAngle\n */\nexport function toCreasedNormals(geometry: BufferGeometry, creaseAngle = Math.PI / 3 /* 60 degrees */): BufferGeometry {\n  const creaseDot = Math.cos(creaseAngle)\n  const hashMultiplier = (1 + 1e-10) * 1e2\n\n  // reusable vectors\n  const verts = [new Vector3(), new Vector3(), new Vector3()]\n  const tempVec1 = new Vector3()\n  const tempVec2 = new Vector3()\n  const tempNorm = new Vector3()\n  const tempNorm2 = new Vector3()\n\n  // hashes a vector\n  function hashVertex(v: Vector3): string {\n    const x = ~~(v.x * hashMultiplier)\n    const y = ~~(v.y * hashMultiplier)\n    const z = ~~(v.z * hashMultiplier)\n    return `${x},${y},${z}`\n  }\n\n  const resultGeometry = geometry.index ? geometry.toNonIndexed() : geometry\n  const posAttr = resultGeometry.attributes.position\n  const vertexMap: { [key: string]: Vector3[] } = {}\n\n  // find all the normals shared by commonly located vertices\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    const i3 = 3 * i\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0)\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1)\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2)\n\n    tempVec1.subVectors(c, b)\n    tempVec2.subVectors(a, b)\n\n    // add the normal to the map for all vertices\n    const normal = new Vector3().crossVectors(tempVec1, tempVec2).normalize()\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n]\n      const hash = hashVertex(vert)\n      if (!(hash in vertexMap)) {\n        vertexMap[hash] = []\n      }\n\n      vertexMap[hash].push(normal)\n    }\n  }\n\n  // average normals from all vertices that share a common location if they are within the\n  // provided crease threshold\n  const normalArray = new Float32Array(posAttr.count * 3)\n  const normAttr = new BufferAttribute(normalArray, 3, false)\n  for (let i = 0, l = posAttr.count / 3; i < l; i++) {\n    // get the face normal for this vertex\n    const i3 = 3 * i\n    const a = verts[0].fromBufferAttribute(posAttr, i3 + 0)\n    const b = verts[1].fromBufferAttribute(posAttr, i3 + 1)\n    const c = verts[2].fromBufferAttribute(posAttr, i3 + 2)\n\n    tempVec1.subVectors(c, b)\n    tempVec2.subVectors(a, b)\n\n    tempNorm.crossVectors(tempVec1, tempVec2).normalize()\n\n    // average all normals that meet the threshold and set the normal value\n    for (let n = 0; n < 3; n++) {\n      const vert = verts[n]\n      const hash = hashVertex(vert)\n      const otherNormals = vertexMap[hash]\n      tempNorm2.set(0, 0, 0)\n\n      for (let k = 0, lk = otherNormals.length; k < lk; k++) {\n        const otherNorm = otherNormals[k]\n        if (tempNorm.dot(otherNorm) > creaseDot) {\n          tempNorm2.add(otherNorm)\n        }\n      }\n\n      tempNorm2.normalize()\n      normAttr.setXYZ(i3 + n, tempNorm2.x, tempNorm2.y, tempNorm2.z)\n    }\n  }\n\n  resultGeometry.setAttribute('normal', normAttr)\n  return resultGeometry\n}\n"],"names":["GroundProjectedEnv","Mesh","constructor","texture","options","isCubeMap","def","isCubeTexture","cubeSize","_b","_a","image","width","_lodMax","Math","floor","log2","_cubeSize","pow","max","height","fragmentShader","concat","join","parseInt","REVISION","replace","uniforms","map","value","radius","super","IcosahedronGeometry","ShaderMaterial","vertexShader","side","DoubleSide","material","this","RGBELoader","DataTextureLoader","manager","type","HalfFloatType","parse","buffer","rgbe_error","rgbe_error_code","msg","Error","fgets","buffer2","lineLimit","consume","p","pos","i","len","s","chunk","String","fromCharCode","apply","Uint16Array","subarray","indexOf","byteLength","length","slice","RGBEByteToRGBFloat","sourceArray","sourceOffset","destArray","destOffset","e","scale","RGBEByteToRGBHalf","DataUtils","toHalfFloat","min","byteArray","Uint8Array","rgbe_header_info","gamma_re","exposure_re","format_re","dimensions_re","header","valid","string","comments","programtype","format","gamma","exposure","line","match","charAt","parseFloat","RGBE_ReadHeader","w","h","image_rgba_data","w2","h2","scanline_width","data_rgba","offset","ptr_end","rgbeStart","scanline_buffer","num_scanlines","count","ptr","isEncodedRun","byteValue","set","l","off","RGBE_ReadPixels_RLE","data","numElements","FloatType","floatArray","Float32Array","j","halfArray","setDataType","load","url","onLoad","onProgress","onError","texData","colorSpace","encoding","minFilter","LinearFilter","magFilter","generateMipmaps","flipY","u8","u16","u32","Uint32Array","fleb","fdeb","clim","freb","eb","start","b","r","fl","revfl","fd","rev","x","hMap","cd","mb","co","le","rvb","sv","r_1","v","m","flt","fdt","flrm","fdrm","a","bits","d","o","bits16","shft","slc","n","inflt","dat","buf","st","sl","noBuf","noSt","cbuf","bl","nbuf","final","f","bt","lm","dm","lbt","dbt","tbts","t","hLit","hcLen","tl","ldt","clt","clb","clbmsk","clm","c","lt","dt","lms","dms","lpos","sym","add","dsym","end","et","zlv","unzlibSync","out","td","TextDecoder","decode","stream","hasColorSpace","Texture","EXRLoader","USHORT_RANGE","HUF_DECBITS","HUF_ENCSIZE","HUF_DECSIZE","logBase","getBitsReturn","lc","getBits","nBits","uInt8Array2","inOffset","parseUint8Array","hufTableBuffer","Array","hufUnpackEncTable","inDataView","ni","im","iM","hcode","zerun","nc","hufCanonicalCodeTable","hufLength","code","hufCode","getCharReturn","getChar","getCodeReturn","getCode","po","rlc","outBuffer","outBufferOffset","outBufferEndOffset","cs","UInt16","Int16","ref","wdec14Return","wdec14","ls","hs","ai","as","bs","wdec16","bb","aa","wav2Decode","nx","ox","ny","oy","mx","p2","w14","i00","i01","i10","i11","py","ey","oy1","oy2","ox1","ox2","px","ex","p01","p11","p10","hufUncompress","nCompressed","nRaw","initialInOffset","parseUint32","freq","hdec","lit","hufClearDecTable","hdecod","pl","plOffset","hufBuildDecTable","encodingTable","decodingTable","no","outOffset","inOffsetEnd","trunc","hufDecode","predictor","source","interleaveScalar","t1","t2","stop","decodeRunLength","size","reader","DataView","getInt8","push","getUint8","unRleAC","currAcComp","acBuffer","halfZigBlock","acValue","dctComp","unZigZag","src","dst","decodeFloat16","dctInverse","cos","g","alpha","beta","theta","row","rowPtr","column","csc709Inverse","y","cb","cr","convertToHalf","idx","toLinear","float","sign","abs","uncompressRAW","info","array","uncompressRLE","compressed","viewer","rawBuffer","tmpBuffer","uncompressZIP","uncompressPIZ","scanlineBlockSize","channels","bitmap","outBufferEnd","pizChannelData","lines","minNonZero","parseUint16","maxNonZero","parseUint8","lut","maxValue","k","reverseLutFromBitmap","nData","applyLut","tmpOffset2","cp","uncompressPXR","sz","tmpBufferEnd","writePtr","pixel","uncompressDWA","dwaHeader","version","parseInt64","unknownUncompressedSize","unknownCompressedSize","acCompressedSize","dcCompressedSize","rleCompressedSize","rleUncompressedSize","rleRawSize","totalAcUncompressedCount","totalDcUncompressedCount","acCompression","EXRHeader","compression","channelRules","ruleSize","name","parseNullTerminatedString","index","Int8Array","channelData","channel","decoded","pixelType","pLinear","cscSet","offset2","rule","zlibInfo","dcBuffer","rleBuffer","rowOffsets","chan","rowPtrs","dataView","numFullBlocksX","numBlocksX","ceil","numBlocksY","leftoverX","leftoverY","currDcComp","dctData","rowBlock","comp2","blocky","maxY","maxX","blockx","fill","type2","y2","setUint16","offset3","x2","halfRow","comp","getUint16","setFloat32","lossyDctDecode","rleOffset","rowOffsetBytes","byte","uintBuffer","endOffset","stringValue","parseInt32","Int32","getInt32","Uint32","getUint32","Uint8","int","prototype","Number","getBigInt64","parseFloat32","getFloat32","decodeFloat32","binary","exponent","fraction","NaN","Infinity","Uint16","parseFloat16","parseValue","parseFixedLengthString","startOffset","xSampling","ySampling","parseChlist","redX","redY","greenX","greenY","blueX","blueY","whiteX","whiteY","parseChromaticities","parseCompression","xMin","yMin","xMax","yMax","parseBox2i","parseLineOrder","parseV2f","parseV3f","parseRational","parseTimecode","bufferDataView","uInt8Array","EXRHeader2","spec","singleTile","longName","deepFormat","multiPart","keepReading","attributeName","attributeType","attributeValue","console","warn","error","parseHeader","EXRDecoder","outputType","EXRDecoder2","dataWindow","bytesPerLine","inputSize","uncompress","getter","blockCount","outputChannels","RGBAFormat","RedFormat","setupDecoder","tmpOffset","channelOffsets","R","G","B","A","Y","scanlineBlockIdx","line_y","true_y","channelID","cOff","outIndex","getBufferForType","UnsignedByteType","Uint8ClampedArray","UnsignedIntType","ByteType","ShortType","Int16Array","IntType","Int32Array","_canReadPixelsResult","QuadRenderer","_c","_d","_e","_f","_g","_h","_j","_k","_l","_m","_o","_p","_q","_r","_rendererIsDisposable","_supportsReadPixels","render","_renderer","setRenderTarget","_renderTarget","_scene","_camera","_width","_height","_type","_colorSpace","rtOptions","depthBuffer","stencilBuffer","anisotropy","undefined","renderTargetOptions","samples","wrapS","ClampToEdgeWrapping","wrapT","_material","renderer","instantiateRenderer","Scene","OrthographicCamera","position","left","right","top","bottom","updateProjectionMatrix","canReadPixels","camera","testRT","WebGLRenderTarget","mesh","PlaneGeometry","MeshBasicMaterial","color","readRenderTargetPixels","dispose","geometry","alternativeType","extensions","has","_quad","computeBoundingBox","mapping","UVMapping","WebGLRenderer","setSize","toArray","toDataTexture","returnValue","DataTexture","LinearSRGBColorSpace","disposeOnDemandRenderer","forceContextLoss","disposeRenderTarget","renderTarget","Object","values","forEach","GainMapDecoderMaterial","_ref","offsetHdr","offsetSdr","gainMapMin","gainMapMax","maxDisplayBoost","hdrCapacityMin","hdrCapacityMax","sdr","gainMap","Vector3","fromArray","weightFactor","blending","NoBlending","depthTest","depthWrite","_maxDisplayBoost","_hdrCapacityMin","_hdrCapacityMax","needsUpdate","uniformsNeedUpdate","z","calculateWeight","val","GainMapNotFoundError","XMPMetadataNotFoundError","getAttribute","description","defaultValue","parsedValue","attributes","getNamedItem","nodeValue","node","getElementsByTagName","from","innerHTML","MPFExtractor","debug","extractFII","extractNonFII","extract","imageArrayBuffer","Promise","resolve","reject","marker","loops","toString","log","formatPt","tiffOffset","bigEnd","firstIFDOffset","dirStart","entriesStart","numberOfImages","MPImageListValPt","images","MPType","dataOffset","dependantImages","isFII","bufferBlob","Blob","imgs","imageBlob","extractGainmapFromJPEG","async","metadata","input","str","parser","DOMParser","xmpBlock","parseFromString","offsetSDR","offsetHDR","isArray","extractXMP","jpegFile","mpfExtractor","arrayBuffer","getHTMLImageFromBlob","blob","img","document","createElement","onload","onerror","URL","createObjectURL","LoaderBase","Loader","_internalLoadingManager","LoadingManager","setRenderer","setRenderTargetOptions","_renderTargetOptions","prepareQuadRenderer","quadRenderer","sdrBuffer","gainMapBuffer","gainMapBlob","sdrBlob","sdrImage","gainMapImage","needsFlip","createImageBitmap","res","all","imageOrientation","ImageData","LinearMipMapLinearFilter","SRGBColorSpace","GainMapLoader","_ref2","sdrUrl","gainMapUrl","metadataUrl","loadCheck","itemError","itemEnd","sdrLengthComputable","sdrTotal","sdrLoaded","gainMapLengthComputable","gainMapTotal","gainMapLoaded","metadataLengthComputable","metadataTotal","metadataLoaded","progressHandler","ProgressEvent","lengthComputable","loaded","total","itemStart","sdrLoader","FileLoader","setResponseType","setRequestHeader","requestHeader","setPath","path","setWithCredentials","withCredentials","gainMapLoader","metadataLoader","json","JSON","HDRJPGLoader","loader","jpeg","jpegBuffer","sdrJPEG","gainMapJPEG","extractionResult","presetsObj","apartment","city","dawn","forest","lobby","night","park","studio","sunset","warehouse","LinearEncoding","sRGBEncoding","CUBEMAP_ROOT","arr","useEnvironment","files","preset","arguments","_firstEntry$split$pop","extension","multiFile","keys","isCubemap","isGainmap","some","file","endsWith","firstEntry","startsWith","split","pop","shift","toLowerCase","CubeTextureLoader","gl","useThree","state","loaderResult","useLoader","CubeReflectionMapping","EquirectangularReflectionMapping","resolveScene","scene","isRef","obj","current","isScene","setEnvProps","background","defaultScene","sceneProps","_sceneProps$blur","_target$backgroundRot","_target$backgroundRot2","_target$environmentRo","_target$environmentRo2","backgroundBlurriness","blur","backgroundIntensity","backgroundRotation","environmentIntensity","environmentRotation","target","oldbg","oldenv","environment","oldSceneProps","clone","applyProps","EnvironmentMap","config","React","EnvironmentCube","rest","EnvironmentPortal","_ref3","children","near","far","resolution","frames","virtualScene","fbo","WebGLCubeRenderTarget","update","useFrame","createPortal","args","EnvironmentGround","props","_props$ground","_props$ground2","_scale","_props$ground3","textureDefault","extend","GroundProjectedEnvImpl","ground","_extends","Environment","_ray","Ray","_plane","Plane","TILT_LIMIT","PI","moduloWrapAround","capacity","OrbitControls","EventDispatcher","object","domElement","__publicField","LEFT","UP","RIGHT","BOTTOM","MOUSE","ROTATE","MIDDLE","DOLLY","PAN","ONE","TOUCH","TWO","DOLLY_PAN","target0","position0","zoom0","zoom","getPolarAngle","spherical","phi","getAzimuthalAngle","setPolarAngle","currentPhi","phiDist","sphericalDelta","scope","setAzimuthalAngle","currentTheta","thetaDist","getDistance","distanceTo","listenToKeyEvents","domElement2","addEventListener","onKeyDown","_domElementKeyEvents","stopListenToKeyEvents","removeEventListener","saveState","copy","reset","dispatchEvent","changeEvent","STATE","NONE","up","quat","Quaternion","setFromUnitVectors","quatInverse","invert","lastPosition","lastQuaternion","twoPI","sub","applyQuaternion","setFromVector3","autoRotate","rotateLeft","autoRotateSpeed","enableDamping","dampingFactor","minAzimuthAngle","maxAzimuthAngle","isFinite","minPolarAngle","maxPolarAngle","makeSafe","addScaledVector","panOffset","zoomToCursor","performCursorZoom","isOrthographicCamera","clampDistance","setFromSpherical","matrixAutoUpdate","updateMatrix","lookAt","multiplyScalar","zoomChanged","newRadius","PerspectiveCamera","isPerspectiveCamera","prevRadius","radiusDelta","dollyDirection","updateMatrixWorld","mouseBefore","mouse","unproject","minZoom","maxZoom","mouseAfter","screenSpacePanning","transformDirection","matrix","origin","direction","dot","setFromNormalAndCoplanarPoint","intersectPlane","distanceToSquared","EPS","quaternion","connect","style","touchAction","onContextMenu","onPointerDown","onPointerUp","onMouseWheel","ownerDocument","onPointerMove","startEvent","endEvent","TOUCH_ROTATE","TOUCH_PAN","TOUCH_DOLLY_PAN","TOUCH_DOLLY_ROTATE","Spherical","rotateStart","Vector2","rotateEnd","rotateDelta","panStart","panEnd","panDelta","dollyStart","dollyEnd","dollyDelta","pointers","pointerPositions","getZoomScale","zoomSpeed","angle","reverseOrbit","reverseHorizontalOrbit","rotateUp","reverseVerticalOrbit","panLeft","distance","objectMatrix","setFromMatrixColumn","panUp","crossVectors","pan","deltaX","deltaY","element","targetDistance","tan","fov","clientHeight","clientWidth","enablePan","dollyOut","dollyScale","enableZoom","dollyIn","updateMouseParameters","event","rect","getBoundingClientRect","clientX","clientY","normalize","dist","minDistance","maxDistance","handleMouseDownRotate","handleMouseDownPan","handleTouchStartRotate","pageX","pageY","handleTouchStartPan","handleTouchStartDolly","dx","dy","sqrt","handleTouchMoveRotate","getSecondPointerPosition","subVectors","rotateSpeed","handleTouchMovePan","panSpeed","handleTouchMoveDolly","enabled","addPointer","pointerType","trackPointer","touches","enableRotate","DOLLY_ROTATE","onTouchStart","mouseAction","button","mouseButtons","handleMouseDownDolly","ctrlKey","metaKey","shiftKey","onMouseDown","handleTouchMoveDollyPan","handleTouchMoveDollyRotate","onTouchMove","handleMouseMoveRotate","handleMouseMoveDolly","handleMouseMovePan","onMouseMove","pointerId","splice","removePointer","releasePointerCapture","preventDefault","handleMouseWheel","keyPanSpeed","handleKeyDown","pointer","makeDefault","regress","keyEvents","onChange","onStart","onEnd","restProps","invalidate","defaultCamera","events","setEvents","get","performance","explCamera","explDomElement","connected","controls","OrbitControls$1","callback","onStartCb","onEndCb","old","TextGeometry","ExtrudeGeometry","text","parameters","bevelEnabled","bevelSize","bevelThickness","font","lineHeight","letterSpacing","generateShapes","depth","FontLoader","response","loadAsync","Font","shapes","paths","chars","line_height","boundingBox","underlineThickness","offsetX","offsetY","char","ret","createPath","createPaths","toShapes","glyph","glyphs","familyName","ShapePath","cpx","cpy","cpx1","cpy1","cpx2","cpy2","outline","_cachedOutline","moveTo","lineTo","quadraticCurveTo","bezierCurveTo","ha","fontLoader","fetch","loadFontData","fontData","useFont","suspend","preload","clear","types","Text3D","fref","_font","bevelOffset","bevelSegments","curveSegments","smooth","RenamedTextGeometry","opts","useMemo","label","child","includes","getTextFromChildren","tolerance","EPSILON","hashToIndex","indices","getIndex","positions","vertexCount","nextIndex","attributeNames","attrArrays","morphAttrsArrays","newIndices","getters","morphAttr","morphAttributes","decimalShift","log10","shiftMultiplier","getX","hash","attribute","itemSize","newarray","newMorphArrays","getterFunc","ml","result","oldAttribute","BufferAttribute","normalized","setAttribute","oldMorphAttribute","morphAttribute","setIndex","mergeVertices","computeVertexNormals"],"sourceRoot":""}